!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l="1.11.3",m=function(a,b){return new m.fn.init(a,b)},n=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,o=/^-ms-/,p=/-([\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:"jQuery"+(l+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===m.type(a)},isArray:Array.isArray||function(a){return"array"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,"constructor")&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,"ms-").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(n,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function r(a){var b="length"in a&&a.length,c=m.type(a);return"function"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);m.find=s,m.expr=s.selectors,m.expr[":"]=m.expr.pseudos,m.unique=s.uniqueSort,m.text=s.getText,m.isXMLDoc=s.isXML,m.contains=s.contains;var t=m.expr.match.needsContext,u=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,v=/^.[^:#\[\.,]*$/;function w(a,b,c){if(m.isFunction(b))return m.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return m.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(v.test(b))return m.filter(b,a,c);b=m.filter(b,a)}return m.grep(a,function(a){return m.inArray(a,b)>=0!==c})}m.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?m.find.matchesSelector(d,a)?[d]:[]:m.find.matches(a,m.grep(b,function(a){return 1===a.nodeType}))},m.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(m(a).filter(function(){for(b=0;e>b;b++)if(m.contains(d[b],this))return!0}));for(b=0;e>b;b++)m.find(a,d[b],c);return c=this.pushStack(e>1?m.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(w(this,a||[],!1))},not:function(a){return this.pushStack(w(this,a||[],!0))},is:function(a){return!!w(this,"string"==typeof a&&t.test(a)?m(a):a||[],!1).length}});var x,y=a.document,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=m.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||x).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof m?b[0]:b,m.merge(this,m.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:y,!0)),u.test(c[1])&&m.isPlainObject(b))for(c in b)m.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=y.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return x.find(a);this.length=1,this[0]=d}return this.context=y,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):m.isFunction(a)?"undefined"!=typeof x.ready?x.ready(a):a(m):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),m.makeArray(a,this))};A.prototype=m.fn,x=m(y);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};m.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!m(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),m.fn.extend({has:function(a){var b,c=m(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(m.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=t.test(a)||"string"!=typeof a?m(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&m.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?m.unique(f):f)},index:function(a){return a?"string"==typeof a?m.inArray(this[0],m(a)):m.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(m.unique(m.merge(this.get(),m(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}m.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return m.dir(a,"parentNode")},parentsUntil:function(a,b,c){return m.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return m.dir(a,"nextSibling")},prevAll:function(a){return m.dir(a,"previousSibling")},nextUntil:function(a,b,c){return m.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return m.dir(a,"previousSibling",c)},siblings:function(a){return m.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return m.sibling(a.firstChild)},contents:function(a){return m.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:m.merge([],a.childNodes)}},function(a,b){m.fn[a]=function(c,d){var e=m.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=m.filter(d,e)),this.length>1&&(C[a]||(e=m.unique(e)),B.test(a)&&(e=e.reverse())),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return m.each(a.match(E)||[],function(a,c){b[c]=!0}),b}m.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):m.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){m.each(b,function(b,c){var d=m.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&m.each(arguments,function(a,c){var d;while((d=m.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?m.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},m.extend({Deferred:function(a){var b=[["resolve","done",m.Callbacks("once memory"),"resolved"],["reject","fail",m.Callbacks("once memory"),"rejected"],["notify","progress",m.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return m.Deferred(function(c){m.each(b,function(b,f){var g=m.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&m.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?m.extend(a,d):d}},e={};return d.pipe=d.then,m.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&m.isFunction(a.promise)?e:0,g=1===f?a:m.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&m.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;m.fn.ready=function(a){return m.ready.promise().done(a),this},m.extend({isReady:!1,readyWait:1,holdReady:function(a){a?m.readyWait++:m.ready(!0)},ready:function(a){if(a===!0?!--m.readyWait:!m.isReady){if(!y.body)return setTimeout(m.ready);m.isReady=!0,a!==!0&&--m.readyWait>0||(H.resolveWith(y,[m]),m.fn.triggerHandler&&(m(y).triggerHandler("ready"),m(y).off("ready")))}}});function I(){y.addEventListener?(y.removeEventListener("DOMContentLoaded",J,!1),a.removeEventListener("load",J,!1)):(y.detachEvent("onreadystatechange",J),a.detachEvent("onload",J))}function J(){(y.addEventListener||"load"===event.type||"complete"===y.readyState)&&(I(),m.ready())}m.ready.promise=function(b){if(!H)if(H=m.Deferred(),"complete"===y.readyState)setTimeout(m.ready);else if(y.addEventListener)y.addEventListener("DOMContentLoaded",J,!1),a.addEventListener("load",J,!1);else{y.attachEvent("onreadystatechange",J),a.attachEvent("onload",J);var c=!1;try{c=null==a.frameElement&&y.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!m.isReady){try{c.doScroll("left")}catch(a){return setTimeout(e,50)}I(),m.ready()}}()}return H.promise(b)};var K="undefined",L;for(L in m(k))break;k.ownLast="0"!==L,k.inlineBlockNeedsLayout=!1,m(function(){var a,b,c,d;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",k.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(d))}),function(){var a=y.createElement("div");if(null==k.deleteExpando){k.deleteExpando=!0;try{delete a.test}catch(b){k.deleteExpando=!1}}a=null}(),m.acceptData=function(a){var b=m.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b};var M=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,N=/([A-Z])/g;function O(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(N,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:M.test(c)?m.parseJSON(c):c}catch(e){}m.data(a,b,c)}else c=void 0}return c}function P(a){var b;for(b in a)if(("data"!==b||!m.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;

return!0}function Q(a,b,d,e){if(m.acceptData(a)){var f,g,h=m.expando,i=a.nodeType,j=i?m.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||m.guid++:h),j[k]||(j[k]=i?{}:{toJSON:m.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=m.extend(j[k],b):j[k].data=m.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[m.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[m.camelCase(b)])):f=g,f}}function R(a,b,c){if(m.acceptData(a)){var d,e,f=a.nodeType,g=f?m.cache:a,h=f?a[m.expando]:m.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){m.isArray(b)?b=b.concat(m.map(b,m.camelCase)):b in d?b=[b]:(b=m.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!P(d):!m.isEmptyObject(d))return}(c||(delete g[h].data,P(g[h])))&&(f?m.cleanData([a],!0):k.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}m.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?m.cache[a[m.expando]]:a[m.expando],!!a&&!P(a)},data:function(a,b,c){return Q(a,b,c)},removeData:function(a,b){return R(a,b)},_data:function(a,b,c){return Q(a,b,c,!0)},_removeData:function(a,b){return R(a,b,!0)}}),m.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=m.data(f),1===f.nodeType&&!m._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=m.camelCase(d.slice(5)),O(f,d,e[d])));m._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){m.data(this,a)}):arguments.length>1?this.each(function(){m.data(this,a,b)}):f?O(f,a,m.data(f,a)):void 0},removeData:function(a){return this.each(function(){m.removeData(this,a)})}}),m.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=m._data(a,b),c&&(!d||m.isArray(c)?d=m._data(a,b,m.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=m.queue(a,b),d=c.length,e=c.shift(),f=m._queueHooks(a,b),g=function(){m.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return m._data(a,c)||m._data(a,c,{empty:m.Callbacks("once memory").add(function(){m._removeData(a,b+"queue"),m._removeData(a,c)})})}}),m.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?m.queue(this[0],a):void 0===b?this:this.each(function(){var c=m.queue(this,a,b);m._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&m.dequeue(this,a)})},dequeue:function(a){return this.each(function(){m.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=m.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=m._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=["Top","Right","Bottom","Left"],U=function(a,b){return a=b||a,"none"===m.css(a,"display")||!m.contains(a.ownerDocument,a)},V=m.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===m.type(c)){e=!0;for(h in c)m.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,m.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(m(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},W=/^(?:checkbox|radio)$/i;!function(){var a=y.createElement("input"),b=y.createElement("div"),c=y.createDocumentFragment();if(b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",k.leadingWhitespace=3===b.firstChild.nodeType,k.tbody=!b.getElementsByTagName("tbody").length,k.htmlSerialize=!!b.getElementsByTagName("link").length,k.html5Clone="<:nav></:nav>"!==y.createElement("nav").cloneNode(!0).outerHTML,a.type="checkbox",a.checked=!0,c.appendChild(a),k.appendChecked=a.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,c.appendChild(b),b.innerHTML="<input type='radio' checked='checked' name='t'/>",k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,k.noCloneEvent=!0,b.attachEvent&&(b.attachEvent("onclick",function(){k.noCloneEvent=!1}),b.cloneNode(!0).click()),null==k.deleteExpando){k.deleteExpando=!0;try{delete b.test}catch(d){k.deleteExpando=!1}}}(),function(){var b,c,d=y.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(k[b+"Bubbles"]=c in a)||(d.setAttribute(c,"t"),k[b+"Bubbles"]=d.attributes[c].expando===!1);d=null}();var X=/^(?:input|select|textarea)$/i,Y=/^key/,Z=/^(?:mouse|pointer|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=/^([^.]*)(?:\.(.+)|)$/;function aa(){return!0}function ba(){return!1}function ca(){try{return y.activeElement}catch(a){}}m.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=m.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof m===K||a&&m.event.triggered===a.type?void 0:m.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(E)||[""],h=b.length;while(h--)f=_.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=m.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=m.event.special[o]||{},l=m.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&m.expr.match.needsContext.test(e),namespace:p.join(".")},i),(n=g[o])||(n=g[o]=[],n.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?n.splice(n.delegateCount++,0,l):n.push(l),m.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m.hasData(a)&&m._data(a);if(r&&(k=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=_.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=m.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,n=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=n.length;while(f--)g=n[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(n.splice(f,1),g.selector&&n.delegateCount--,l.remove&&l.remove.call(a,g));i&&!n.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||m.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)m.event.remove(a,o+b[j],c,d,!0);m.isEmptyObject(k)&&(delete r.handle,m._removeData(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,n,o=[d||y],p=j.call(b,"type")?b.type:b,q=j.call(b,"namespace")?b.namespace.split("."):[];if(h=l=d=d||y,3!==d.nodeType&&8!==d.nodeType&&!$.test(p+m.event.triggered)&&(p.indexOf(".")>=0&&(q=p.split("."),p=q.shift(),q.sort()),g=p.indexOf(":")<0&&"on"+p,b=b[m.expando]?b:new m.Event(p,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:m.makeArray(c,[b]),k=m.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!m.isWindow(d)){for(i=k.delegateType||p,$.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||y)&&o.push(l.defaultView||l.parentWindow||a)}n=0;while((h=o[n++])&&!b.isPropagationStopped())b.type=n>1?i:k.bindType||p,f=(m._data(h,"events")||{})[b.type]&&m._data(h,"handle"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&m.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&m.acceptData(d)&&g&&d[p]&&!m.isWindow(d)){l=d[g],l&&(d[g]=null),m.event.triggered=p;try{d[p]()}catch(r){}m.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=m.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(m._data(this,"events")||{})[a.type]||[],k=m.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=m.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((m.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+" ",void 0===e[c]&&(e[c]=d.needsContext?m(c,this).index(i)>=0:m.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[m.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=Z.test(e)?this.mouseHooks:Y.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new m.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||y),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||y,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ca()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===ca()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return m.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return m.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=m.extend(new m.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?m.event.trigger(e,null,b):m.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},m.removeEvent=y.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]===K&&(a[d]=null),a.detachEvent(d,c))},m.Event=function(a,b){return this instanceof m.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?aa:ba):this.type=a,b&&m.extend(this,b),this.timeStamp=a&&a.timeStamp||m.now(),void(this[m.expando]=!0)):new m.Event(a,b)},m.Event.prototype={isDefaultPrevented:ba,isPropagationStopped:ba,isImmediatePropagationStopped:ba,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=aa,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=aa,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=aa,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},m.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){m.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!m.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.submitBubbles||(m.event.special.submit={setup:function(){return m.nodeName(this,"form")?!1:void m.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=m.nodeName(b,"input")||m.nodeName(b,"button")?b.form:void 0;c&&!m._data(c,"submitBubbles")&&(m.event.add(c,"submit._submit",function(a){a._submit_bubble=!0}),m._data(c,"submitBubbles",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&m.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){return m.nodeName(this,"form")?!1:void m.event.remove(this,"._submit")}}),k.changeBubbles||(m.event.special.change={setup:function(){return X.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(m.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._just_changed=!0)}),m.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),m.event.simulate("change",this,a,!0)})),!1):void m.event.add(this,"beforeactivate._change",function(a){var b=a.target;X.test(b.nodeName)&&!m._data(b,"changeBubbles")&&(m.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||m.event.simulate("change",this.parentNode,a,!0)}),m._data(b,"changeBubbles",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return m.event.remove(this,"._change"),!X.test(this.nodeName)}}),k.focusinBubbles||m.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){m.event.simulate(b,a.target,m.event.fix(a),!0)};m.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=m._data(d,b);e||d.addEventListener(a,c,!0),m._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=m._data(d,b)-1;e?m._data(d,b,e):(d.removeEventListener(a,c,!0),m._removeData(d,b))}}}),m.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=ba;else if(!d)return this;return 1===e&&(g=d,d=function(a){return m().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=m.guid++)),this.each(function(){m.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,m(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=ba),this.each(function(){m.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){m.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?m.event.trigger(a,b,c,!0):void 0}});function da(a){var b=ea.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var ea="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",fa=/ jQuery\d+="(?:null|\d+)"/g,ga=new RegExp("<(?:"+ea+")[\\s/>]","i"),ha=/^\s+/,ia=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ja=/<([\w:]+)/,ka=/<tbody/i,la=/<|&#?\w+;/,ma=/<(?:script|style|link)/i,na=/checked\s*(?:[^=]|=\s*.checked.)/i,oa=/^$|\/(?:java|ecma)script/i,pa=/^true\/(.*)/,qa=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ra={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:k.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},sa=da(y),ta=sa.appendChild(y.createElement("div"));ra.optgroup=ra.option,ra.tbody=ra.tfoot=ra.colgroup=ra.caption=ra.thead,ra.th=ra.td;function ua(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==K?a.getElementsByTagName(b||"*"):typeof a.querySelectorAll!==K?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||m.nodeName(d,b)?f.push(d):m.merge(f,ua(d,b));return void 0===b||b&&m.nodeName(a,b)?m.merge([a],f):f}function va(a){W.test(a.type)&&(a.defaultChecked=a.checked)}function wa(a,b){return m.nodeName(a,"table")&&m.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function xa(a){return a.type=(null!==m.find.attr(a,"type"))+"/"+a.type,a}function ya(a){var b=pa.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function za(a,b){for(var c,d=0;null!=(c=a[d]);d++)m._data(c,"globalEval",!b||m._data(b[d],"globalEval"))}function Aa(a,b){if(1===b.nodeType&&m.hasData(a)){var c,d,e,f=m._data(a),g=m._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)m.event.add(b,c,h[c][d])}g.data&&(g.data=m.extend({},g.data))}}function Ba(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!k.noCloneEvent&&b[m.expando]){e=m._data(b);for(d in e.events)m.removeEvent(b,d,e.handle);b.removeAttribute(m.expando)}"script"===c&&b.text!==a.text?(xa(b).text=a.text,ya(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),k.html5Clone&&a.innerHTML&&!m.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&W.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}m.extend({clone:function(a,b,c){var d,e,f,g,h,i=m.contains(a.ownerDocument,a);if(k.html5Clone||m.isXMLDoc(a)||!ga.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(ta.innerHTML=a.outerHTML,ta.removeChild(f=ta.firstChild)),!(k.noCloneEvent&&k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||m.isXMLDoc(a)))for(d=ua(f),h=ua(a),g=0;null!=(e=h[g]);++g)d[g]&&Ba(e,d[g]);if(b)if(c)for(h=h||ua(a),d=d||ua(f),g=0;null!=(e=h[g]);g++)Aa(e,d[g]);else Aa(a,f);return d=ua(f,"script"),d.length>0&&za(d,!i&&ua(a,"script")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,l,n=a.length,o=da(b),p=[],q=0;n>q;q++)if(f=a[q],f||0===f)if("object"===m.type(f))m.merge(p,f.nodeType?[f]:f);else if(la.test(f)){h=h||o.appendChild(b.createElement("div")),i=(ja.exec(f)||["",""])[1].toLowerCase(),l=ra[i]||ra._default,h.innerHTML=l[1]+f.replace(ia,"<$1></$2>")+l[2],e=l[0];while(e--)h=h.lastChild;if(!k.leadingWhitespace&&ha.test(f)&&p.push(b.createTextNode(ha.exec(f)[0])),!k.tbody){f="table"!==i||ka.test(f)?"<table>"!==l[1]||ka.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)m.nodeName(j=f.childNodes[e],"tbody")&&!j.childNodes.length&&f.removeChild(j)}m.merge(p,h.childNodes),h.textContent="";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),k.appendChecked||m.grep(ua(p,"input"),va),q=0;while(f=p[q++])if((!d||-1===m.inArray(f,d))&&(g=m.contains(f.ownerDocument,f),h=ua(o.appendChild(f),"script"),g&&za(h),c)){e=0;while(f=h[e++])oa.test(f.type||"")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=m.expando,j=m.cache,l=k.deleteExpando,n=m.event.special;null!=(d=a[h]);h++)if((b||m.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)n[e]?m.event.remove(d,e):m.removeEvent(d,e,g.handle);j[f]&&(delete j[f],l?delete d[i]:typeof d.removeAttribute!==K?d.removeAttribute(i):d[i]=null,c.push(f))}}}),m.fn.extend({text:function(a){return V(this,function(a){return void 0===a?m.text(this):this.empty().append((this[0]&&this[0].ownerDocument||y).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?m.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||m.cleanData(ua(c)),c.parentNode&&(b&&m.contains(c.ownerDocument,c)&&za(ua(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&m.cleanData(ua(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&m.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return m.clone(this,a,b)})},html:function(a){return V(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(fa,""):void 0;if(!("string"!=typeof a||ma.test(a)||!k.htmlSerialize&&ga.test(a)||!k.leadingWhitespace&&ha.test(a)||ra[(ja.exec(a)||["",""])[1].toLowerCase()])){a=a.replace(ia,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(m.cleanData(ua(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,m.cleanData(ua(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,n=this,o=l-1,p=a[0],q=m.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&na.test(p))return this.each(function(c){var d=n.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(i=m.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=m.map(ua(i,"script"),xa),f=g.length;l>j;j++)d=i,j!==o&&(d=m.clone(d,!0,!0),f&&m.merge(g,ua(d,"script"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,m.map(g,ya),j=0;f>j;j++)d=g[j],oa.test(d.type||"")&&!m._data(d,"globalEval")&&m.contains(h,d)&&(d.src?m._evalUrl&&m._evalUrl(d.src):m.globalEval((d.text||d.textContent||d.innerHTML||"").replace(qa,"")));i=c=null}return this}}),m.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){m.fn[a]=function(a){for(var c,d=0,e=[],g=m(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),m(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Ca,Da={};function Ea(b,c){var d,e=m(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:m.css(e[0],"display");return e.detach(),f}function Fa(a){var b=y,c=Da[a];return c||(c=Ea(a,b),"none"!==c&&c||(Ca=(Ca||m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Ca[0].contentWindow||Ca[0].contentDocument).document,b.write(),b.close(),c=Ea(a,b),Ca.detach()),Da[a]=c),c}!function(){var a;k.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,d;return c=y.getElementsByTagName("body")[0],c&&c.style?(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(y.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(d),a):void 0}}();var Ga=/^margin/,Ha=new RegExp("^("+S+")(?!px)[a-z%]+$","i"),Ia,Ja,Ka=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ia=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||m.contains(a.ownerDocument,a)||(g=m.style(a,b)),Ha.test(g)&&Ga.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):y.documentElement.currentStyle&&(Ia=function(a){return a.currentStyle},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Ha.test(g)&&!Ka.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function La(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h;if(b=y.createElement("div"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=d&&d.style){c.cssText="float:left;opacity:.5",k.opacity="0.5"===c.opacity,k.cssFloat=!!c.cssFloat,b.style.backgroundClip="content-box",b.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===b.style.backgroundClip,k.boxSizing=""===c.boxSizing||""===c.MozBoxSizing||""===c.WebkitBoxSizing,m.extend(k,{reliableHiddenOffsets:function(){return null==g&&i(),g},boxSizingReliable:function(){return null==f&&i(),f},pixelPosition:function(){return null==e&&i(),e},reliableMarginRight:function(){return null==h&&i(),h}});function i(){var b,c,d,i;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),b.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",e=f=!1,h=!0,a.getComputedStyle&&(e="1%"!==(a.getComputedStyle(b,null)||{}).top,f="4px"===(a.getComputedStyle(b,null)||{width:"4px"}).width,i=b.appendChild(y.createElement("div")),i.style.cssText=b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",i.style.marginRight=i.style.width="0",b.style.width="1px",h=!parseFloat((a.getComputedStyle(i,null)||{}).marginRight),b.removeChild(i)),b.innerHTML="<table><tr><td></td><td>t</td></tr></table>",i=b.getElementsByTagName("td"),i[0].style.cssText="margin:0;border:0;padding:0;display:none",g=0===i[0].offsetHeight,g&&(i[0].style.display="",i[1].style.display="none",g=0===i[0].offsetHeight),c.removeChild(d))}}}(),m.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Ma=/alpha\([^)]*\)/i,Na=/opacity\s*=\s*([^)]*)/,Oa=/^(none|table(?!-c[ea]).+)/,Pa=new RegExp("^("+S+")(.*)$","i"),Qa=new RegExp("^([+-])=("+S+")","i"),Ra={position:"absolute",visibility:"hidden",display:"block"},Sa={letterSpacing:"0",fontWeight:"400"},Ta=["Webkit","O","Moz","ms"];function Ua(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Ta.length;while(e--)if(b=Ta[e]+c,b in a)return b;return d}function Va(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=m._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&U(d)&&(f[g]=m._data(d,"olddisplay",Fa(d.nodeName)))):(e=U(d),(c&&"none"!==c||!e)&&m._data(d,"olddisplay",e?c:m.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function Wa(a,b,c){var d=Pa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Xa(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=m.css(a,c+T[f],!0,e)),d?("content"===c&&(g-=m.css(a,"padding"+T[f],!0,e)),"margin"!==c&&(g-=m.css(a,"border"+T[f]+"Width",!0,e))):(g+=m.css(a,"padding"+T[f],!0,e),"padding"!==c&&(g+=m.css(a,"border"+T[f]+"Width",!0,e)));return g}function Ya(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ia(a),g=k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Ja(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ha.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Xa(a,b,c||(g?"border":"content"),d,f)+"px"}m.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Ja(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":k.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=m.camelCase(b),i=a.style;if(b=m.cssProps[h]||(m.cssProps[h]=Ua(i,h)),g=m.cssHooks[b]||m.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=Qa.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(m.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||m.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=m.camelCase(b);return b=m.cssProps[h]||(m.cssProps[h]=Ua(a.style,h)),g=m.cssHooks[b]||m.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Ja(a,b,d)),"normal"===f&&b in Sa&&(f=Sa[b]),""===c||c?(e=parseFloat(f),c===!0||m.isNumeric(e)?e||0:f):f}}),m.each(["height","width"],function(a,b){m.cssHooks[b]={get:function(a,c,d){return c?Oa.test(m.css(a,"display"))&&0===a.offsetWidth?m.swap(a,Ra,function(){return Ya(a,b,d)}):Ya(a,b,d):void 0},set:function(a,c,d){var e=d&&Ia(a);return Wa(a,c,d?Xa(a,b,d,k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,e),e):0)}}}),k.opacity||(m.cssHooks.opacity={get:function(a,b){return Na.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=m.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===m.trim(f.replace(Ma,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Ma.test(f)?f.replace(Ma,e):f+" "+e)}}),m.cssHooks.marginRight=La(k.reliableMarginRight,function(a,b){return b?m.swap(a,{display:"inline-block"},Ja,[a,"marginRight"]):void 0}),m.each({margin:"",padding:"",border:"Width"},function(a,b){m.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+T[d]+b]=f[d]||f[d-2]||f[0];return e}},Ga.test(a)||(m.cssHooks[a+b].set=Wa)}),m.fn.extend({css:function(a,b){return V(this,function(a,b,c){var d,e,f={},g=0;if(m.isArray(b)){for(d=Ia(a),e=b.length;e>g;g++)f[b[g]]=m.css(a,b[g],!1,d);return f}return void 0!==c?m.style(a,b,c):m.css(a,b)},a,b,arguments.length>1)},show:function(){return Va(this,!0)},hide:function(){return Va(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){U(this)?m(this).show():m(this).hide()})}});function Za(a,b,c,d,e){
return new Za.prototype.init(a,b,c,d,e)}m.Tween=Za,Za.prototype={constructor:Za,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(m.cssNumber[c]?"":"px")},cur:function(){var a=Za.propHooks[this.prop];return a&&a.get?a.get(this):Za.propHooks._default.get(this)},run:function(a){var b,c=Za.propHooks[this.prop];return this.options.duration?this.pos=b=m.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Za.propHooks._default.set(this),this}},Za.prototype.init.prototype=Za.prototype,Za.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=m.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){m.fx.step[a.prop]?m.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[m.cssProps[a.prop]]||m.cssHooks[a.prop])?m.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Za.propHooks.scrollTop=Za.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},m.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},m.fx=Za.prototype.init,m.fx.step={};var $a,_a,ab=/^(?:toggle|show|hide)$/,bb=new RegExp("^(?:([+-])=|)("+S+")([a-z%]*)$","i"),cb=/queueHooks$/,db=[ib],eb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=bb.exec(b),f=e&&e[3]||(m.cssNumber[a]?"":"px"),g=(m.cssNumber[a]||"px"!==f&&+d)&&bb.exec(m.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,m.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function fb(){return setTimeout(function(){$a=void 0}),$a=m.now()}function gb(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=T[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function hb(a,b,c){for(var d,e=(eb[b]||[]).concat(eb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,l,n=this,o={},p=a.style,q=a.nodeType&&U(a),r=m._data(a,"fxshow");c.queue||(h=m._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,n.always(function(){n.always(function(){h.unqueued--,m.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=m.css(a,"display"),l="none"===j?m._data(a,"olddisplay")||Fa(a.nodeName):j,"inline"===l&&"none"===m.css(a,"float")&&(k.inlineBlockNeedsLayout&&"inline"!==Fa(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",k.shrinkWrapBlocks()||n.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],ab.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||m.style(a,d)}else j=void 0;if(m.isEmptyObject(o))"inline"===("none"===j?Fa(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=m._data(a,"fxshow",{}),f&&(r.hidden=!q),q?m(a).show():n.done(function(){m(a).hide()}),n.done(function(){var b;m._removeData(a,"fxshow");for(b in o)m.style(a,b,o[b])});for(d in o)g=hb(q?r[d]:0,d,n),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=m.camelCase(c),e=b[d],f=a[c],m.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=m.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=db.length,h=m.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=$a||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:m.extend({},b),opts:m.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:$a||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=m.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);g>f;f++)if(d=db[f].call(j,a,k,j.opts))return d;return m.map(k,hb,j),m.isFunction(j.opts.start)&&j.opts.start.call(a,j),m.fx.timer(m.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}m.Animation=m.extend(kb,{tweener:function(a,b){m.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],eb[c]=eb[c]||[],eb[c].unshift(b)},prefilter:function(a,b){b?db.unshift(a):db.push(a)}}),m.speed=function(a,b,c){var d=a&&"object"==typeof a?m.extend({},a):{complete:c||!c&&b||m.isFunction(a)&&a,duration:a,easing:c&&b||b&&!m.isFunction(b)&&b};return d.duration=m.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in m.fx.speeds?m.fx.speeds[d.duration]:m.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){m.isFunction(d.old)&&d.old.call(this),d.queue&&m.dequeue(this,d.queue)},d},m.fn.extend({fadeTo:function(a,b,c,d){return this.filter(U).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=m.isEmptyObject(a),f=m.speed(b,c,d),g=function(){var b=kb(this,m.extend({},a),f);(e||m._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=m.timers,g=m._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&cb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&m.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=m._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=m.timers,g=d?d.length:0;for(c.finish=!0,m.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),m.each(["toggle","show","hide"],function(a,b){var c=m.fn[b];m.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),m.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){m.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),m.timers=[],m.fx.tick=function(){var a,b=m.timers,c=0;for($a=m.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||m.fx.stop(),$a=void 0},m.fx.timer=function(a){m.timers.push(a),a()?m.fx.start():m.timers.pop()},m.fx.interval=13,m.fx.start=function(){_a||(_a=setInterval(m.fx.tick,m.fx.interval))},m.fx.stop=function(){clearInterval(_a),_a=null},m.fx.speeds={slow:600,fast:200,_default:400},m.fn.delay=function(a,b){return a=m.fx?m.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e;b=y.createElement("div"),b.setAttribute("className","t"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=y.createElement("select"),e=c.appendChild(y.createElement("option")),a=b.getElementsByTagName("input")[0],d.style.cssText="top:1px",k.getSetAttribute="t"!==b.className,k.style=/top/.test(d.getAttribute("style")),k.hrefNormalized="/a"===d.getAttribute("href"),k.checkOn=!!a.value,k.optSelected=e.selected,k.enctype=!!y.createElement("form").enctype,c.disabled=!0,k.optDisabled=!e.disabled,a=y.createElement("input"),a.setAttribute("value",""),k.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),k.radioValue="t"===a.value}();var lb=/\r/g;m.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=m.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,m(this).val()):a,null==e?e="":"number"==typeof e?e+="":m.isArray(e)&&(e=m.map(e,function(a){return null==a?"":a+""})),b=m.valHooks[this.type]||m.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=m.valHooks[e.type]||m.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(lb,""):null==c?"":c)}}}),m.extend({valHooks:{option:{get:function(a){var b=m.find.attr(a,"value");return null!=b?b:m.trim(m.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&m.nodeName(c.parentNode,"optgroup"))){if(b=m(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=m.makeArray(b),g=e.length;while(g--)if(d=e[g],m.inArray(m.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),m.each(["radio","checkbox"],function(){m.valHooks[this]={set:function(a,b){return m.isArray(b)?a.checked=m.inArray(m(a).val(),b)>=0:void 0}},k.checkOn||(m.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var mb,nb,ob=m.expr.attrHandle,pb=/^(?:checked|selected)$/i,qb=k.getSetAttribute,rb=k.input;m.fn.extend({attr:function(a,b){return V(this,m.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){m.removeAttr(this,a)})}}),m.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===K?m.prop(a,b,c):(1===f&&m.isXMLDoc(a)||(b=b.toLowerCase(),d=m.attrHooks[b]||(m.expr.match.bool.test(b)?nb:mb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=m.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void m.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=m.propFix[c]||c,m.expr.match.bool.test(c)?rb&&qb||!pb.test(c)?a[d]=!1:a[m.camelCase("default-"+c)]=a[d]=!1:m.attr(a,c,""),a.removeAttribute(qb?c:d)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&m.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),nb={set:function(a,b,c){return b===!1?m.removeAttr(a,c):rb&&qb||!pb.test(c)?a.setAttribute(!qb&&m.propFix[c]||c,c):a[m.camelCase("default-"+c)]=a[c]=!0,c}},m.each(m.expr.match.bool.source.match(/\w+/g),function(a,b){var c=ob[b]||m.find.attr;ob[b]=rb&&qb||!pb.test(b)?function(a,b,d){var e,f;return d||(f=ob[b],ob[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,ob[b]=f),e}:function(a,b,c){return c?void 0:a[m.camelCase("default-"+b)]?b.toLowerCase():null}}),rb&&qb||(m.attrHooks.value={set:function(a,b,c){return m.nodeName(a,"input")?void(a.defaultValue=b):mb&&mb.set(a,b,c)}}),qb||(mb={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},ob.id=ob.name=ob.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},m.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:mb.set},m.attrHooks.contenteditable={set:function(a,b,c){mb.set(a,""===b?!1:b,c)}},m.each(["width","height"],function(a,b){m.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),k.style||(m.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var sb=/^(?:input|select|textarea|button|object)$/i,tb=/^(?:a|area)$/i;m.fn.extend({prop:function(a,b){return V(this,m.prop,a,b,arguments.length>1)},removeProp:function(a){return a=m.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),m.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!m.isXMLDoc(a),f&&(b=m.propFix[b]||b,e=m.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=m.find.attr(a,"tabindex");return b?parseInt(b,10):sb.test(a.nodeName)||tb.test(a.nodeName)&&a.href?0:-1}}}}),k.hrefNormalized||m.each(["href","src"],function(a,b){m.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),k.optSelected||(m.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),m.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){m.propFix[this.toLowerCase()]=this}),k.enctype||(m.propFix.enctype="encoding");var ub=/[\t\r\n\f]/g;m.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j="string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=m.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||"string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?m.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(m.isFunction(a)?function(c){m(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=m(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===K||"boolean"===c)&&(this.className&&m._data(this,"__className__",this.className),this.className=this.className||a===!1?"":m._data(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ub," ").indexOf(b)>=0)return!0;return!1}}),m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){m.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),m.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var vb=m.now(),wb=/\?/,xb=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;m.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=m.trim(b+"");return e&&!m.trim(e.replace(xb,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():m.error("Invalid JSON: "+b)},m.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,"text/xml")):(c=new ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||m.error("Invalid XML: "+b),c};var yb,zb,Ab=/#.*$/,Bb=/([?&])_=[^&]*/,Cb=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Db=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Eb=/^(?:GET|HEAD)$/,Fb=/^\/\//,Gb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Hb={},Ib={},Jb="*/".concat("*");try{zb=location.href}catch(Kb){zb=y.createElement("a"),zb.href="",zb=zb.href}yb=Gb.exec(zb.toLowerCase())||[];function Lb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(m.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Mb(a,b,c,d){var e={},f=a===Ib;function g(h){var i;return e[h]=!0,m.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Nb(a,b){var c,d,e=m.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&m.extend(!0,a,c),a}function Ob(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Pb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}m.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:zb,type:"GET",isLocal:Db.test(yb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Jb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":m.parseJSON,"text xml":m.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Nb(Nb(a,m.ajaxSettings),b):Nb(m.ajaxSettings,a)},ajaxPrefilter:Lb(Hb),ajaxTransport:Lb(Ib),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=m.ajaxSetup({},b),l=k.context||k,n=k.context&&(l.nodeType||l.jquery)?m(l):m.event,o=m.Deferred(),p=m.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Cb.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||zb)+"").replace(Ab,"").replace(Fb,yb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=m.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(c=Gb.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===yb[1]&&c[2]===yb[2]&&(c[3]||("http:"===c[1]?"80":"443"))===(yb[3]||("http:"===yb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=m.param(k.data,k.traditional)),Mb(Hb,k,b,v),2===t)return v;h=m.event&&k.global,h&&0===m.active++&&m.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!Eb.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(wb.test(e)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=Bb.test(e)?e.replace(Bb,"$1_="+vb++):e+(wb.test(e)?"&":"?")+"_="+vb++)),k.ifModified&&(m.lastModified[e]&&v.setRequestHeader("If-Modified-Since",m.lastModified[e]),m.etag[e]&&v.setRequestHeader("If-None-Match",m.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+Jb+"; q=0.01":""):k.accepts["*"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Mb(Ib,k,b,v)){v.readyState=1,h&&n.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Ob(k,v,c)),u=Pb(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(m.lastModified[e]=w),w=v.getResponseHeader("etag"),w&&(m.etag[e]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&n.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(n.trigger("ajaxComplete",[v,k]),--m.active||m.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return m.get(a,b,c,"json")},getScript:function(a,b){return m.get(a,void 0,b,"script")}}),m.each(["get","post"],function(a,b){m[b]=function(a,c,d,e){return m.isFunction(c)&&(e=e||d,d=c,c=void 0),m.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),m._evalUrl=function(a){return m.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},m.fn.extend({wrapAll:function(a){if(m.isFunction(a))return this.each(function(b){m(this).wrapAll(a.call(this,b))});if(this[0]){var b=m(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(m.isFunction(a)?function(b){m(this).wrapInner(a.call(this,b))}:function(){var b=m(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=m.isFunction(a);return this.each(function(c){m(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){m.nodeName(this,"body")||m(this).replaceWith(this.childNodes)}).end()}}),m.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!k.reliableHiddenOffsets()&&"none"===(a.style&&a.style.display||m.css(a,"display"))},m.expr.filters.visible=function(a){return!m.expr.filters.hidden(a)};var Qb=/%20/g,Rb=/\[\]$/,Sb=/\r?\n/g,Tb=/^(?:submit|button|image|reset|file)$/i,Ub=/^(?:input|select|textarea|keygen)/i;function Vb(a,b,c,d){var e;if(m.isArray(b))m.each(b,function(b,e){c||Rb.test(a)?d(a,e):Vb(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==m.type(b))d(a,b);else for(e in b)Vb(a+"["+e+"]",b[e],c,d)}m.param=function(a,b){var c,d=[],e=function(a,b){b=m.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=m.ajaxSettings&&m.ajaxSettings.traditional),m.isArray(a)||a.jquery&&!m.isPlainObject(a))m.each(a,function(){e(this.name,this.value)});else for(c in a)Vb(c,a[c],b,e);return d.join("&").replace(Qb,"+")},m.fn.extend({serialize:function(){return m.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=m.prop(this,"elements");return a?m.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!m(this).is(":disabled")&&Ub.test(this.nodeName)&&!Tb.test(a)&&(this.checked||!W.test(a))}).map(function(a,b){var c=m(this).val();return null==c?null:m.isArray(c)?m.map(c,function(a){return{name:b.name,value:a.replace(Sb,"\r\n")}}):{name:b.name,value:c.replace(Sb,"\r\n")}}).get()}}),m.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&Zb()||$b()}:Zb;var Wb=0,Xb={},Yb=m.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Xb)Xb[a](void 0,!0)}),k.cors=!!Yb&&"withCredentials"in Yb,Yb=k.ajax=!!Yb,Yb&&m.ajaxTransport(function(a){if(!a.crossDomain||k.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Wb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+"");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Xb[g],b=void 0,f.onreadystatechange=m.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,"string"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=""}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Xb[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function Zb(){try{return new a.XMLHttpRequest}catch(b){}}function $b(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}m.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return m.globalEval(a),a}}}),m.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),m.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=y.head||m("head")[0]||y.documentElement;return{send:function(d,e){b=y.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var _b=[],ac=/(=)\?(?=&|$)|\?\?/;m.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=_b.pop()||m.expando+"_"+vb++;return this[a]=!0,a}}),m.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(ac.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&ac.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=m.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(ac,"$1"+e):b.jsonp!==!1&&(b.url+=(wb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||m.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,_b.push(e)),g&&m.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),m.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||y;var d=u.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=m.buildFragment([a],b,e),e&&e.length&&m(e).remove(),m.merge([],d.childNodes))};var bc=m.fn.load;m.fn.load=function(a,b,c){if("string"!=typeof a&&bc)return bc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=m.trim(a.slice(h,a.length)),a=a.slice(0,h)),m.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(f="POST"),g.length>0&&m.ajax({url:a,type:f,dataType:"html",data:b}).done(function(a){e=arguments,g.html(d?m("<div>").append(m.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},m.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){m.fn[b]=function(a){return this.on(b,a)}}),m.expr.filters.animated=function(a){return m.grep(m.timers,function(b){return a===b.elem}).length};var cc=a.document.documentElement;function dc(a){return m.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}m.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=m.css(a,"position"),l=m(a),n={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=m.css(a,"top"),i=m.css(a,"left"),j=("absolute"===k||"fixed"===k)&&m.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),m.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(n.top=b.top-h.top+g),null!=b.left&&(n.left=b.left-h.left+e),"using"in b?b.using.call(a,n):l.css(n)}},m.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){m.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,m.contains(b,e)?(typeof e.getBoundingClientRect!==K&&(d=e.getBoundingClientRect()),c=dc(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===m.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),m.nodeName(a[0],"html")||(c=a.offset()),c.top+=m.css(a[0],"borderTopWidth",!0),c.left+=m.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-m.css(d,"marginTop",!0),left:b.left-c.left-m.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||cc;while(a&&!m.nodeName(a,"html")&&"static"===m.css(a,"position"))a=a.offsetParent;return a||cc})}}),m.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);m.fn[a]=function(d){return V(this,function(a,d,e){var f=dc(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?m(f).scrollLeft():e,c?e:m(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),m.each(["top","left"],function(a,b){m.cssHooks[b]=La(k.pixelPosition,function(a,c){return c?(c=Ja(a,b),Ha.test(c)?m(a).position()[b]+"px":c):void 0})}),m.each({Height:"height",Width:"width"},function(a,b){m.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){m.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return V(this,function(b,c,d){var e;return m.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?m.css(b,c,g):m.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),m.fn.size=function(){return this.length},m.fn.andSelf=m.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return m});var ec=a.jQuery,fc=a.$;return m.noConflict=function(b){return a.$===m&&(a.$=fc),b&&a.jQuery===m&&(a.jQuery=ec),m},typeof b===K&&(a.jQuery=a.$=m),m});


if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery"); +function (a) { "use strict"; var b = a.fn.jquery.split(" ")[0].split("."); if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher") }(jQuery), +function (a) { "use strict"; function b() { var a = document.createElement("bootstrap"), b = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" }; for (var c in b) if (void 0 !== a.style[c]) return { end: b[c] }; return !1 } a.fn.emulateTransitionEnd = function (b) { var c = !1, d = this; a(this).one("bsTransitionEnd", function () { c = !0 }); var e = function () { c || a(d).trigger(a.support.transition.end) }; return setTimeout(e, b), this }, a(function () { a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = { bindType: a.support.transition.end, delegateType: a.support.transition.end, handle: function (b) { return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0 } }) }) }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var c = a(this), e = c.data("bs.alert"); e || c.data("bs.alert", e = new d(this)), "string" == typeof b && e[b].call(c) }) } var c = '[data-dismiss="alert"]', d = function (b) { a(b).on("click", c, this.close) }; d.VERSION = "3.3.5", d.TRANSITION_DURATION = 150, d.prototype.close = function (b) { function c() { g.detach().trigger("closed.bs.alert").remove() } var e = a(this), f = e.attr("data-target"); f || (f = e.attr("href"), f = f && f.replace(/.*(?=#[^\s]*$)/, "")); var g = a(f); b && b.preventDefault(), g.length || (g = e.closest(".alert")), g.trigger(b = a.Event("close.bs.alert")), b.isDefaultPrevented() || (g.removeClass("in"), a.support.transition && g.hasClass("fade") ? g.one("bsTransitionEnd", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c()) }; var e = a.fn.alert; a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function () { return a.fn.alert = e, this }, a(document).on("click.bs.alert.data-api", c, d.prototype.close) }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.button"), f = "object" == typeof b && b; e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b) }) } var c = function (b, d) { this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1 }; c.VERSION = "3.3.5", c.DEFAULTS = { loadingText: "loading..." }, c.prototype.setState = function (b) { var c = "disabled", d = this.$element, e = d.is("input") ? "val" : "html", f = d.data(); b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function () { d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c)) }, this), 0) }, c.prototype.toggle = function () { var a = !0, b = this.$element.closest('[data-toggle="buttons"]'); if (b.length) { var c = this.$element.find("input"); "radio" == c.prop("type") ? (c.prop("checked") && (a = !1), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = !1), this.$element.toggleClass("active")), c.prop("checked", this.$element.hasClass("active")), a && c.trigger("change") } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active") }; var d = a.fn.button; a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function () { return a.fn.button = d, this }, a(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (c) { var d = a(c.target); d.hasClass("btn") || (d = d.closest(".btn")), b.call(d, "toggle"), a(c.target).is('input[type="radio"]') || a(c.target).is('input[type="checkbox"]') || c.preventDefault() }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (b) { a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type)) }) }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.carousel"), f = a.extend({}, c.DEFAULTS, d.data(), "object" == typeof b && b), g = "string" == typeof b ? b : f.slide; e || d.data("bs.carousel", e = new c(this, f)), "number" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle() }) } var c = function (b, c) { this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"), this.options = c, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", a.proxy(this.pause, this)).on("mouseleave.bs.carousel", a.proxy(this.cycle, this)) }; c.VERSION = "3.3.5", c.TRANSITION_DURATION = 600, c.DEFAULTS = { interval: 5e3, pause: "hover", wrap: !0, keyboard: !0 }, c.prototype.keydown = function (a) { if (!/input|textarea/i.test(a.target.tagName)) { switch (a.which) { case 37: this.prev(); break; case 39: this.next(); break; default: return }a.preventDefault() } }, c.prototype.cycle = function (b) { return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), this }, c.prototype.getItemIndex = function (a) { return this.$items = a.parent().children(".item"), this.$items.index(a || this.$active) }, c.prototype.getItemForDirection = function (a, b) { var c = this.getItemIndex(b), d = "prev" == a && 0 === c || "next" == a && c == this.$items.length - 1; if (d && !this.options.wrap) return b; var e = "prev" == a ? -1 : 1, f = (c + e) % this.$items.length; return this.$items.eq(f) }, c.prototype.to = function (a) { var b = this, c = this.getItemIndex(this.$active = this.$element.find(".item.active")); return a > this.$items.length - 1 || 0 > a ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function () { b.to(a) }) : c == a ? this.pause().cycle() : this.slide(a > c ? "next" : "prev", this.$items.eq(a)) }, c.prototype.pause = function (b) { return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this }, c.prototype.next = function () { return this.sliding ? void 0 : this.slide("next") }, c.prototype.prev = function () { return this.sliding ? void 0 : this.slide("prev") }, c.prototype.slide = function (b, d) { var e = this.$element.find(".item.active"), f = d || this.getItemForDirection(b, e), g = this.interval, h = "next" == b ? "left" : "right", i = this; if (f.hasClass("active")) return this.sliding = !1; var j = f[0], k = a.Event("slide.bs.carousel", { relatedTarget: j, direction: h }); if (this.$element.trigger(k), !k.isDefaultPrevented()) { if (this.sliding = !0, g && this.pause(), this.$indicators.length) { this.$indicators.find(".active").removeClass("active"); var l = a(this.$indicators.children()[this.getItemIndex(f)]); l && l.addClass("active") } var m = a.Event("slid.bs.carousel", { relatedTarget: j, direction: h }); return a.support.transition && this.$element.hasClass("slide") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one("bsTransitionEnd", function () { f.removeClass([b, h].join(" ")).addClass("active"), e.removeClass(["active", h].join(" ")), i.sliding = !1, setTimeout(function () { i.$element.trigger(m) }, 0) }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass("active"), f.addClass("active"), this.sliding = !1, this.$element.trigger(m)), g && this.cycle(), this } }; var d = a.fn.carousel; a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel.noConflict = function () { return a.fn.carousel = d, this }; var e = function (c) { var d, e = a(this), f = a(e.attr("data-target") || (d = e.attr("href")) && d.replace(/.*(?=#[^\s]+$)/, "")); if (f.hasClass("carousel")) { var g = a.extend({}, f.data(), e.data()), h = e.attr("data-slide-to"); h && (g.interval = !1), b.call(f, g), h && f.data("bs.carousel").to(h), c.preventDefault() } }; a(document).on("click.bs.carousel.data-api", "[data-slide]", e).on("click.bs.carousel.data-api", "[data-slide-to]", e), a(window).on("load", function () { a('[data-ride="carousel"]').each(function () { var c = a(this); b.call(c, c.data()) }) }) }(jQuery), +function (a) { "use strict"; function b(b) { var c, d = b.attr("data-target") || (c = b.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, ""); return a(d) } function c(b) { return this.each(function () { var c = a(this), e = c.data("bs.collapse"), f = a.extend({}, d.DEFAULTS, c.data(), "object" == typeof b && b); !e && f.toggle && /show|hide/.test(b) && (f.toggle = !1), e || c.data("bs.collapse", e = new d(this, f)), "string" == typeof b && e[b]() }) } var d = function (b, c) { this.$element = a(b), this.options = a.extend({}, d.DEFAULTS, c), this.$trigger = a('[data-toggle="collapse"][href="#' + b.id + '"],[data-toggle="collapse"][data-target="#' + b.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle() }; d.VERSION = "3.3.5", d.TRANSITION_DURATION = 350, d.DEFAULTS = { toggle: !0 }, d.prototype.dimension = function () { var a = this.$element.hasClass("width"); return a ? "width" : "height" }, d.prototype.show = function () { if (!this.transitioning && !this.$element.hasClass("in")) { var b, e = this.$parent && this.$parent.children(".panel").children(".in, .collapsing"); if (!(e && e.length && (b = e.data("bs.collapse"), b && b.transitioning))) { var f = a.Event("show.bs.collapse"); if (this.$element.trigger(f), !f.isDefaultPrevented()) { e && e.length && (c.call(e, "hide"), b || e.data("bs.collapse", null)); var g = this.dimension(); this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1; var h = function () { this.$element.removeClass("collapsing").addClass("collapse in")[g](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse") }; if (!a.support.transition) return h.call(this); var i = a.camelCase(["scroll", g].join("-")); this.$element.one("bsTransitionEnd", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i]) } } } }, d.prototype.hide = function () { if (!this.transitioning && this.$element.hasClass("in")) { var b = a.Event("hide.bs.collapse"); if (this.$element.trigger(b), !b.isDefaultPrevented()) { var c = this.dimension(); this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1; var e = function () { this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse") }; return a.support.transition ? void this.$element[c](0).one("bsTransitionEnd", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this) } } }, d.prototype.toggle = function () { this[this.$element.hasClass("in") ? "hide" : "show"]() }, d.prototype.getParent = function () { return a(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(a.proxy(function (c, d) { var e = a(d); this.addAriaAndCollapsedClass(b(e), e) }, this)).end() }, d.prototype.addAriaAndCollapsedClass = function (a, b) { var c = a.hasClass("in"); a.attr("aria-expanded", c), b.toggleClass("collapsed", !c).attr("aria-expanded", c) }; var e = a.fn.collapse; a.fn.collapse = c, a.fn.collapse.Constructor = d, a.fn.collapse.noConflict = function () { return a.fn.collapse = e, this }, a(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (d) { var e = a(this); e.attr("data-target") || d.preventDefault(); var f = b(e), g = f.data("bs.collapse"), h = g ? "toggle" : e.data(); c.call(f, h) }) }(jQuery), +function (a) { "use strict"; function b(b) { var c = b.attr("data-target"); c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, "")); var d = c && a(c); return d && d.length ? d : b.parent() } function c(c) { c && 3 === c.which || (a(e).remove(), a(f).each(function () { var d = a(this), e = b(d), f = { relatedTarget: this }; e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger("hidden.bs.dropdown", f)))) })) } function d(b) { return this.each(function () { var c = a(this), d = c.data("bs.dropdown"); d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c) }) } var e = ".dropdown-backdrop", f = '[data-toggle="dropdown"]', g = function (b) { a(b).on("click.bs.dropdown", this.toggle) }; g.VERSION = "3.3.5", g.prototype.toggle = function (d) { var e = a(this); if (!e.is(".disabled, :disabled")) { var f = b(e), g = f.hasClass("open"); if (c(), !g) { "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c); var h = { relatedTarget: this }; if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return; e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger("shown.bs.dropdown", h) } return !1 } }, g.prototype.keydown = function (c) { if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) { var d = a(this); if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) { var e = b(d), g = e.hasClass("open"); if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"), d.trigger("click"); var h = " li:not(.disabled):visible a", i = e.find(".dropdown-menu" + h); if (i.length) { var j = i.index(c.target); 38 == c.which && j > 0 && j-- , 40 == c.which && j < i.length - 1 && j++ , ~j || (j = 0), i.eq(j).trigger("focus") } } } }; var h = a.fn.dropdown; a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function () { return a.fn.dropdown = h, this }, a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form", function (a) { a.stopPropagation() }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown) }(jQuery), +function (a) { "use strict"; function b(b, d) { return this.each(function () { var e = a(this), f = e.data("bs.modal"), g = a.extend({}, c.DEFAULTS, e.data(), "object" == typeof b && b); f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d) }) } var c = function (b, c) { this.options = c, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function () { this.$element.trigger("loaded.bs.modal") }, this)) }; c.VERSION = "3.3.5", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = { backdrop: !0, keyboard: !0, show: !0 }, c.prototype.toggle = function (a) { return this.isShown ? this.hide() : this.show(a) }, c.prototype.show = function (b) { var d = this, e = a.Event("show.bs.modal", { relatedTarget: b }); this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function () { d.$element.one("mouseup.dismiss.bs.modal", function (b) { a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0) }) }), this.backdrop(function () { var e = a.support.transition && d.$element.hasClass("fade"); d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in"), d.enforceFocus(); var f = a.Event("shown.bs.modal", { relatedTarget: b }); e ? d.$dialog.one("bsTransitionEnd", function () { d.$element.trigger("focus").trigger(f) }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f) })) }, c.prototype.hide = function (b) { b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal()) }, c.prototype.enforceFocus = function () { a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function (a) { this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus") }, this)) }, c.prototype.escape = function () { this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function (a) { 27 == a.which && this.hide() }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal") }, c.prototype.resize = function () { this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal") }, c.prototype.hideModal = function () { var a = this; this.$element.hide(), this.backdrop(function () { a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal") }) }, c.prototype.removeBackdrop = function () { this.$backdrop && this.$backdrop.remove(), this.$backdrop = null }, c.prototype.backdrop = function (b) { var d = this, e = this.$element.hasClass("fade") ? "fade" : ""; if (this.isShown && this.options.backdrop) { var f = a.support.transition && e; if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function (a) { return this.ignoreBackdropClick ? void (this.ignoreBackdropClick = !1) : void (a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide())) }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return; f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b() } else if (!this.isShown && this.$backdrop) { this.$backdrop.removeClass("in"); var g = function () { d.removeBackdrop(), b && b() }; a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g() } else b && b() }, c.prototype.handleUpdate = function () { this.adjustDialog() }, c.prototype.adjustDialog = function () { var a = this.$element[0].scrollHeight > document.documentElement.clientHeight; this.$element.css({ paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "", paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : "" }) }, c.prototype.resetAdjustments = function () { this.$element.css({ paddingLeft: "", paddingRight: "" }) }, c.prototype.checkScrollbar = function () { var a = window.innerWidth; if (!a) { var b = document.documentElement.getBoundingClientRect(); a = b.right - Math.abs(b.left) } this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar() }, c.prototype.setScrollbar = function () { var a = parseInt(this.$body.css("padding-right") || 0, 10); this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth) }, c.prototype.resetScrollbar = function () { this.$body.css("padding-right", this.originalBodyPad) }, c.prototype.measureScrollbar = function () { var a = document.createElement("div"); a.className = "modal-scrollbar-measure", this.$body.append(a); var b = a.offsetWidth - a.clientWidth; return this.$body[0].removeChild(a), b }; var d = a.fn.modal; a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function () { return a.fn.modal = d, this }, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (c) { var d = a(this), e = d.attr("href"), f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\s]+$)/, "")), g = f.data("bs.modal") ? "toggle" : a.extend({ remote: !/#/.test(e) && e }, f.data(), d.data()); d.is("a") && c.preventDefault(), f.one("show.bs.modal", function (a) { a.isDefaultPrevented() || f.one("hidden.bs.modal", function () { d.is(":visible") && d.trigger("focus") }) }), b.call(f, g, this) }) }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.tooltip"), f = "object" == typeof b && b; (e || !/destroy|hide/.test(b)) && (e || d.data("bs.tooltip", e = new c(this, f)), "string" == typeof b && e[b]()) }) } var c = function (a, b) { this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", a, b) }; c.VERSION = "3.3.5", c.TRANSITION_DURATION = 150, c.DEFAULTS = { animation: !0, placement: "top", selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: !1, container: !1, viewport: { selector: "body", padding: 0 } }, c.prototype.init = function (b, c, d) { if (this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(a.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = { click: !1, hover: !1, focus: !1 }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!"); for (var e = this.options.trigger.split(" "), f = e.length; f--;) { var g = e[f]; if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this)); else if ("manual" != g) { var h = "hover" == g ? "mouseenter" : "focusin", i = "hover" == g ? "mouseleave" : "focusout"; this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)), this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this)) } } this.options.selector ? this._options = a.extend({}, this.options, { trigger: "manual", selector: "" }) : this.fixTitle() }, c.prototype.getDefaults = function () { return c.DEFAULTS }, c.prototype.getOptions = function (b) { return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && "number" == typeof b.delay && (b.delay = { show: b.delay, hide: b.delay }), b }, c.prototype.getDelegateOptions = function () { var b = {}, c = this.getDefaults(); return this._options && a.each(this._options, function (a, d) { c[a] != d && (b[a] = d) }), b }, c.prototype.enter = function (b) { var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type); return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusin" == b.type ? "focus" : "hover"] = !0), c.tip().hasClass("in") || "in" == c.hoverState ? void (c.hoverState = "in") : (clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void (c.timeout = setTimeout(function () { "in" == c.hoverState && c.show() }, c.options.delay.show)) : c.show()) }, c.prototype.isInStateTrue = function () { for (var a in this.inState) if (this.inState[a]) return !0; return !1 }, c.prototype.leave = function (b) { var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type); return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusout" == b.type ? "focus" : "hover"] = !1), c.isInStateTrue() ? void 0 : (clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void (c.timeout = setTimeout(function () { "out" == c.hoverState && c.hide() }, c.options.delay.hide)) : c.hide()) }, c.prototype.show = function () { var b = a.Event("show.bs." + this.type); if (this.hasContent() && this.enabled) { this.$element.trigger(b); var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]); if (b.isDefaultPrevented() || !d) return; var e = this, f = this.tip(), g = this.getUID(this.type); this.setContent(), f.attr("id", g), this.$element.attr("aria-describedby", g), this.options.animation && f.addClass("fade"); var h = "function" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement, i = /\s?auto?\s?/i, j = i.test(h); j && (h = h.replace(i, "") || "top"), f.detach().css({ top: 0, left: 0, display: "block" }).addClass(h).data("bs." + this.type, this), this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type); var k = this.getPosition(), l = f[0].offsetWidth, m = f[0].offsetHeight; if (j) { var n = h, o = this.getPosition(this.$viewport); h = "bottom" == h && k.bottom + m > o.bottom ? "top" : "top" == h && k.top - m < o.top ? "bottom" : "right" == h && k.right + l > o.width ? "left" : "left" == h && k.left - l < o.left ? "right" : h, f.removeClass(n).addClass(h) } var p = this.getCalculatedOffset(h, k, l, m); this.applyPlacement(p, h); var q = function () { var a = e.hoverState; e.$element.trigger("shown.bs." + e.type), e.hoverState = null, "out" == a && e.leave(e) }; a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", q).emulateTransitionEnd(c.TRANSITION_DURATION) : q() } }, c.prototype.applyPlacement = function (b, c) { var d = this.tip(), e = d[0].offsetWidth, f = d[0].offsetHeight, g = parseInt(d.css("margin-top"), 10), h = parseInt(d.css("margin-left"), 10); isNaN(g) && (g = 0), isNaN(h) && (h = 0), b.top += g, b.left += h, a.offset.setOffset(d[0], a.extend({ using: function (a) { d.css({ top: Math.round(a.top), left: Math.round(a.left) }) } }, b), 0), d.addClass("in"); var i = d[0].offsetWidth, j = d[0].offsetHeight; "top" == c && j != f && (b.top = b.top + f - j); var k = this.getViewportAdjustedDelta(c, b, i, j); k.left ? b.left += k.left : b.top += k.top; var l = /top|bottom/.test(c), m = l ? 2 * k.left - e + i : 2 * k.top - f + j, n = l ? "offsetWidth" : "offsetHeight"; d.offset(b), this.replaceArrow(m, d[0][n], l) }, c.prototype.replaceArrow = function (a, b, c) { this.arrow().css(c ? "left" : "top", 50 * (1 - a / b) + "%").css(c ? "top" : "left", "") }, c.prototype.setContent = function () { var a = this.tip(), b = this.getTitle(); a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right") }, c.prototype.hide = function (b) { function d() { "in" != e.hoverState && f.detach(), e.$element.removeAttr("aria-describedby").trigger("hidden.bs." + e.type), b && b() } var e = this, f = a(this.$tip), g = a.Event("hide.bs." + this.type); return this.$element.trigger(g), g.isDefaultPrevented() ? void 0 : (f.removeClass("in"), a.support.transition && f.hasClass("fade") ? f.one("bsTransitionEnd", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this) }, c.prototype.fixTitle = function () { var a = this.$element; (a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "") }, c.prototype.hasContent = function () { return this.getTitle() }, c.prototype.getPosition = function (b) { b = b || this.$element; var c = b[0], d = "BODY" == c.tagName, e = c.getBoundingClientRect(); null == e.width && (e = a.extend({}, e, { width: e.right - e.left, height: e.bottom - e.top })); var f = d ? { top: 0, left: 0 } : b.offset(), g = { scroll: d ? document.documentElement.scrollTop || document.body.scrollTop : b.scrollTop() }, h = d ? { width: a(window).width(), height: a(window).height() } : null; return a.extend({}, e, g, h, f) }, c.prototype.getCalculatedOffset = function (a, b, c, d) { return "bottom" == a ? { top: b.top + b.height, left: b.left + b.width / 2 - c / 2 } : "top" == a ? { top: b.top - d, left: b.left + b.width / 2 - c / 2 } : "left" == a ? { top: b.top + b.height / 2 - d / 2, left: b.left - c } : { top: b.top + b.height / 2 - d / 2, left: b.left + b.width } }, c.prototype.getViewportAdjustedDelta = function (a, b, c, d) { var e = { top: 0, left: 0 }; if (!this.$viewport) return e; var f = this.options.viewport && this.options.viewport.padding || 0, g = this.getPosition(this.$viewport); if (/right|left/.test(a)) { var h = b.top - f - g.scroll, i = b.top + f - g.scroll + d; h < g.top ? e.top = g.top - h : i > g.top + g.height && (e.top = g.top + g.height - i) } else { var j = b.left - f, k = b.left + f + c; j < g.left ? e.left = g.left - j : k > g.right && (e.left = g.left + g.width - k) } return e }, c.prototype.getTitle = function () { var a, b = this.$element, c = this.options; return a = b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title) }, c.prototype.getUID = function (a) { do a += ~~(1e6 * Math.random()); while (document.getElementById(a)); return a }, c.prototype.tip = function () { if (!this.$tip && (this.$tip = a(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!"); return this.$tip }, c.prototype.arrow = function () { return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow") }, c.prototype.enable = function () { this.enabled = !0 }, c.prototype.disable = function () { this.enabled = !1 }, c.prototype.toggleEnabled = function () { this.enabled = !this.enabled }, c.prototype.toggle = function (b) { var c = this; b && (c = a(b.currentTarget).data("bs." + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c))), b ? (c.inState.click = !c.inState.click, c.isInStateTrue() ? c.enter(c) : c.leave(c)) : c.tip().hasClass("in") ? c.leave(c) : c.enter(c) }, c.prototype.destroy = function () { var a = this; clearTimeout(this.timeout), this.hide(function () { a.$element.off("." + a.type).removeData("bs." + a.type), a.$tip && a.$tip.detach(), a.$tip = null, a.$arrow = null, a.$viewport = null }) }; var d = a.fn.tooltip; a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function () { return a.fn.tooltip = d, this } }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.popover"), f = "object" == typeof b && b; (e || !/destroy|hide/.test(b)) && (e || d.data("bs.popover", e = new c(this, f)), "string" == typeof b && e[b]()) }) } var c = function (a, b) { this.init("popover", a, b) }; if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js"); c.VERSION = "3.3.5", c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, { placement: "right", trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>' }), c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), c.prototype.constructor = c, c.prototype.getDefaults = function () { return c.DEFAULTS }, c.prototype.setContent = function () { var a = this.tip(), b = this.getTitle(), c = this.getContent(); a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c), a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide() }, c.prototype.hasContent = function () { return this.getTitle() || this.getContent() }, c.prototype.getContent = function () { var a = this.$element, b = this.options; return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content) }, c.prototype.arrow = function () { return this.$arrow = this.$arrow || this.tip().find(".arrow") }; var d = a.fn.popover; a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function () { return a.fn.popover = d, this } }(jQuery), +function (a) {
    "use strict"; function b(c, d) { this.$body = a(document.body), this.$scrollElement = a(a(c).is(document.body) ? window : c), this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", a.proxy(this.process, this)), this.refresh(), this.process() } function c(c) { return this.each(function () { var d = a(this), e = d.data("bs.scrollspy"), f = "object" == typeof c && c; e || d.data("bs.scrollspy", e = new b(this, f)), "string" == typeof c && e[c]() }) } b.VERSION = "3.3.5", b.DEFAULTS = { offset: 10 }, b.prototype.getScrollHeight = function () { return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight) }, b.prototype.refresh = function () { var b = this, c = "offset", d = 0; this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), a.isWindow(this.$scrollElement[0]) || (c = "position", d = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () { var b = a(this), e = b.data("target") || b.attr("href"), f = /^#./.test(e) && a(e); return f && f.length && f.is(":visible") && [[f[c]().top + d, e]] || null }).sort(function (a, b) { return a[0] - b[0] }).each(function () { b.offsets.push(this[0]), b.targets.push(this[1]) }) }, b.prototype.process = function () { var a, b = this.$scrollElement.scrollTop() + this.options.offset, c = this.getScrollHeight(), d = this.options.offset + c - this.$scrollElement.height(), e = this.offsets, f = this.targets, g = this.activeTarget; if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a); if (g && b < e[0]) return this.activeTarget = null, this.clear(); for (a = e.length; a--;)g != f[a] && b >= e[a] && (void 0 === e[a + 1] || b < e[a + 1]) && this.activate(f[a]) }, b.prototype.activate = function (b) {
    this.activeTarget = b, this.clear(); var c = this.selector + '[data-target="' + b + '"],' + this.selector + '[href="' + b + '"]', d = a(c).parents("li").addClass("active"); d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")),
        d.trigger("activate.bs.scrollspy")
    }, b.prototype.clear = function () { a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active") }; var d = a.fn.scrollspy; a.fn.scrollspy = c, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function () { return a.fn.scrollspy = d, this }, a(window).on("load.bs.scrollspy.data-api", function () { a('[data-spy="scroll"]').each(function () { var b = a(this); c.call(b, b.data()) }) })
}(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.tab"); e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]() }) } var c = function (b) { this.element = a(b) }; c.VERSION = "3.3.5", c.TRANSITION_DURATION = 150, c.prototype.show = function () { var b = this.element, c = b.closest("ul:not(.dropdown-menu)"), d = b.data("target"); if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) { var e = c.find(".active:last a"), f = a.Event("hide.bs.tab", { relatedTarget: b[0] }), g = a.Event("show.bs.tab", { relatedTarget: e[0] }); if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) { var h = a(d); this.activate(b.closest("li"), c), this.activate(h, h.parent(), function () { e.trigger({ type: "hidden.bs.tab", relatedTarget: b[0] }), b.trigger({ type: "shown.bs.tab", relatedTarget: e[0] }) }) } } }, c.prototype.activate = function (b, d, e) { function f() { g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), e && e() } var g = d.find("> .active"), h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length); g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in") }; var d = a.fn.tab; a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function () { return a.fn.tab = d, this }; var e = function (c) { c.preventDefault(), b.call(a(this), "show") }; a(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', e).on("click.bs.tab.data-api", '[data-toggle="pill"]', e) }(jQuery), +function (a) { "use strict"; function b(b) { return this.each(function () { var d = a(this), e = d.data("bs.affix"), f = "object" == typeof b && b; e || d.data("bs.affix", e = new c(this, f)), "string" == typeof b && e[b]() }) } var c = function (b, d) { this.options = a.extend({}, c.DEFAULTS, d), this.$target = a(this.options.target).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)), this.$element = a(b), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition() }; c.VERSION = "3.3.5", c.RESET = "affix affix-top affix-bottom", c.DEFAULTS = { offset: 0, target: window }, c.prototype.getState = function (a, b, c, d) { var e = this.$target.scrollTop(), f = this.$element.offset(), g = this.$target.height(); if (null != c && "top" == this.affixed) return c > e ? "top" : !1; if ("bottom" == this.affixed) return null != c ? e + this.unpin <= f.top ? !1 : "bottom" : a - d >= e + g ? !1 : "bottom"; var h = null == this.affixed, i = h ? e : f.top, j = h ? g : b; return null != c && c >= e ? "top" : null != d && i + j >= a - d ? "bottom" : !1 }, c.prototype.getPinnedOffset = function () { if (this.pinnedOffset) return this.pinnedOffset; this.$element.removeClass(c.RESET).addClass("affix"); var a = this.$target.scrollTop(), b = this.$element.offset(); return this.pinnedOffset = b.top - a }, c.prototype.checkPositionWithEventLoop = function () { setTimeout(a.proxy(this.checkPosition, this), 1) }, c.prototype.checkPosition = function () { if (this.$element.is(":visible")) { var b = this.$element.height(), d = this.options.offset, e = d.top, f = d.bottom, g = Math.max(a(document).height(), a(document.body).height()); "object" != typeof d && (f = e = d), "function" == typeof e && (e = d.top(this.$element)), "function" == typeof f && (f = d.bottom(this.$element)); var h = this.getState(g, b, e, f); if (this.affixed != h) { null != this.unpin && this.$element.css("top", ""); var i = "affix" + (h ? "-" + h : ""), j = a.Event(i + ".bs.affix"); if (this.$element.trigger(j), j.isDefaultPrevented()) return; this.affixed = h, this.unpin = "bottom" == h ? this.getPinnedOffset() : null, this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix", "affixed") + ".bs.affix") } "bottom" == h && this.$element.offset({ top: g - b - f }) } }; var d = a.fn.affix; a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function () { return a.fn.affix = d, this }, a(window).on("load", function () { a('[data-spy="affix"]').each(function () { var c = a(this), d = c.data(); d.offset = d.offset || {}, null != d.offsetBottom && (d.offset.bottom = d.offsetBottom), null != d.offsetTop && (d.offset.top = d.offsetTop), b.call(c, d) }) }) }(jQuery);


/*====================================================
	1. fitVids
  2. highlight js
  3. GhostHunter
====================================================*/
/*====================================================
	1. fitVids
====================================================*/
/*jshint browser:true */
/*!
* FitVids 1.1
*
* Copyright 2013, Chris Coyier - http://css-tricks.com + Dave Rupert - http://daverupert.com
* Credit to Thierry Koblentz - http://www.alistapart.com/articles/creating-intrinsic-ratios-for-video/
* Released under the WTFPL license - http://sam.zoy.org/wtfpl/
*
*/

; (function ($) {

    'use strict';

    $.fn.fitVids = function (options) {
        var settings = {
            customSelector: null,
            ignore: null
        };

        if (!document.getElementById('fit-vids-style')) {
            // appendStyles: https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.js
            var head = document.head || document.getElementsByTagName('head')[0];
            var css = '.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}';
            var div = document.createElement("div");
            div.innerHTML = '<p>x</p><style id="fit-vids-style">' + css + '</style>';
            head.appendChild(div.childNodes[1]);
        }

        if (options) {
            $.extend(settings, options);
        }

        return this.each(function () {
            var selectors = [
                'iframe[src*="player.vimeo.com"]',
                'iframe[src*="youtube.com"]',
                'iframe[src*="youtube-nocookie.com"]',
                'iframe[src*="kickstarter.com"][src*="video.html"]',
                'object',
                'embed'
            ];

            if (settings.customSelector) {
                selectors.push(settings.customSelector);
            }

            var ignoreList = '.fitvidsignore';

            if (settings.ignore) {
                ignoreList = ignoreList + ', ' + settings.ignore;
            }

            var $allVideos = $(this).find(selectors.join(','));
            $allVideos = $allVideos.not('object object'); // SwfObj conflict patch
            $allVideos = $allVideos.not(ignoreList); // Disable FitVids on this video.

            $allVideos.each(function (count) {
                var $this = $(this);
                if ($this.parents(ignoreList).length > 0) {
                    return; // Disable FitVids on this video.
                }
                if (this.tagName.toLowerCase() === 'embed' && $this.parent('object').length || $this.parent('.fluid-width-video-wrapper').length) { return; }
                if ((!$this.css('height') && !$this.css('width')) && (isNaN($this.attr('height')) || isNaN($this.attr('width')))) {
                    $this.attr('height', 9);
                    $this.attr('width', 16);
                }
                var height = (this.tagName.toLowerCase() === 'object' || ($this.attr('height') && !isNaN(parseInt($this.attr('height'), 10)))) ? parseInt($this.attr('height'), 10) : $this.height(),
                    width = !isNaN(parseInt($this.attr('width'), 10)) ? parseInt($this.attr('width'), 10) : $this.width(),
                    aspectRatio = height / width;
                if (!$this.attr('id')) {
                    var videoID = 'fitvid' + count;
                    $this.attr('id', videoID);
                }
                $this.wrap('<div class="fluid-width-video-wrapper"></div>').parent('.fluid-width-video-wrapper').css('padding-top', (aspectRatio * 100) + '%');
                $this.removeAttr('height').removeAttr('width');
            });
        });
    };
    // Works with either jQuery or Zepto
})(window.jQuery || window.Zepto);

/*====================================================
  2. highlight js
====================================================*/
!function (e) { "undefined" != typeof exports ? e(exports) : (window.hljs = e({}), "function" == typeof define && define.amd && define([], function () { return window.hljs })) }(function (e) { function n(e) { return e.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;") } function t(e) { return e.nodeName.toLowerCase() } function r(e, n) { var t = e && e.exec(n); return t && 0 == t.index } function a(e) { var n = (e.className + " " + (e.parentNode ? e.parentNode.className : "")).split(/\s+/); return n = n.map(function (e) { return e.replace(/^lang(uage)?-/, "") }), n.filter(function (e) { return N(e) || /no(-?)highlight|plain|text/.test(e) })[0] } function i(e, n) { var t, r = {}; for (t in e) r[t] = e[t]; if (n) for (t in n) r[t] = n[t]; return r } function o(e) { var n = []; return function r(e, a) { for (var i = e.firstChild; i; i = i.nextSibling)3 == i.nodeType ? a += i.nodeValue.length : 1 == i.nodeType && (n.push({ event: "start", offset: a, node: i }), a = r(i, a), t(i).match(/br|hr|img|input/) || n.push({ event: "stop", offset: a, node: i })); return a }(e, 0), n } function u(e, r, a) { function i() { return e.length && r.length ? e[0].offset != r[0].offset ? e[0].offset < r[0].offset ? e : r : "start" == r[0].event ? e : r : e.length ? e : r } function o(e) { function r(e) { return " " + e.nodeName + '="' + n(e.value) + '"' } l += "<" + t(e) + Array.prototype.map.call(e.attributes, r).join("") + ">" } function u(e) { l += "</" + t(e) + ">" } function c(e) { ("start" == e.event ? o : u)(e.node) } for (var s = 0, l = "", f = []; e.length || r.length;) { var g = i(); if (l += n(a.substr(s, g[0].offset - s)), s = g[0].offset, g == e) { f.reverse().forEach(u); do c(g.splice(0, 1)[0]), g = i(); while (g == e && g.length && g[0].offset == s); f.reverse().forEach(o) } else "start" == g[0].event ? f.push(g[0].node) : f.pop(), c(g.splice(0, 1)[0]) } return l + n(a.substr(s)) } function c(e) { function n(e) { return e && e.source || e } function t(t, r) { return new RegExp(n(t), "m" + (e.cI ? "i" : "") + (r ? "g" : "")) } function r(a, o) { if (!a.compiled) { if (a.compiled = !0, a.k = a.k || a.bK, a.k) { var u = {}, c = function (n, t) { e.cI && (t = t.toLowerCase()), t.split(" ").forEach(function (e) { var t = e.split("|"); u[t[0]] = [n, t[1] ? Number(t[1]) : 1] }) }; "string" == typeof a.k ? c("keyword", a.k) : Object.keys(a.k).forEach(function (e) { c(e, a.k[e]) }), a.k = u } a.lR = t(a.l || /\b\w+\b/, !0), o && (a.bK && (a.b = "\\b(" + a.bK.split(" ").join("|") + ")\\b"), a.b || (a.b = /\B|\b/), a.bR = t(a.b), a.e || a.eW || (a.e = /\B|\b/), a.e && (a.eR = t(a.e)), a.tE = n(a.e) || "", a.eW && o.tE && (a.tE += (a.e ? "|" : "") + o.tE)), a.i && (a.iR = t(a.i)), void 0 === a.r && (a.r = 1), a.c || (a.c = []); var s = []; a.c.forEach(function (e) { e.v ? e.v.forEach(function (n) { s.push(i(e, n)) }) : s.push("self" == e ? a : e) }), a.c = s, a.c.forEach(function (e) { r(e, a) }), a.starts && r(a.starts, o); var l = a.c.map(function (e) { return e.bK ? "\\.?(" + e.b + ")\\.?" : e.b }).concat([a.tE, a.i]).map(n).filter(Boolean); a.t = l.length ? t(l.join("|"), !0) : { exec: function () { return null } } } } r(e) } function s(e, t, a, i) { function o(e, n) { for (var t = 0; t < n.c.length; t++)if (r(n.c[t].bR, e)) return n.c[t] } function u(e, n) { if (r(e.eR, n)) { for (; e.endsParent && e.parent;)e = e.parent; return e } return e.eW ? u(e.parent, n) : void 0 } function f(e, n) { return !a && r(n.iR, e) } function g(e, n) { var t = E.cI ? n[0].toLowerCase() : n[0]; return e.k.hasOwnProperty(t) && e.k[t] } function p(e, n, t, r) { var a = r ? "" : x.classPrefix, i = '<span class="' + a, o = t ? "" : "</span>"; return i += e + '">', i + n + o } function d() { if (!L.k) return n(y); var e = "", t = 0; L.lR.lastIndex = 0; for (var r = L.lR.exec(y); r;) { e += n(y.substr(t, r.index - t)); var a = g(L, r); a ? (B += a[1], e += p(a[0], n(r[0]))) : e += n(r[0]), t = L.lR.lastIndex, r = L.lR.exec(y) } return e + n(y.substr(t)) } function h() { if (L.sL && !w[L.sL]) return n(y); var e = L.sL ? s(L.sL, y, !0, M[L.sL]) : l(y); return L.r > 0 && (B += e.r), "continuous" == L.subLanguageMode && (M[L.sL] = e.top), p(e.language, e.value, !1, !0) } function b() { return void 0 !== L.sL ? h() : d() } function v(e, t) { var r = e.cN ? p(e.cN, "", !0) : ""; e.rB ? (k += r, y = "") : e.eB ? (k += n(t) + r, y = "") : (k += r, y = t), L = Object.create(e, { parent: { value: L } }) } function m(e, t) { if (y += e, void 0 === t) return k += b(), 0; var r = o(t, L); if (r) return k += b(), v(r, t), r.rB ? 0 : t.length; var a = u(L, t); if (a) { var i = L; i.rE || i.eE || (y += t), k += b(); do L.cN && (k += "</span>"), B += L.r, L = L.parent; while (L != a.parent); return i.eE && (k += n(t)), y = "", a.starts && v(a.starts, ""), i.rE ? 0 : t.length } if (f(t, L)) throw new Error('Illegal lexeme "' + t + '" for mode "' + (L.cN || "<unnamed>") + '"'); return y += t, t.length || 1 } var E = N(e); if (!E) throw new Error('Unknown language: "' + e + '"'); c(E); var R, L = i || E, M = {}, k = ""; for (R = L; R != E; R = R.parent)R.cN && (k = p(R.cN, "", !0) + k); var y = "", B = 0; try { for (var C, j, I = 0; ;) { if (L.t.lastIndex = I, C = L.t.exec(t), !C) break; j = m(t.substr(I, C.index - I), C[0]), I = C.index + j } for (m(t.substr(I)), R = L; R.parent; R = R.parent)R.cN && (k += "</span>"); return { r: B, value: k, language: e, top: L } } catch (S) { if (-1 != S.message.indexOf("Illegal")) return { r: 0, value: n(t) }; throw S } } function l(e, t) { t = t || x.languages || Object.keys(w); var r = { r: 0, value: n(e) }, a = r; return t.forEach(function (n) { if (N(n)) { var t = s(n, e, !1); t.language = n, t.r > a.r && (a = t), t.r > r.r && (a = r, r = t) } }), a.language && (r.second_best = a), r } function f(e) { return x.tabReplace && (e = e.replace(/^((<[^>]+>|\t)+)/gm, function (e, n) { return n.replace(/\t/g, x.tabReplace) })), x.useBR && (e = e.replace(/\n/g, "<br>")), e } function g(e, n, t) { var r = n ? E[n] : t, a = [e.trim()]; return e.match(/\bhljs\b/) || a.push("hljs"), -1 === e.indexOf(r) && a.push(r), a.join(" ").trim() } function p(e) { var n = a(e); if (!/no(-?)highlight|plain|text/.test(n)) { var t; x.useBR ? (t = document.createElementNS("http://www.w3.org/1999/xhtml", "div"), t.innerHTML = e.innerHTML.replace(/\n/g, "").replace(/<br[ \/]*>/g, "\n")) : t = e; var r = t.textContent, i = n ? s(n, r, !0) : l(r), c = o(t); if (c.length) { var p = document.createElementNS("http://www.w3.org/1999/xhtml", "div"); p.innerHTML = i.value, i.value = u(c, o(p), r) } i.value = f(i.value), e.innerHTML = i.value, e.className = g(e.className, n, i.language), e.result = { language: i.language, re: i.r }, i.second_best && (e.second_best = { language: i.second_best.language, re: i.second_best.r }) } } function d(e) { x = i(x, e) } function h() { if (!h.called) { h.called = !0; var e = document.querySelectorAll("pre code"); Array.prototype.forEach.call(e, p) } } function b() { addEventListener("DOMContentLoaded", h, !1), addEventListener("load", h, !1) } function v(n, t) { var r = w[n] = t(e); r.aliases && r.aliases.forEach(function (e) { E[e] = n }) } function m() { return Object.keys(w) } function N(e) { return w[e] || w[E[e]] } var x = { classPrefix: "hljs-", tabReplace: null, useBR: !1, languages: void 0 }, w = {}, E = {}; return e.highlight = s, e.highlightAuto = l, e.fixMarkup = f, e.highlightBlock = p, e.configure = d, e.initHighlighting = h, e.initHighlightingOnLoad = b, e.registerLanguage = v, e.listLanguages = m, e.getLanguage = N, e.inherit = i, e.IR = "[a-zA-Z]\\w*", e.UIR = "[a-zA-Z_]\\w*", e.NR = "\\b\\d+(\\.\\d+)?", e.CNR = "\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", e.BNR = "\\b(0b[01]+)", e.RSR = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", e.BE = { b: "\\\\[\\s\\S]", r: 0 }, e.ASM = { cN: "string", b: "'", e: "'", i: "\\n", c: [e.BE] }, e.QSM = { cN: "string", b: '"', e: '"', i: "\\n", c: [e.BE] }, e.PWM = { b: /\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such)\b/ }, e.C = function (n, t, r) { var a = e.inherit({ cN: "comment", b: n, e: t, c: [] }, r || {}); return a.c.push(e.PWM), a }, e.CLCM = e.C("//", "$"), e.CBCM = e.C("/\\*", "\\*/"), e.HCM = e.C("#", "$"), e.NM = { cN: "number", b: e.NR, r: 0 }, e.CNM = { cN: "number", b: e.CNR, r: 0 }, e.BNM = { cN: "number", b: e.BNR, r: 0 }, e.CSSNM = { cN: "number", b: e.NR + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?", r: 0 }, e.RM = { cN: "regexp", b: /\//, e: /\/[gimuy]*/, i: /\n/, c: [e.BE, { b: /\[/, e: /\]/, r: 0, c: [e.BE] }] }, e.TM = { cN: "title", b: e.IR, r: 0 }, e.UTM = { cN: "title", b: e.UIR, r: 0 }, e }); hljs.registerLanguage("ini", function (e) { return { cI: !0, i: /\S/, c: [e.C(";", "$"), { cN: "title", b: "^\\[", e: "\\]" }, { cN: "setting", b: "^[a-z0-9\\[\\]_-]+[ \\t]*=[ \\t]*", e: "$", c: [{ cN: "value", eW: !0, k: "on off true false yes no", c: [e.QSM, e.NM], r: 0 }] }] } }); hljs.registerLanguage("json", function (e) { var t = { literal: "true false null" }, i = [e.QSM, e.CNM], l = { cN: "value", e: ",", eW: !0, eE: !0, c: i, k: t }, c = { b: "{", e: "}", c: [{ cN: "attribute", b: '\\s*"', e: '"\\s*:\\s*', eB: !0, eE: !0, c: [e.BE], i: "\\n", starts: l }], i: "\\S" }, n = { b: "\\[", e: "\\]", c: [e.inherit(l, { cN: null })], i: "\\S" }; return i.splice(i.length, 0, c, n), { c: i, k: t, i: "\\S" } }); hljs.registerLanguage("sql", function (e) { var t = e.C("--", "$"); return { cI: !0, i: /[<>]/, c: [{ cN: "operator", bK: "begin end start commit rollback savepoint lock alter create drop rename call delete do handler insert load replace select truncate update set show pragma grant merge describe use explain help declare prepare execute deallocate savepoint release unlock purge reset change stop analyze cache flush optimize repair kill install uninstall checksum restore check backup revoke", e: /;/, eW: !0, k: { keyword: "abs absolute acos action add adddate addtime aes_decrypt aes_encrypt after aggregate all allocate alter analyze and any are as asc ascii asin assertion at atan atan2 atn2 authorization authors avg backup before begin benchmark between bin binlog bit_and bit_count bit_length bit_or bit_xor both by cache call cascade cascaded case cast catalog ceil ceiling chain change changed char_length character_length charindex charset check checksum checksum_agg choose close coalesce coercibility collate collation collationproperty column columns columns_updated commit compress concat concat_ws concurrent connect connection connection_id consistent constraint constraints continue contributors conv convert convert_tz corresponding cos cot count count_big crc32 create cross cume_dist curdate current current_date current_time current_timestamp current_user cursor curtime data database databases datalength date_add date_format date_sub dateadd datediff datefromparts datename datepart datetime2fromparts datetimeoffsetfromparts day dayname dayofmonth dayofweek dayofyear deallocate declare decode default deferrable deferred degrees delayed delete des_decrypt des_encrypt des_key_file desc describe descriptor diagnostics difference disconnect distinct distinctrow div do domain double drop dumpfile each else elt enclosed encode encrypt end end-exec engine engines eomonth errors escape escaped event eventdata events except exception exec execute exists exp explain export_set extended external extract fast fetch field fields find_in_set first first_value floor flush for force foreign format found found_rows from from_base64 from_days from_unixtime full function get get_format get_lock getdate getutcdate global go goto grant grants greatest group group_concat grouping grouping_id gtid_subset gtid_subtract handler having help hex high_priority hosts hour ident_current ident_incr ident_seed identified identity if ifnull ignore iif ilike immediate in index indicator inet6_aton inet6_ntoa inet_aton inet_ntoa infile initially inner innodb input insert install instr intersect into is is_free_lock is_ipv4 is_ipv4_compat is_ipv4_mapped is_not is_not_null is_used_lock isdate isnull isolation join key kill language last last_day last_insert_id last_value lcase lead leading least leaves left len lenght level like limit lines ln load load_file local localtime localtimestamp locate lock log log10 log2 logfile logs low_priority lower lpad ltrim make_set makedate maketime master master_pos_wait match matched max md5 medium merge microsecond mid min minute mod mode module month monthname mutex name_const names national natural nchar next no no_write_to_binlog not now nullif nvarchar oct octet_length of old_password on only open optimize option optionally or ord order outer outfile output pad parse partial partition password patindex percent_rank percentile_cont percentile_disc period_add period_diff pi plugin position pow power pragma precision prepare preserve primary prior privileges procedure procedure_analyze processlist profile profiles public publishingservername purge quarter query quick quote quotename radians rand read references regexp relative relaylog release release_lock rename repair repeat replace replicate reset restore restrict return returns reverse revoke right rlike rollback rollup round row row_count rows rpad rtrim savepoint schema scroll sec_to_time second section select serializable server session session_user set sha sha1 sha2 share show sign sin size slave sleep smalldatetimefromparts snapshot some soname soundex sounds_like space sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sql_variant_property sqlstate sqrt square start starting status std stddev stddev_pop stddev_samp stdev stdevp stop str str_to_date straight_join strcmp string stuff subdate substr substring subtime subtring_index sum switchoffset sysdate sysdatetime sysdatetimeoffset system_user sysutcdatetime table tables tablespace tan temporary terminated tertiary_weights then time time_format time_to_sec timediff timefromparts timestamp timestampadd timestampdiff timezone_hour timezone_minute to to_base64 to_days to_seconds todatetimeoffset trailing transaction translation trigger trigger_nestlevel triggers trim truncate try_cast try_convert try_parse ucase uncompress uncompressed_length unhex unicode uninstall union unique unix_timestamp unknown unlock update upgrade upped upper usage use user user_resources using utc_date utc_time utc_timestamp uuid uuid_short validate_password_strength value values var var_pop var_samp variables variance varp version view warnings week weekday weekofyear weight_string when whenever where with work write xml xor year yearweek zon", literal: "true false null", built_in: "array bigint binary bit blob boolean char character date dec decimal float int integer interval number numeric real serial smallint varchar varying int8 serial8 text" }, c: [{ cN: "string", b: "'", e: "'", c: [e.BE, { b: "''" }] }, { cN: "string", b: '"', e: '"', c: [e.BE, { b: '""' }] }, { cN: "string", b: "`", e: "`", c: [e.BE] }, e.CNM, e.CBCM, t] }, e.CBCM, t] } }); hljs.registerLanguage("javascript", function (e) { return { aliases: ["js"], k: { keyword: "in of if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const export super debugger as await", literal: "true false null undefined NaN Infinity", built_in: "eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect Promise" }, c: [{ cN: "pi", r: 10, v: [{ b: /^\s*('|")use strict('|")/ }, { b: /^\s*('|")use asm('|")/ }] }, e.ASM, e.QSM, { cN: "string", b: "`", e: "`", c: [e.BE, { cN: "subst", b: "\\$\\{", e: "\\}" }] }, e.CLCM, e.CBCM, { cN: "number", b: "\\b(0[xXbBoO][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", r: 0 }, { b: "(" + e.RSR + "|\\b(case|return|throw)\\b)\\s*", k: "return throw case", c: [e.CLCM, e.CBCM, e.RM, { b: /</, e: />\s*[);\]]/, r: 0, sL: "xml" }], r: 0 }, { cN: "function", bK: "function", e: /\{/, eE: !0, c: [e.inherit(e.TM, { b: /[A-Za-z$_][0-9A-Za-z$_]*/ }), { cN: "params", b: /\(/, e: /\)/, c: [e.CLCM, e.CBCM], i: /["'\(]/ }], i: /\[|%/ }, { b: /\$[(.]/ }, { b: "\\." + e.IR, r: 0 }, { bK: "import", e: "[;$]", k: "import from as", c: [e.ASM, e.QSM] }, { cN: "class", bK: "class", e: /[{;=]/, eE: !0, i: /[:"\[\]]/, c: [{ bK: "extends" }, e.UTM] }] } }); hljs.registerLanguage("perl", function (e) { var t = "getpwent getservent quotemeta msgrcv scalar kill dbmclose undef lc ma syswrite tr send umask sysopen shmwrite vec qx utime local oct semctl localtime readpipe do return format read sprintf dbmopen pop getpgrp not getpwnam rewinddir qqfileno qw endprotoent wait sethostent bless s|0 opendir continue each sleep endgrent shutdown dump chomp connect getsockname die socketpair close flock exists index shmgetsub for endpwent redo lstat msgctl setpgrp abs exit select print ref gethostbyaddr unshift fcntl syscall goto getnetbyaddr join gmtime symlink semget splice x|0 getpeername recv log setsockopt cos last reverse gethostbyname getgrnam study formline endhostent times chop length gethostent getnetent pack getprotoent getservbyname rand mkdir pos chmod y|0 substr endnetent printf next open msgsnd readdir use unlink getsockopt getpriority rindex wantarray hex system getservbyport endservent int chr untie rmdir prototype tell listen fork shmread ucfirst setprotoent else sysseek link getgrgid shmctl waitpid unpack getnetbyname reset chdir grep split require caller lcfirst until warn while values shift telldir getpwuid my getprotobynumber delete and sort uc defined srand accept package seekdir getprotobyname semop our rename seek if q|0 chroot sysread setpwent no crypt getc chown sqrt write setnetent setpriority foreach tie sin msgget map stat getlogin unless elsif truncate exec keys glob tied closedirioctl socket readlink eval xor readline binmode setservent eof ord bind alarm pipe atan2 getgrent exp time push setgrent gt lt or ne m|0 break given say state when", r = { cN: "subst", b: "[$@]\\{", e: "\\}", k: t }, s = { b: "->{", e: "}" }, n = { cN: "variable", v: [{ b: /\$\d/ }, { b: /[\$%@](\^\w\b|#\w+(::\w+)*|{\w+}|\w+(::\w*)*)/ }, { b: /[\$%@][^\s\w{]/, r: 0 }] }, i = e.C("^(__END__|__DATA__)", "\\n$", { r: 5 }), o = [e.BE, r, n], a = [n, e.HCM, i, e.C("^\\=\\w", "\\=cut", { eW: !0 }), s, { cN: "string", c: o, v: [{ b: "q[qwxr]?\\s*\\(", e: "\\)", r: 5 }, { b: "q[qwxr]?\\s*\\[", e: "\\]", r: 5 }, { b: "q[qwxr]?\\s*\\{", e: "\\}", r: 5 }, { b: "q[qwxr]?\\s*\\|", e: "\\|", r: 5 }, { b: "q[qwxr]?\\s*\\<", e: "\\>", r: 5 }, { b: "qw\\s+q", e: "q", r: 5 }, { b: "'", e: "'", c: [e.BE] }, { b: '"', e: '"' }, { b: "`", e: "`", c: [e.BE] }, { b: "{\\w+}", c: [], r: 0 }, { b: "-?\\w+\\s*\\=\\>", c: [], r: 0 }] }, { cN: "number", b: "(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b", r: 0 }, { b: "(\\/\\/|" + e.RSR + "|\\b(split|return|print|reverse|grep)\\b)\\s*", k: "split return print reverse grep", r: 0, c: [e.HCM, i, { cN: "regexp", b: "(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*", r: 10 }, { cN: "regexp", b: "(m|qr)?/", e: "/[a-z]*", c: [e.BE], r: 0 }] }, { cN: "sub", bK: "sub", e: "(\\s*\\(.*?\\))?[;{]", r: 5 }, { cN: "operator", b: "-\\w\\b", r: 0 }]; return r.c = a, s.c = a, { aliases: ["pl"], k: t, c: a } }); hljs.registerLanguage("nginx", function (e) { var r = { cN: "variable", v: [{ b: /\$\d+/ }, { b: /\$\{/, e: /}/ }, { b: "[\\$\\@]" + e.UIR }] }, b = { eW: !0, l: "[a-z/_]+", k: { built_in: "on off yes no true false none blocked debug info notice warn error crit select break last permanent redirect kqueue rtsig epoll poll /dev/poll" }, r: 0, i: "=>", c: [e.HCM, { cN: "string", c: [e.BE, r], v: [{ b: /"/, e: /"/ }, { b: /'/, e: /'/ }] }, { cN: "url", b: "([a-z]+):/", e: "\\s", eW: !0, eE: !0, c: [r] }, { cN: "regexp", c: [e.BE, r], v: [{ b: "\\s\\^", e: "\\s|{|;", rE: !0 }, { b: "~\\*?\\s+", e: "\\s|{|;", rE: !0 }, { b: "\\*(\\.[a-z\\-]+)+" }, { b: "([a-z\\-]+\\.)+\\*" }] }, { cN: "number", b: "\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b" }, { cN: "number", b: "\\b\\d+[kKmMgGdshdwy]*\\b", r: 0 }, r] }; return { aliases: ["nginxconf"], c: [e.HCM, { b: e.UIR + "\\s", e: ";|{", rB: !0, c: [{ cN: "title", b: e.UIR, starts: b }], r: 0 }], i: "[^\\s\\}]" } }); hljs.registerLanguage("php", function (e) { var c = { cN: "variable", b: "\\$+[a-zA-Z_-ÿ][a-zA-Z0-9_-ÿ]*" }, i = { cN: "preprocessor", b: /<\?(php)?|\?>/ }, a = { cN: "string", c: [e.BE, i], v: [{ b: 'b"', e: '"' }, { b: "b'", e: "'" }, e.inherit(e.ASM, { i: null }), e.inherit(e.QSM, { i: null })] }, n = { v: [e.BNM, e.CNM] }; return { aliases: ["php3", "php4", "php5", "php6"], cI: !0, k: "and include_once list abstract global private echo interface as static endswitch array null if endwhile or const for endforeach self var while isset public protected exit foreach throw elseif include __FILE__ empty require_once do xor return parent clone use __CLASS__ __LINE__ else break print eval new catch __METHOD__ case exception default die require __FUNCTION__ enddeclare final try switch continue endfor endif declare unset true false trait goto instanceof insteadof __DIR__ __NAMESPACE__ yield finally", c: [e.CLCM, e.HCM, e.C("/\\*", "\\*/", { c: [{ cN: "phpdoc", b: "\\s@[A-Za-z]+" }, i] }), e.C("__halt_compiler.+?;", !1, { eW: !0, k: "__halt_compiler", l: e.UIR }), { cN: "string", b: "<<<['\"]?\\w+['\"]?$", e: "^\\w+;", c: [e.BE] }, i, c, { b: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/ }, { cN: "function", bK: "function", e: /[;{]/, eE: !0, i: "\\$|\\[|%", c: [e.UTM, { cN: "params", b: "\\(", e: "\\)", c: ["self", c, e.CBCM, a, n] }] }, { cN: "class", bK: "class interface", e: "{", eE: !0, i: /[:\(\$"]/, c: [{ bK: "extends implements" }, e.UTM] }, { bK: "namespace", e: ";", i: /[\.']/, c: [e.UTM] }, { bK: "use", e: ";", c: [e.UTM] }, { b: "=>" }, a, n] } }); hljs.registerLanguage("java", function (e) { var a = e.UIR + "(<" + e.UIR + ">)?", t = "false synchronized int abstract float private char boolean static null if const for true while long strictfp finally protected import native final void enum else break transient catch instanceof byte super volatile case assert short package default double public try this switch continue throws protected public private", c = "(\\b(0b[01_]+)|\\b0[xX][a-fA-F0-9_]+|(\\b[\\d_]+(\\.[\\d_]*)?|\\.[\\d_]+)([eE][-+]?\\d+)?)[lLfF]?", r = { cN: "number", b: c, r: 0 }; return { aliases: ["jsp"], k: t, i: /<\//, c: [{ cN: "javadoc", b: "/\\*\\*", e: "\\*/", r: 0, c: [{ cN: "javadoctag", b: "(^|\\s)@[A-Za-z]+" }] }, e.CLCM, e.CBCM, e.ASM, e.QSM, { cN: "class", bK: "class interface", e: /[{;=]/, eE: !0, k: "class interface", i: /[:"\[\]]/, c: [{ bK: "extends implements" }, e.UTM] }, { bK: "new throw return", r: 0 }, { cN: "function", b: "(" + a + "\\s+)+" + e.UIR + "\\s*\\(", rB: !0, e: /[{;=]/, eE: !0, k: t, c: [{ b: e.UIR + "\\s*\\(", rB: !0, r: 0, c: [e.UTM] }, { cN: "params", b: /\(/, e: /\)/, k: t, r: 0, c: [e.ASM, e.QSM, e.CNM, e.CBCM] }, e.CLCM, e.CBCM] }, r, { cN: "annotation", b: "@[A-Za-z]+" }] } }); hljs.registerLanguage("cpp", function (t) { var i = { keyword: "false int float while private char catch export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const struct for static_cast|10 union namespace unsigned long volatile static protected bool template mutable if public friend do goto auto void enum else break extern using true class asm case typeid short reinterpret_cast|10 default double register explicit signed typename try this switch continue wchar_t inline delete alignof char16_t char32_t constexpr decltype noexcept nullptr static_assert thread_local restrict _Bool complex _Complex _Imaginary intmax_t uintmax_t int8_t uint8_t int16_t uint16_t int32_t uint32_t  int64_t uint64_t int_least8_t uint_least8_t int_least16_t uint_least16_t int_least32_t uint_least32_t int_least64_t uint_least64_t int_fast8_t uint_fast8_t int_fast16_t uint_fast16_t int_fast32_t uint_fast32_t int_fast64_t uint_fast64_t intptr_t uintptr_t atomic_bool atomic_char atomic_schar atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong atomic_ullong atomic_wchar_t atomic_char16_t atomic_char32_t atomic_intmax_t atomic_uintmax_t atomic_intptr_t atomic_uintptr_t atomic_size_t atomic_ptrdiff_t atomic_int_least8_t atomic_int_least16_t atomic_int_least32_t atomic_int_least64_t atomic_uint_least8_t atomic_uint_least16_t atomic_uint_least32_t atomic_uint_least64_t atomic_int_fast8_t atomic_int_fast16_t atomic_int_fast32_t atomic_int_fast64_t atomic_uint_fast8_t atomic_uint_fast16_t atomic_uint_fast32_t atomic_uint_fast64_t", built_in: "std string cin cout cerr clog stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap array shared_ptr abort abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf" }; return { aliases: ["c", "cc", "h", "c++", "h++", "hpp"], k: i, i: "</", c: [t.CLCM, t.CBCM, t.QSM, { cN: "string", b: "'\\\\?.", e: "'", i: "." }, { cN: "number", b: "\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)" }, t.CNM, { cN: "preprocessor", b: "#", e: "$", k: "if else elif endif define undef warning error line pragma", c: [{ b: /\\\n/, r: 0 }, { b: 'include\\s*[<"]', e: '[>"]', k: "include", i: "\\n" }, t.CLCM] }, { b: "\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<", e: ">", k: i, c: ["self"] }, { b: t.IR + "::", k: i }, { bK: "new throw return else", r: 0 }, { cN: "function", b: "(" + t.IR + "\\s+)+" + t.IR + "\\s*\\(", rB: !0, e: /[{;=]/, eE: !0, k: i, c: [{ b: t.IR + "\\s*\\(", rB: !0, c: [t.TM], r: 0 }, { cN: "params", b: /\(/, e: /\)/, k: i, r: 0, c: [t.CBCM] }, t.CLCM, t.CBCM] }] } }); hljs.registerLanguage("coffeescript", function (e) { var c = { keyword: "in if for while finally new do return else break catch instanceof throw try this switch continue typeof delete debugger super then unless until loop of by when and or is isnt not", literal: "true false null undefined yes no on off", reserved: "case default function var void with const let enum export import native __hasProp __extends __slice __bind __indexOf", built_in: "npm require console print module global window document" }, n = "[A-Za-z$_][0-9A-Za-z$_]*", t = { cN: "subst", b: /#\{/, e: /}/, k: c }, r = [e.BNM, e.inherit(e.CNM, { starts: { e: "(\\s*/)?", r: 0 } }), { cN: "string", v: [{ b: /'''/, e: /'''/, c: [e.BE] }, { b: /'/, e: /'/, c: [e.BE] }, { b: /"""/, e: /"""/, c: [e.BE, t] }, { b: /"/, e: /"/, c: [e.BE, t] }] }, { cN: "regexp", v: [{ b: "///", e: "///", c: [t, e.HCM] }, { b: "//[gim]*", r: 0 }, { b: /\/(?![ *])(\\\/|.)*?\/[gim]*(?=\W|$)/ }] }, { cN: "property", b: "@" + n }, { b: "`", e: "`", eB: !0, eE: !0, sL: "javascript" }]; t.c = r; var i = e.inherit(e.TM, { b: n }), s = "(\\(.*\\))?\\s*\\B[-=]>", o = { cN: "params", b: "\\([^\\(]", rB: !0, c: [{ b: /\(/, e: /\)/, k: c, c: ["self"].concat(r) }] }; return { aliases: ["coffee", "cson", "iced"], k: c, i: /\/\*/, c: r.concat([e.C("###", "###"), e.HCM, { cN: "function", b: "^\\s*" + n + "\\s*=\\s*" + s, e: "[-=]>", rB: !0, c: [i, o] }, { b: /[:\(,=]\s*/, r: 0, c: [{ cN: "function", b: s, e: "[-=]>", rB: !0, c: [o] }] }, { cN: "class", bK: "class", e: "$", i: /[:="\[\]]/, c: [{ bK: "extends", eW: !0, i: /[:="\[\]]/, c: [i] }, i] }, { cN: "attribute", b: n + ":", e: ":", rB: !0, rE: !0, r: 0 }]) } }); hljs.registerLanguage("http", function (t) { return { aliases: ["https"], i: "\\S", c: [{ cN: "status", b: "^HTTP/[0-9\\.]+", e: "$", c: [{ cN: "number", b: "\\b\\d{3}\\b" }] }, { cN: "request", b: "^[A-Z]+ (.*?) HTTP/[0-9\\.]+$", rB: !0, e: "$", c: [{ cN: "string", b: " ", e: " ", eB: !0, eE: !0 }] }, { cN: "attribute", b: "^\\w", e: ": ", eE: !0, i: "\\n|\\s|=", starts: { cN: "string", e: "$" } }, { b: "\\n\\n", starts: { sL: "", eW: !0 } }] } }); hljs.registerLanguage("xml", function (t) { var e = "[A-Za-z0-9\\._:-]+", s = { b: /<\?(php)?(?!\w)/, e: /\?>/, sL: "php", subLanguageMode: "continuous" }, c = { eW: !0, i: /</, r: 0, c: [s, { cN: "attribute", b: e, r: 0 }, { b: "=", r: 0, c: [{ cN: "value", c: [s], v: [{ b: /"/, e: /"/ }, { b: /'/, e: /'/ }, { b: /[^\s\/>]+/ }] }] }] }; return { aliases: ["html", "xhtml", "rss", "atom", "xsl", "plist"], cI: !0, c: [{ cN: "doctype", b: "<!DOCTYPE", e: ">", r: 10, c: [{ b: "\\[", e: "\\]" }] }, t.C("<!--", "-->", { r: 10 }), { cN: "cdata", b: "<\\!\\[CDATA\\[", e: "\\]\\]>", r: 10 }, { cN: "tag", b: "<style(?=\\s|>|$)", e: ">", k: { title: "style" }, c: [c], starts: { e: "</style>", rE: !0, sL: "css" } }, { cN: "tag", b: "<script(?=\\s|>|$)", e: ">", k: { title: "script" }, c: [c], starts: { e: "</script>", rE: !0, sL: "" } }, s, { cN: "pi", b: /<\?\w+/, e: /\?>/, r: 10 }, { cN: "tag", b: "</?", e: "/?>", c: [{ cN: "title", b: /[^ \/><\n\t]+/, r: 0 }, c] }] } }); hljs.registerLanguage("cs", function (e) { var r = "abstract as base bool break byte case catch char checked const continue decimal dynamic default delegate do double else enum event explicit extern false finally fixed float for foreach goto if implicit in int interface internal is lock long null when object operator out override params private protected public readonly ref sbyte sealed short sizeof stackalloc static string struct switch this true try typeof uint ulong unchecked unsafe ushort using virtual volatile void while async protected public private internal ascending descending from get group into join let orderby partial select set value var where yield", t = e.IR + "(<" + e.IR + ">)?"; return { aliases: ["csharp"], k: r, i: /::/, c: [e.C("///", "$", { rB: !0, c: [{ cN: "xmlDocTag", v: [{ b: "///", r: 0 }, { b: "<!--|-->" }, { b: "</?", e: ">" }] }] }), e.CLCM, e.CBCM, { cN: "preprocessor", b: "#", e: "$", k: "if else elif endif define undef warning error line region endregion pragma checksum" }, { cN: "string", b: '@"', e: '"', c: [{ b: '""' }] }, e.ASM, e.QSM, e.CNM, { bK: "class namespace interface", e: /[{;=]/, i: /[^\s:]/, c: [e.TM, e.CLCM, e.CBCM] }, { bK: "new return throw await", r: 0 }, { cN: "function", b: "(" + t + "\\s+)+" + e.IR + "\\s*\\(", rB: !0, e: /[{;=]/, eE: !0, k: r, c: [{ b: e.IR + "\\s*\\(", rB: !0, c: [e.TM], r: 0 }, { cN: "params", b: /\(/, e: /\)/, k: r, r: 0, c: [e.ASM, e.QSM, e.CNM, e.CBCM] }, e.CLCM, e.CBCM] }] } }); hljs.registerLanguage("python", function (e) { var r = { cN: "prompt", b: /^(>>>|\.\.\.) / }, b = { cN: "string", c: [e.BE], v: [{ b: /(u|b)?r?'''/, e: /'''/, c: [r], r: 10 }, { b: /(u|b)?r?"""/, e: /"""/, c: [r], r: 10 }, { b: /(u|r|ur)'/, e: /'/, r: 10 }, { b: /(u|r|ur)"/, e: /"/, r: 10 }, { b: /(b|br)'/, e: /'/ }, { b: /(b|br)"/, e: /"/ }, e.ASM, e.QSM] }, l = { cN: "number", r: 0, v: [{ b: e.BNR + "[lLjJ]?" }, { b: "\\b(0o[0-7]+)[lLjJ]?" }, { b: e.CNR + "[lLjJ]?" }] }, c = { cN: "params", b: /\(/, e: /\)/, c: ["self", r, l, b] }; return { aliases: ["py", "gyp"], k: { keyword: "and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda nonlocal|10 None True False", built_in: "Ellipsis NotImplemented" }, i: /(<\/|->|\?)/, c: [r, l, b, e.HCM, { v: [{ cN: "function", bK: "def", r: 10 }, { cN: "class", bK: "class" }], e: /:/, i: /[${=;\n,]/, c: [e.UTM, c] }, { cN: "decorator", b: /@/, e: /$/ }, { b: /\b(print|exec)\(/ }] } }); hljs.registerLanguage("bash", function (e) { var t = { cN: "variable", v: [{ b: /\$[\w\d#@][\w\d_]*/ }, { b: /\$\{(.*?)}/ }] }, s = { cN: "string", b: /"/, e: /"/, c: [e.BE, t, { cN: "variable", b: /\$\(/, e: /\)/, c: [e.BE] }] }, a = { cN: "string", b: /'/, e: /'/ }; return { aliases: ["sh", "zsh"], l: /-?[a-z\.]+/, k: { keyword: "if then else elif fi for while in do done case esac function", literal: "true false", built_in: "break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp", operator: "-ne -eq -lt -gt -f -d -e -s -l -a" }, c: [{ cN: "shebang", b: /^#![^\n]+sh\s*$/, r: 10 }, { cN: "function", b: /\w[\w\d_]*\s*\(\s*\)\s*\{/, rB: !0, c: [e.inherit(e.TM, { b: /\w[\w\d_]*/ })], r: 0 }, e.HCM, e.NM, s, a, t] } }); hljs.registerLanguage("diff", function (e) { return { aliases: ["patch"], c: [{ cN: "chunk", r: 10, v: [{ b: /^@@ +\-\d+,\d+ +\+\d+,\d+ +@@$/ }, { b: /^\*\*\* +\d+,\d+ +\*\*\*\*$/ }, { b: /^\-\-\- +\d+,\d+ +\-\-\-\-$/ }] }, { cN: "header", v: [{ b: /Index: /, e: /$/ }, { b: /=====/, e: /=====$/ }, { b: /^\-\-\-/, e: /$/ }, { b: /^\*{3} /, e: /$/ }, { b: /^\+\+\+/, e: /$/ }, { b: /\*{5}/, e: /\*{5}$/ }] }, { cN: "addition", b: "^\\+", e: "$" }, { cN: "deletion", b: "^\\-", e: "$" }, { cN: "change", b: "^\\!", e: "$" }] } }); hljs.registerLanguage("css", function (e) { var c = "[a-zA-Z-][a-zA-Z0-9_-]*", a = { cN: "function", b: c + "\\(", rB: !0, eE: !0, e: "\\(" }, r = { cN: "rule", b: /[A-Z\_\.\-]+\s*:/, rB: !0, e: ";", eW: !0, c: [{ cN: "attribute", b: /\S/, e: ":", eE: !0, starts: { cN: "value", eW: !0, eE: !0, c: [a, e.CSSNM, e.QSM, e.ASM, e.CBCM, { cN: "hexcolor", b: "#[0-9A-Fa-f]+" }, { cN: "important", b: "!important" }] } }] }; return { cI: !0, i: /[=\/|']/, c: [e.CBCM, r, { cN: "id", b: /\#[A-Za-z0-9_-]+/ }, { cN: "class", b: /\.[A-Za-z0-9_-]+/, r: 0 }, { cN: "attr_selector", b: /\[/, e: /\]/, i: "$" }, { cN: "pseudo", b: /:(:)?[a-zA-Z0-9\_\-\+\(\)"']+/ }, { cN: "at_rule", b: "@(font-face|page)", l: "[a-z-]+", k: "font-face page" }, { cN: "at_rule", b: "@", e: "[{;]", c: [{ cN: "keyword", b: /\S+/ }, { b: /\s/, eW: !0, eE: !0, r: 0, c: [a, e.ASM, e.QSM, e.CSSNM] }] }, { cN: "tag", b: c, r: 0 }, { cN: "rules", b: "{", e: "}", i: /\S/, r: 0, c: [e.CBCM, r] }] } }); hljs.registerLanguage("apache", function (e) { var r = { cN: "number", b: "[\\$%]\\d+" }; return { aliases: ["apacheconf"], cI: !0, c: [e.HCM, { cN: "tag", b: "</?", e: ">" }, { cN: "keyword", b: /\w+/, r: 0, k: { common: "order deny allow setenv rewriterule rewriteengine rewritecond documentroot sethandler errordocument loadmodule options header listen serverroot servername" }, starts: { e: /$/, r: 0, k: { literal: "on off all" }, c: [{ cN: "sqbracket", b: "\\s\\[", e: "\\]$" }, { cN: "cbracket", b: "[\\$%]\\{", e: "\\}", c: ["self", r] }, r, e.QSM] } }], i: /\S/ } }); hljs.registerLanguage("markdown", function (e) { return { aliases: ["md", "mkdown", "mkd"], c: [{ cN: "header", v: [{ b: "^#{1,6}", e: "$" }, { b: "^.+?\\n[=-]{2,}$" }] }, { b: "<", e: ">", sL: "xml", r: 0 }, { cN: "bullet", b: "^([*+-]|(\\d+\\.))\\s+" }, { cN: "strong", b: "[*_]{2}.+?[*_]{2}" }, { cN: "emphasis", v: [{ b: "\\*.+?\\*" }, { b: "_.+?_", r: 0 }] }, { cN: "blockquote", b: "^>\\s+", e: "$" }, { cN: "code", v: [{ b: "`.+?`" }, { b: "^( {4}| )", e: "$", r: 0 }] }, { cN: "horizontal_rule", b: "^[-\\*]{3,}", e: "$" }, { b: "\\[.+?\\][\\(\\[].*?[\\)\\]]", rB: !0, c: [{ cN: "link_label", b: "\\[", e: "\\]", eB: !0, rE: !0, r: 0 }, { cN: "link_url", b: "\\]\\(", e: "\\)", eB: !0, eE: !0 }, { cN: "link_reference", b: "\\]\\[", e: "\\]", eB: !0, eE: !0 }], r: 10 }, { b: "^\\[.+\\]:", rB: !0, c: [{ cN: "link_reference", b: "\\[", e: "\\]:", eB: !0, eE: !0, starts: { cN: "link_url", e: "$" } }] }] } }); hljs.registerLanguage("makefile", function (e) { var a = { cN: "variable", b: /\$\(/, e: /\)/, c: [e.BE] }; return { aliases: ["mk", "mak"], c: [e.HCM, { b: /^\w+\s*\W*=/, rB: !0, r: 0, starts: { cN: "constant", e: /\s*\W*=/, eE: !0, starts: { e: /$/, r: 0, c: [a] } } }, { cN: "title", b: /^[\w]+:\s*$/ }, { cN: "phony", b: /^\.PHONY:/, e: /$/, k: ".PHONY", l: /[\.\w]+/ }, { b: /^\t+/, e: /$/, r: 0, c: [e.QSM, a] }] } }); hljs.registerLanguage("ruby", function (e) { var c = "[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?", r = "and false then defined module in return redo if BEGIN retry end for true self when next until do begin unless END rescue nil else break undef not super class case require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor", b = { cN: "yardoctag", b: "@[A-Za-z]+" }, a = { cN: "value", b: "#<", e: ">" }, n = [e.C("#", "$", { c: [b] }), e.C("^\\=begin", "^\\=end", { c: [b], r: 10 }), e.C("^__END__", "\\n$")], s = { cN: "subst", b: "#\\{", e: "}", k: r }, t = { cN: "string", c: [e.BE, s], v: [{ b: /'/, e: /'/ }, { b: /"/, e: /"/ }, { b: /`/, e: /`/ }, { b: "%[qQwWx]?\\(", e: "\\)" }, { b: "%[qQwWx]?\\[", e: "\\]" }, { b: "%[qQwWx]?{", e: "}" }, { b: "%[qQwWx]?<", e: ">" }, { b: "%[qQwWx]?/", e: "/" }, { b: "%[qQwWx]?%", e: "%" }, { b: "%[qQwWx]?-", e: "-" }, { b: "%[qQwWx]?\\|", e: "\\|" }, { b: /\B\?(\\\d{1,3}|\\x[A-Fa-f0-9]{1,2}|\\u[A-Fa-f0-9]{4}|\\?\S)\b/ }] }, i = { cN: "params", b: "\\(", e: "\\)", k: r }, d = [t, a, { cN: "class", bK: "class module", e: "$|;", i: /=/, c: [e.inherit(e.TM, { b: "[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?" }), { cN: "inheritance", b: "<\\s*", c: [{ cN: "parent", b: "(" + e.IR + "::)?" + e.IR }] }].concat(n) }, { cN: "function", bK: "def", e: " |$|;", r: 0, c: [e.inherit(e.TM, { b: c }), i].concat(n) }, { cN: "constant", b: "(::)?(\\b[A-Z]\\w*(::)?)+", r: 0 }, { cN: "symbol", b: e.UIR + "(\\!|\\?)?:", r: 0 }, { cN: "symbol", b: ":", c: [t, { b: c }], r: 0 }, { cN: "number", b: "(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b", r: 0 }, { cN: "variable", b: "(\\$\\W)|((\\$|\\@\\@?)(\\w+))" }, { b: "(" + e.RSR + ")\\s*", c: [a, { cN: "regexp", c: [e.BE, s], i: /\n/, v: [{ b: "/", e: "/[a-z]*" }, { b: "%r{", e: "}[a-z]*" }, { b: "%r\\(", e: "\\)[a-z]*" }, { b: "%r!", e: "![a-z]*" }, { b: "%r\\[", e: "\\][a-z]*" }] }].concat(n), r: 0 }].concat(n); s.c = d, i.c = d; var o = "[>?]>", l = "[\\w#]+\\(\\w+\\):\\d+:\\d+>", u = "(\\w+-)?\\d+\\.\\d+\\.\\d(p\\d+)?[^>]+>", N = [{ b: /^\s*=>/, cN: "status", starts: { e: "$", c: d } }, { cN: "prompt", b: "^(" + o + "|" + l + "|" + u + ")", starts: { e: "$", c: d } }]; return { aliases: ["rb", "gemspec", "podspec", "thor", "irb"], k: r, c: n.concat(N).concat(d) } }); hljs.registerLanguage("objectivec", function (e) { var t = { cN: "built_in", b: "(AV|CA|CF|CG|CI|MK|MP|NS|UI)\\w+" }, i = { keyword: "int float while char export sizeof typedef const struct for union unsigned long volatile static bool mutable if do return goto void enum else break extern asm case short default double register explicit signed typename this switch continue wchar_t inline readonly assign readwrite self @synchronized id typeof nonatomic super unichar IBOutlet IBAction strong weak copy in out inout bycopy byref oneway __strong __weak __block __autoreleasing @private @protected @public @try @property @end @throw @catch @finally @autoreleasepool @synthesize @dynamic @selector @optional @required", literal: "false true FALSE TRUE nil YES NO NULL", built_in: "BOOL dispatch_once_t dispatch_queue_t dispatch_sync dispatch_async dispatch_once" }, o = /[a-zA-Z@][a-zA-Z0-9_]*/, n = "@interface @class @protocol @implementation"; return { aliases: ["m", "mm", "objc", "obj-c"], k: i, l: o, i: "</", c: [t, e.CLCM, e.CBCM, e.CNM, e.QSM, { cN: "string", v: [{ b: '@"', e: '"', i: "\\n", c: [e.BE] }, { b: "'", e: "[^\\\\]'", i: "[^\\\\][^']" }] }, { cN: "preprocessor", b: "#", e: "$", c: [{ cN: "title", v: [{ b: '"', e: '"' }, { b: "<", e: ">" }] }] }, { cN: "class", b: "(" + n.split(" ").join("|") + ")\\b", e: "({|$)", eE: !0, k: n, l: o, c: [e.UTM] }, { cN: "variable", b: "\\." + e.UIR, r: 0 }] } });

/*====================================================
3. GhostHunter
====================================================*/
(function ($) { var lunr = function (t) { var e = new lunr.Index; return e.pipeline.add(lunr.stopWordFilter, lunr.stemmer), t && t.call(e, e), e }; lunr.version = "0.4.3", "undefined" != typeof module && (module.exports = lunr), lunr.utils = {}, lunr.utils.warn = function (t) { return function (e) { t.console && console.warn && console.warn(e) } }(this), lunr.utils.zeroFillArray = function () { var t = [0]; return function (e) { for (; e > t.length;)t = t.concat(t); return t.slice(0, e) } }(), lunr.EventEmitter = function () { this.events = {} }, lunr.EventEmitter.prototype.addListener = function () { var t = Array.prototype.slice.call(arguments), e = t.pop(), n = t; if ("function" != typeof e) throw new TypeError("last argument must be a function"); n.forEach(function (t) { this.hasHandler(t) || (this.events[t] = []), this.events[t].push(e) }, this) }, lunr.EventEmitter.prototype.removeListener = function (t, e) { if (this.hasHandler(t)) { var n = this.events[t].indexOf(e); this.events[t].splice(n, 1), this.events[t].length || delete this.events[t] } }, lunr.EventEmitter.prototype.emit = function (t) { if (this.hasHandler(t)) { var e = Array.prototype.slice.call(arguments, 1); this.events[t].forEach(function (t) { t.apply(void 0, e) }) } }, lunr.EventEmitter.prototype.hasHandler = function (t) { return t in this.events }, lunr.tokenizer = function (t) { if (!arguments.length || null == t || void 0 == t) return []; if (Array.isArray(t)) return t.map(function (t) { return t.toLowerCase() }); for (var e = ("" + t).replace(/^\s+/, ""), n = e.length - 1; n >= 0; n--)if (/\S/.test(e.charAt(n))) { e = e.substring(0, n + 1); break } return e.split(/\s+/).map(function (t) { return t.replace(/^\W+/, "").replace(/\W+$/, "").toLowerCase() }) }, lunr.Pipeline = function () { this._stack = [] }, lunr.Pipeline.registeredFunctions = {}, lunr.Pipeline.registerFunction = function (t, e) { e in this.registeredFunctions && lunr.utils.warn("Overwriting existing registered function: " + e), t.label = e, lunr.Pipeline.registeredFunctions[t.label] = t }, lunr.Pipeline.warnIfFunctionNotRegistered = function (t) { var e = t.label && t.label in this.registeredFunctions; e || lunr.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n", t) }, lunr.Pipeline.load = function (t) { var e = new lunr.Pipeline; return t.forEach(function (t) { var n = lunr.Pipeline.registeredFunctions[t]; if (!n) throw Error("Cannot load un-registered function: " + t); e.add(n) }), e }, lunr.Pipeline.prototype.add = function () { var t = Array.prototype.slice.call(arguments); t.forEach(function (t) { lunr.Pipeline.warnIfFunctionNotRegistered(t), this._stack.push(t) }, this) }, lunr.Pipeline.prototype.after = function (t, e) { lunr.Pipeline.warnIfFunctionNotRegistered(e); var n = this._stack.indexOf(t) + 1; this._stack.splice(n, 0, e) }, lunr.Pipeline.prototype.before = function (t, e) { lunr.Pipeline.warnIfFunctionNotRegistered(e); var n = this._stack.indexOf(t); this._stack.splice(n, 0, e) }, lunr.Pipeline.prototype.remove = function (t) { var e = this._stack.indexOf(t); this._stack.splice(e, 1) }, lunr.Pipeline.prototype.run = function (t) { for (var e = [], n = t.length, r = this._stack.length, o = 0; n > o; o++) { for (var i = t[o], s = 0; r > s && (i = this._stack[s](i, o, t), void 0 !== i); s++); void 0 !== i && e.push(i) } return e }, lunr.Pipeline.prototype.toJSON = function () { return this._stack.map(function (t) { return lunr.Pipeline.warnIfFunctionNotRegistered(t), t.label }) }, lunr.Vector = function (t) { this.elements = t }, lunr.Vector.prototype.magnitude = function () { if (this._magnitude) return this._magnitude; for (var t, e = 0, n = this.elements, r = n.length, o = 0; r > o; o++)t = n[o], e += t * t; return this._magnitude = Math.sqrt(e) }, lunr.Vector.prototype.dot = function (t) { for (var e = this.elements, n = t.elements, r = e.length, o = 0, i = 0; r > i; i++)o += e[i] * n[i]; return o }, lunr.Vector.prototype.similarity = function (t) { return this.dot(t) / (this.magnitude() * t.magnitude()) }, lunr.Vector.prototype.toArray = function () { return this.elements }, lunr.SortedSet = function () { this.length = 0, this.elements = [] }, lunr.SortedSet.load = function (t) { var e = new this; return e.elements = t, e.length = t.length, e }, lunr.SortedSet.prototype.add = function () { Array.prototype.slice.call(arguments).forEach(function (t) { ~this.indexOf(t) || this.elements.splice(this.locationFor(t), 0, t) }, this), this.length = this.elements.length }, lunr.SortedSet.prototype.toArray = function () { return this.elements.slice() }, lunr.SortedSet.prototype.map = function (t, e) { return this.elements.map(t, e) }, lunr.SortedSet.prototype.forEach = function (t, e) { return this.elements.forEach(t, e) }, lunr.SortedSet.prototype.indexOf = function (t, e, n) { var e = e || 0, n = n || this.elements.length, r = n - e, o = e + Math.floor(r / 2), i = this.elements[o]; return 1 >= r ? i === t ? o : -1 : t > i ? this.indexOf(t, o, n) : i > t ? this.indexOf(t, e, o) : i === t ? o : void 0 }, lunr.SortedSet.prototype.locationFor = function (t, e, n) { var e = e || 0, n = n || this.elements.length, r = n - e, o = e + Math.floor(r / 2), i = this.elements[o]; if (1 >= r) { if (i > t) return o; if (t > i) return o + 1 } return t > i ? this.locationFor(t, o, n) : i > t ? this.locationFor(t, e, o) : void 0 }, lunr.SortedSet.prototype.intersect = function (t) { for (var e = new lunr.SortedSet, n = 0, r = 0, o = this.length, i = t.length, s = this.elements, l = t.elements; ;) { if (n > o - 1 || r > i - 1) break; s[n] !== l[r] ? s[n] < l[r] ? n++ : s[n] > l[r] && r++ : (e.add(s[n]), n++ , r++) } return e }, lunr.SortedSet.prototype.clone = function () { var t = new lunr.SortedSet; return t.elements = this.toArray(), t.length = t.elements.length, t }, lunr.SortedSet.prototype.union = function (t) { var e, n, r; return this.length >= t.length ? (e = this, n = t) : (e = t, n = this), r = e.clone(), r.add.apply(r, n.toArray()), r }, lunr.SortedSet.prototype.toJSON = function () { return this.toArray() }, lunr.Index = function () { this._fields = [], this._ref = "id", this.pipeline = new lunr.Pipeline, this.documentStore = new lunr.Store, this.tokenStore = new lunr.TokenStore, this.corpusTokens = new lunr.SortedSet, this.eventEmitter = new lunr.EventEmitter, this._idfCache = {}, this.on("add", "remove", "update", function () { this._idfCache = {} }.bind(this)) }, lunr.Index.prototype.on = function () { var t = Array.prototype.slice.call(arguments); return this.eventEmitter.addListener.apply(this.eventEmitter, t) }, lunr.Index.prototype.off = function (t, e) { return this.eventEmitter.removeListener(t, e) }, lunr.Index.load = function (t) { t.version !== lunr.version && lunr.utils.warn("version mismatch: current " + lunr.version + " importing " + t.version); var e = new this; return e._fields = t.fields, e._ref = t.ref, e.documentStore = lunr.Store.load(t.documentStore), e.tokenStore = lunr.TokenStore.load(t.tokenStore), e.corpusTokens = lunr.SortedSet.load(t.corpusTokens), e.pipeline = lunr.Pipeline.load(t.pipeline), e }, lunr.Index.prototype.field = function (t, e) { var e = e || {}, n = { name: t, boost: e.boost || 1 }; return this._fields.push(n), this }, lunr.Index.prototype.ref = function (t) { return this._ref = t, this }, lunr.Index.prototype.add = function (t, e) { var n = {}, r = new lunr.SortedSet, o = t[this._ref], e = void 0 === e ? !0 : e; this._fields.forEach(function (e) { var o = this.pipeline.run(lunr.tokenizer(t[e.name])); n[e.name] = o, lunr.SortedSet.prototype.add.apply(r, o) }, this), this.documentStore.set(o, r), lunr.SortedSet.prototype.add.apply(this.corpusTokens, r.toArray()); for (var i = 0; r.length > i; i++) { var s = r.elements[i], l = this._fields.reduce(function (t, e) { var r = n[e.name].length; if (!r) return t; var o = n[e.name].filter(function (t) { return t === s }).length; return t + o / r * e.boost }, 0); this.tokenStore.add(s, { ref: o, tf: l }) } e && this.eventEmitter.emit("add", t, this) }, lunr.Index.prototype.remove = function (t, e) { var n = t[this._ref], e = void 0 === e ? !0 : e; if (this.documentStore.has(n)) { var r = this.documentStore.get(n); this.documentStore.remove(n), r.forEach(function (t) { this.tokenStore.remove(t, n) }, this), e && this.eventEmitter.emit("remove", t, this) } }, lunr.Index.prototype.update = function (t, e) { var e = void 0 === e ? !0 : e; this.remove(t, !1), this.add(t, !1), e && this.eventEmitter.emit("update", t, this) }, lunr.Index.prototype.idf = function (t) { if (this._idfCache[t]) return this._idfCache[t]; var e = this.tokenStore.count(t), n = 1; return e > 0 && (n = 1 + Math.log(this.tokenStore.length / e)), this._idfCache[t] = n }, lunr.Index.prototype.search = function (t) { var e = this.pipeline.run(lunr.tokenizer(t)), n = lunr.utils.zeroFillArray(this.corpusTokens.length), r = [], o = this._fields.reduce(function (t, e) { return t + e.boost }, 0), i = e.some(function (t) { return this.tokenStore.has(t) }, this); if (!i) return []; e.forEach(function (t, e, i) { var s = 1 / i.length * this._fields.length * o, l = this, u = this.tokenStore.expand(t).reduce(function (e, r) { var o = l.corpusTokens.indexOf(r), i = l.idf(r), u = 1, a = new lunr.SortedSet; if (r !== t) { var h = Math.max(3, r.length - t.length); u = 1 / Math.log(h) } return o > -1 && (n[o] = s * i * u), Object.keys(l.tokenStore.get(r)).forEach(function (t) { a.add(t) }), e.union(a) }, new lunr.SortedSet); r.push(u) }, this); var s = r.reduce(function (t, e) { return t.intersect(e) }), l = new lunr.Vector(n); return s.map(function (t) { return { ref: t, score: l.similarity(this.documentVector(t)) } }, this).sort(function (t, e) { return e.score - t.score }) }, lunr.Index.prototype.documentVector = function (t) { for (var e = this.documentStore.get(t), n = e.length, r = lunr.utils.zeroFillArray(this.corpusTokens.length), o = 0; n > o; o++) { var i = e.elements[o], s = this.tokenStore.get(i)[t].tf, l = this.idf(i); r[this.corpusTokens.indexOf(i)] = s * l } return new lunr.Vector(r) }, lunr.Index.prototype.toJSON = function () { return { version: lunr.version, fields: this._fields, ref: this._ref, documentStore: this.documentStore.toJSON(), tokenStore: this.tokenStore.toJSON(), corpusTokens: this.corpusTokens.toJSON(), pipeline: this.pipeline.toJSON() } }, lunr.Store = function () { this.store = {}, this.length = 0 }, lunr.Store.load = function (t) { var e = new this; return e.length = t.length, e.store = Object.keys(t.store).reduce(function (e, n) { return e[n] = lunr.SortedSet.load(t.store[n]), e }, {}), e }, lunr.Store.prototype.set = function (t, e) { this.store[t] = e, this.length = Object.keys(this.store).length }, lunr.Store.prototype.get = function (t) { return this.store[t] }, lunr.Store.prototype.has = function (t) { return t in this.store }, lunr.Store.prototype.remove = function (t) { this.has(t) && (delete this.store[t], this.length--) }, lunr.Store.prototype.toJSON = function () { return { store: this.store, length: this.length } }, lunr.stemmer = function () { var t = { ational: "ate", tional: "tion", enci: "ence", anci: "ance", izer: "ize", bli: "ble", alli: "al", entli: "ent", eli: "e", ousli: "ous", ization: "ize", ation: "ate", ator: "ate", alism: "al", iveness: "ive", fulness: "ful", ousness: "ous", aliti: "al", iviti: "ive", biliti: "ble", logi: "log" }, e = { icate: "ic", ative: "", alize: "al", iciti: "ic", ical: "ic", ful: "", ness: "" }, n = "[^aeiou]", r = "[aeiouy]", o = n + "[^aeiouy]*", i = r + "[aeiou]*", s = "^(" + o + ")?" + i + o, l = "^(" + o + ")?" + i + o + "(" + i + ")?$", u = "^(" + o + ")?" + i + o + i + o, a = "^(" + o + ")?" + r; return function (n) { var i, h, c, p, f, d, v; if (3 > n.length) return n; if (c = n.substr(0, 1), "y" == c && (n = c.toUpperCase() + n.substr(1)), p = /^(.+?)(ss|i)es$/, f = /^(.+?)([^s])s$/, p.test(n) ? n = n.replace(p, "$1$2") : f.test(n) && (n = n.replace(f, "$1$2")), p = /^(.+?)eed$/, f = /^(.+?)(ed|ing)$/, p.test(n)) { var m = p.exec(n); p = RegExp(s), p.test(m[1]) && (p = /.$/, n = n.replace(p, "")) } else if (f.test(n)) { var m = f.exec(n); i = m[1], f = RegExp(a), f.test(i) && (n = i, f = /(at|bl|iz)$/, d = RegExp("([^aeiouylsz])\\1$"), v = RegExp("^" + o + r + "[^aeiouwxy]$"), f.test(n) ? n += "e" : d.test(n) ? (p = /.$/, n = n.replace(p, "")) : v.test(n) && (n += "e")) } if (p = /^(.+?)y$/, p.test(n)) { var m = p.exec(n); i = m[1], p = RegExp(a), p.test(i) && (n = i + "i") } if (p = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/, p.test(n)) { var m = p.exec(n); i = m[1], h = m[2], p = RegExp(s), p.test(i) && (n = i + t[h]) } if (p = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/, p.test(n)) { var m = p.exec(n); i = m[1], h = m[2], p = RegExp(s), p.test(i) && (n = i + e[h]) } if (p = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/, f = /^(.+?)(s|t)(ion)$/, p.test(n)) { var m = p.exec(n); i = m[1], p = RegExp(u), p.test(i) && (n = i) } else if (f.test(n)) { var m = f.exec(n); i = m[1] + m[2], f = RegExp(u), f.test(i) && (n = i) } if (p = /^(.+?)e$/, p.test(n)) { var m = p.exec(n); i = m[1], p = RegExp(u), f = RegExp(l), d = RegExp("^" + o + r + "[^aeiouwxy]$"), (p.test(i) || f.test(i) && !d.test(i)) && (n = i) } return p = /ll$/, f = RegExp(u), p.test(n) && f.test(n) && (p = /.$/, n = n.replace(p, "")), "y" == c && (n = c.toLowerCase() + n.substr(1)), n } }(), lunr.Pipeline.registerFunction(lunr.stemmer, "stemmer"), lunr.stopWordFilter = function (t) { return -1 === lunr.stopWordFilter.stopWords.indexOf(t) ? t : void 0 }, lunr.stopWordFilter.stopWords = new lunr.SortedSet, lunr.stopWordFilter.stopWords.length = 119, lunr.stopWordFilter.stopWords.elements = ["", "a", "able", "about", "across", "after", "all", "almost", "also", "am", "among", "an", "and", "any", "are", "as", "at", "be", "because", "been", "but", "by", "can", "cannot", "could", "dear", "did", "do", "does", "either", "else", "ever", "every", "for", "from", "get", "got", "had", "has", "have", "he", "her", "hers", "him", "his", "how", "however", "i", "if", "in", "into", "is", "it", "its", "just", "least", "let", "like", "likely", "may", "me", "might", "most", "must", "my", "neither", "no", "nor", "not", "of", "off", "often", "on", "only", "or", "other", "our", "own", "rather", "said", "say", "says", "she", "should", "since", "so", "some", "than", "that", "the", "their", "them", "then", "there", "these", "they", "this", "tis", "to", "too", "twas", "us", "wants", "was", "we", "were", "what", "when", "where", "which", "while", "who", "whom", "why", "will", "with", "would", "yet", "you", "your"], lunr.Pipeline.registerFunction(lunr.stopWordFilter, "stopWordFilter"), lunr.TokenStore = function () { this.root = { docs: {} }, this.length = 0 }, lunr.TokenStore.load = function (t) { var e = new this; return e.root = t.root, e.length = t.length, e }, lunr.TokenStore.prototype.add = function (t, e, n) { var n = n || this.root, r = t[0], o = t.slice(1); return r in n || (n[r] = { docs: {} }), 0 === o.length ? (n[r].docs[e.ref] = e, this.length += 1, void 0) : this.add(o, e, n[r]) }, lunr.TokenStore.prototype.has = function (t) { if (!t) return !1; for (var e = this.root, n = 0; t.length > n; n++) { if (!e[t[n]]) return !1; e = e[t[n]] } return !0 }, lunr.TokenStore.prototype.getNode = function (t) { if (!t) return {}; for (var e = this.root, n = 0; t.length > n; n++) { if (!e[t[n]]) return {}; e = e[t[n]] } return e }, lunr.TokenStore.prototype.get = function (t, e) { return this.getNode(t, e).docs || {} }, lunr.TokenStore.prototype.count = function (t, e) { return Object.keys(this.get(t, e)).length }, lunr.TokenStore.prototype.remove = function (t, e) { if (t) { for (var n = this.root, r = 0; t.length > r; r++) { if (!(t[r] in n)) return; n = n[t[r]] } delete n.docs[e] } }, lunr.TokenStore.prototype.expand = function (t, e) { var n = this.getNode(t), r = n.docs || {}, e = e || []; return Object.keys(r).length && e.push(t), Object.keys(n).forEach(function (n) { "docs" !== n && e.concat(this.expand(t + n, e)) }, this), e }, lunr.TokenStore.prototype.toJSON = function () { return { root: this.root, length: this.length } }; $.fn.ghostHunter = function (options) { var opts = $.extend({}, $.fn.ghostHunter.defaults, options); if (opts.results) { pluginMethods.init(this, opts); return pluginMethods } }; $.fn.ghostHunter.defaults = { results: false, rss: "/rss", onKeyUp: false, result_template: "<a href='{{link}}'><p><h2>{{title}}</h2><h4>{{pubDate}}</h4></p></a>", info_template: "<p>Number of posts found: {{amount}}</p>", displaySearchInfo: true, zeroResultsInfo: true, before: false, onComplete: false }; var pluginMethods = { isInit: false, init: function (target, opts) { var that = this; this.target = target; this.rss = opts.rss; this.results = opts.results; this.blogData = []; this.result_template = opts.result_template; this.info_template = opts.info_template; this.zeroResultsInfo = opts.zeroResultsInfo; this.displaySearchInfo = opts.displaySearchInfo; this.before = opts.before; this.onComplete = opts.onComplete; this.index = lunr(function () { this.field("title", { boost: 10 }); this.field("description"); this.field("link"); this.field("category"); this.field("pubDate"); this.ref("id") }); target.focus(function () { that.loadRSS() }); target.closest("form").submit(function (e) { e.preventDefault(); that.find(target.val()) }); if (opts.onKeyUp) { that.loadRSS(); target.keyup(function () { that.find(target.val()) }) } }, loadRSS: function () { if (this.isInit) return false; var index = this.index, rssURL = this.rss, blogData = this.blogData; $.get(rssURL, function (data) { var posts = $(data).find("item"); for (var i = 0; posts && i < posts.length; i++) { var post = posts.eq(i); var parsedData = { id: i + 1, title: post.find("title").text(), description: post.find("description").text(), category: post.find("category").text(), pubDate: post.find("pubDate").text(), link: post.find("link").text() }; index.add(parsedData); blogData.push(parsedData) } }); this.isInit = true }, find: function (value) { var searchResult = this.index.search(value); var results = $(this.results); var resultsData = []; results.empty(); if (this.before) { this.before() } if (this.zeroResultsInfo || searchResult.length > 0) { if (this.displaySearchInfo) results.append(this.format(this.info_template, { amount: searchResult.length })) } for (var i = 0; i < searchResult.length; i++) { var postData = this.blogData[searchResult[i].ref - 1]; results.append(this.format(this.result_template, postData)); resultsData.push(postData) } if (this.onComplete) { this.onComplete(resultsData) } }, clear: function () { $(this.results).empty(); this.target.val("") }, format: function (t, d) { return t.replace(/{{([^{}]*)}}/g, function (a, b) { var r = d[b]; return typeof r === "string" || typeof r === "number" ? r : a }) } } })(jQuery);

!function (e) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { var t; t = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, t.SimpleMDE = e() } }(function () {
    var e; return function t(e, n, r) { function i(a, l) { if (!n[a]) { if (!e[a]) { var s = "function" == typeof require && require; if (!l && s) return s(a, !0); if (o) return o(a, !0); var c = new Error("Cannot find module '" + a + "'"); throw c.code = "MODULE_NOT_FOUND", c } var u = n[a] = { exports: {} }; e[a][0].call(u.exports, function (t) { var n = e[a][1][t]; return i(n ? n : t) }, u, u.exports, t, e, n, r) } return n[a].exports } for (var o = "function" == typeof require && require, a = 0; a < r.length; a++)i(r[a]); return i }({
        1: [function (e, t, n) { "use strict"; function r() { for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0, n = e.length; n > t; ++t)s[t] = e[t], c[e.charCodeAt(t)] = t; c["-".charCodeAt(0)] = 62, c["_".charCodeAt(0)] = 63 } function i(e) { var t, n, r, i, o, a, l = e.length; if (l % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); o = "=" === e[l - 2] ? 2 : "=" === e[l - 1] ? 1 : 0, a = new u(3 * l / 4 - o), r = o > 0 ? l - 4 : l; var s = 0; for (t = 0, n = 0; r > t; t += 4, n += 3)i = c[e.charCodeAt(t)] << 18 | c[e.charCodeAt(t + 1)] << 12 | c[e.charCodeAt(t + 2)] << 6 | c[e.charCodeAt(t + 3)], a[s++] = i >> 16 & 255, a[s++] = i >> 8 & 255, a[s++] = 255 & i; return 2 === o ? (i = c[e.charCodeAt(t)] << 2 | c[e.charCodeAt(t + 1)] >> 4, a[s++] = 255 & i) : 1 === o && (i = c[e.charCodeAt(t)] << 10 | c[e.charCodeAt(t + 1)] << 4 | c[e.charCodeAt(t + 2)] >> 2, a[s++] = i >> 8 & 255, a[s++] = 255 & i), a } function o(e) { return s[e >> 18 & 63] + s[e >> 12 & 63] + s[e >> 6 & 63] + s[63 & e] } function a(e, t, n) { for (var r, i = [], a = t; n > a; a += 3)r = (e[a] << 16) + (e[a + 1] << 8) + e[a + 2], i.push(o(r)); return i.join("") } function l(e) { for (var t, n = e.length, r = n % 3, i = "", o = [], l = 16383, c = 0, u = n - r; u > c; c += l)o.push(a(e, c, c + l > u ? u : c + l)); return 1 === r ? (t = e[n - 1], i += s[t >> 2], i += s[t << 4 & 63], i += "==") : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], i += s[t >> 10], i += s[t >> 4 & 63], i += s[t << 2 & 63], i += "="), o.push(i), o.join("") } n.toByteArray = i, n.fromByteArray = l; var s = [], c = [], u = "undefined" != typeof Uint8Array ? Uint8Array : Array; r() }, {}], 2: [function (e, t, n) { }, {}], 3: [function (e, t, n) { (function (t) { "use strict"; function r() { try { var e = new Uint8Array(1); return e.foo = function () { return 42 }, 42 === e.foo() && "function" == typeof e.subarray && 0 === e.subarray(1, 1).byteLength } catch (t) { return !1 } } function i() { return a.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function o(e, t) { if (i() < t) throw new RangeError("Invalid typed array length"); return a.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t), e.__proto__ = a.prototype) : (null === e && (e = new a(t)), e.length = t), e } function a(e, t, n) { if (!(a.TYPED_ARRAY_SUPPORT || this instanceof a)) return new a(e, t, n); if ("number" == typeof e) { if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string"); return u(this, e) } return l(this, e, t, n) } function l(e, t, n, r) { if ("number" == typeof t) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? d(e, t, n, r) : "string" == typeof t ? f(e, t, n) : p(e, t) } function s(e) { if ("number" != typeof e) throw new TypeError('"size" argument must be a number') } function c(e, t, n, r) { return s(t), 0 >= t ? o(e, t) : void 0 !== n ? "string" == typeof r ? o(e, t).fill(n, r) : o(e, t).fill(n) : o(e, t) } function u(e, t) { if (s(t), e = o(e, 0 > t ? 0 : 0 | m(t)), !a.TYPED_ARRAY_SUPPORT) for (var n = 0; t > n; n++)e[n] = 0; return e } function f(e, t, n) { if ("string" == typeof n && "" !== n || (n = "utf8"), !a.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding'); var r = 0 | v(t, n); return e = o(e, r), e.write(t, n), e } function h(e, t) { var n = 0 | m(t.length); e = o(e, n); for (var r = 0; n > r; r += 1)e[r] = 255 & t[r]; return e } function d(e, t, n, r) { if (t.byteLength, 0 > n || t.byteLength < n) throw new RangeError("'offset' is out of bounds"); if (t.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds"); return t = void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r), a.TYPED_ARRAY_SUPPORT ? (e = t, e.__proto__ = a.prototype) : e = h(e, t), e } function p(e, t) { if (a.isBuffer(t)) { var n = 0 | m(t.length); return e = o(e, n), 0 === e.length ? e : (t.copy(e, 0, 0, n), e) } if (t) { if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t) return "number" != typeof t.length || K(t.length) ? o(e, 0) : h(e, t); if ("Buffer" === t.type && J(t.data)) return h(e, t.data) } throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") } function m(e) { if (e >= i()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i().toString(16) + " bytes"); return 0 | e } function g(e) { return +e != e && (e = 0), a.alloc(+e) } function v(e, t) { if (a.isBuffer(e)) return e.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength; "string" != typeof e && (e = "" + e); var n = e.length; if (0 === n) return 0; for (var r = !1; ;)switch (t) { case "ascii": case "binary": case "raw": case "raws": return n; case "utf8": case "utf-8": case void 0: return q(e).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return $(e).length; default: if (r) return q(e).length; t = ("" + t).toLowerCase(), r = !0 } } function y(e, t, n) { var r = !1; if ((void 0 === t || 0 > t) && (t = 0), t > this.length) return ""; if ((void 0 === n || n > this.length) && (n = this.length), 0 >= n) return ""; if (n >>>= 0, t >>>= 0, t >= n) return ""; for (e || (e = "utf8"); ;)switch (e) { case "hex": return I(this, t, n); case "utf8": case "utf-8": return N(this, t, n); case "ascii": return E(this, t, n); case "binary": return O(this, t, n); case "base64": return M(this, t, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return P(this, t, n); default: if (r) throw new TypeError("Unknown encoding: " + e); e = (e + "").toLowerCase(), r = !0 } } function x(e, t, n) { var r = e[t]; e[t] = e[n], e[n] = r } function b(e, t, n, r) { function i(e, t) { return 1 === o ? e[t] : e.readUInt16BE(t * o) } var o = 1, a = e.length, l = t.length; if (void 0 !== r && (r = String(r).toLowerCase(), "ucs2" === r || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) { if (e.length < 2 || t.length < 2) return -1; o = 2, a /= 2, l /= 2, n /= 2 } for (var s = -1, c = 0; a > n + c; c++)if (i(e, n + c) === i(t, -1 === s ? 0 : c - s)) { if (-1 === s && (s = c), c - s + 1 === l) return (n + s) * o } else -1 !== s && (c -= c - s), s = -1; return -1 } function w(e, t, n, r) { n = Number(n) || 0; var i = e.length - n; r ? (r = Number(r), r > i && (r = i)) : r = i; var o = t.length; if (o % 2 !== 0) throw new Error("Invalid hex string"); r > o / 2 && (r = o / 2); for (var a = 0; r > a; a++) { var l = parseInt(t.substr(2 * a, 2), 16); if (isNaN(l)) return a; e[n + a] = l } return a } function k(e, t, n, r) { return V(q(t, e.length - n), e, n, r) } function S(e, t, n, r) { return V(G(t), e, n, r) } function C(e, t, n, r) { return S(e, t, n, r) } function L(e, t, n, r) { return V($(t), e, n, r) } function T(e, t, n, r) { return V(Y(t, e.length - n), e, n, r) } function M(e, t, n) { return 0 === t && n === e.length ? X.fromByteArray(e) : X.fromByteArray(e.slice(t, n)) } function N(e, t, n) { n = Math.min(e.length, n); for (var r = [], i = t; n > i;) { var o = e[i], a = null, l = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1; if (n >= i + l) { var s, c, u, f; switch (l) { case 1: 128 > o && (a = o); break; case 2: s = e[i + 1], 128 === (192 & s) && (f = (31 & o) << 6 | 63 & s, f > 127 && (a = f)); break; case 3: s = e[i + 1], c = e[i + 2], 128 === (192 & s) && 128 === (192 & c) && (f = (15 & o) << 12 | (63 & s) << 6 | 63 & c, f > 2047 && (55296 > f || f > 57343) && (a = f)); break; case 4: s = e[i + 1], c = e[i + 2], u = e[i + 3], 128 === (192 & s) && 128 === (192 & c) && 128 === (192 & u) && (f = (15 & o) << 18 | (63 & s) << 12 | (63 & c) << 6 | 63 & u, f > 65535 && 1114112 > f && (a = f)) } } null === a ? (a = 65533, l = 1) : a > 65535 && (a -= 65536, r.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), r.push(a), i += l } return A(r) } function A(e) { var t = e.length; if (Q >= t) return String.fromCharCode.apply(String, e); for (var n = "", r = 0; t > r;)n += String.fromCharCode.apply(String, e.slice(r, r += Q)); return n } function E(e, t, n) { var r = ""; n = Math.min(e.length, n); for (var i = t; n > i; i++)r += String.fromCharCode(127 & e[i]); return r } function O(e, t, n) { var r = ""; n = Math.min(e.length, n); for (var i = t; n > i; i++)r += String.fromCharCode(e[i]); return r } function I(e, t, n) { var r = e.length; (!t || 0 > t) && (t = 0), (!n || 0 > n || n > r) && (n = r); for (var i = "", o = t; n > o; o++)i += U(e[o]); return i } function P(e, t, n) { for (var r = e.slice(t, n), i = "", o = 0; o < r.length; o += 2)i += String.fromCharCode(r[o] + 256 * r[o + 1]); return i } function R(e, t, n) { if (e % 1 !== 0 || 0 > e) throw new RangeError("offset is not uint"); if (e + t > n) throw new RangeError("Trying to access beyond buffer length") } function D(e, t, n, r, i, o) { if (!a.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > i || o > t) throw new RangeError('"value" argument is out of bounds'); if (n + r > e.length) throw new RangeError("Index out of range") } function H(e, t, n, r) { 0 > t && (t = 65535 + t + 1); for (var i = 0, o = Math.min(e.length - n, 2); o > i; i++)e[n + i] = (t & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i) } function W(e, t, n, r) { 0 > t && (t = 4294967295 + t + 1); for (var i = 0, o = Math.min(e.length - n, 4); o > i; i++)e[n + i] = t >>> 8 * (r ? i : 3 - i) & 255 } function B(e, t, n, r, i, o) { if (n + r > e.length) throw new RangeError("Index out of range"); if (0 > n) throw new RangeError("Index out of range") } function _(e, t, n, r, i) { return i || B(e, t, n, 4, 3.4028234663852886e38, -3.4028234663852886e38), Z.write(e, t, n, r, 23, 4), n + 4 } function F(e, t, n, r, i) { return i || B(e, t, n, 8, 1.7976931348623157e308, -1.7976931348623157e308), Z.write(e, t, n, r, 52, 8), n + 8 } function z(e) { if (e = j(e).replace(ee, ""), e.length < 2) return ""; for (; e.length % 4 !== 0;)e += "="; return e } function j(e) { return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "") } function U(e) { return 16 > e ? "0" + e.toString(16) : e.toString(16) } function q(e, t) { t = t || 1 / 0; for (var n, r = e.length, i = null, o = [], a = 0; r > a; a++) { if (n = e.charCodeAt(a), n > 55295 && 57344 > n) { if (!i) { if (n > 56319) { (t -= 3) > -1 && o.push(239, 191, 189); continue } if (a + 1 === r) { (t -= 3) > -1 && o.push(239, 191, 189); continue } i = n; continue } if (56320 > n) { (t -= 3) > -1 && o.push(239, 191, 189), i = n; continue } n = (i - 55296 << 10 | n - 56320) + 65536 } else i && (t -= 3) > -1 && o.push(239, 191, 189); if (i = null, 128 > n) { if ((t -= 1) < 0) break; o.push(n) } else if (2048 > n) { if ((t -= 2) < 0) break; o.push(n >> 6 | 192, 63 & n | 128) } else if (65536 > n) { if ((t -= 3) < 0) break; o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) } else { if (!(1114112 > n)) throw new Error("Invalid code point"); if ((t -= 4) < 0) break; o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128) } } return o } function G(e) { for (var t = [], n = 0; n < e.length; n++)t.push(255 & e.charCodeAt(n)); return t } function Y(e, t) { for (var n, r, i, o = [], a = 0; a < e.length && !((t -= 2) < 0); a++)n = e.charCodeAt(a), r = n >> 8, i = n % 256, o.push(i), o.push(r); return o } function $(e) { return X.toByteArray(z(e)) } function V(e, t, n, r) { for (var i = 0; r > i && !(i + n >= t.length || i >= e.length); i++)t[i + n] = e[i]; return i } function K(e) { return e !== e } var X = e("base64-js"), Z = e("ieee754"), J = e("isarray"); n.Buffer = a, n.SlowBuffer = g, n.INSPECT_MAX_BYTES = 50, a.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : r(), n.kMaxLength = i(), a.poolSize = 8192, a._augment = function (e) { return e.__proto__ = a.prototype, e }, a.from = function (e, t, n) { return l(null, e, t, n) }, a.TYPED_ARRAY_SUPPORT && (a.prototype.__proto__ = Uint8Array.prototype, a.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && a[Symbol.species] === a && Object.defineProperty(a, Symbol.species, { value: null, configurable: !0 })), a.alloc = function (e, t, n) { return c(null, e, t, n) }, a.allocUnsafe = function (e) { return u(null, e) }, a.allocUnsafeSlow = function (e) { return u(null, e) }, a.isBuffer = function (e) { return !(null == e || !e._isBuffer) }, a.compare = function (e, t) { if (!a.isBuffer(e) || !a.isBuffer(t)) throw new TypeError("Arguments must be Buffers"); if (e === t) return 0; for (var n = e.length, r = t.length, i = 0, o = Math.min(n, r); o > i; ++i)if (e[i] !== t[i]) { n = e[i], r = t[i]; break } return r > n ? -1 : n > r ? 1 : 0 }, a.isEncoding = function (e) { switch (String(e).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "binary": case "base64": case "raw": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, a.concat = function (e, t) { if (!J(e)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === e.length) return a.alloc(0); var n; if (void 0 === t) for (t = 0, n = 0; n < e.length; n++)t += e[n].length; var r = a.allocUnsafe(t), i = 0; for (n = 0; n < e.length; n++) { var o = e[n]; if (!a.isBuffer(o)) throw new TypeError('"list" argument must be an Array of Buffers'); o.copy(r, i), i += o.length } return r }, a.byteLength = v, a.prototype._isBuffer = !0, a.prototype.swap16 = function () { var e = this.length; if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var t = 0; e > t; t += 2)x(this, t, t + 1); return this }, a.prototype.swap32 = function () { var e = this.length; if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var t = 0; e > t; t += 4)x(this, t, t + 3), x(this, t + 1, t + 2); return this }, a.prototype.toString = function () { var e = 0 | this.length; return 0 === e ? "" : 0 === arguments.length ? N(this, 0, e) : y.apply(this, arguments) }, a.prototype.equals = function (e) { if (!a.isBuffer(e)) throw new TypeError("Argument must be a Buffer"); return this === e ? !0 : 0 === a.compare(this, e) }, a.prototype.inspect = function () { var e = "", t = n.INSPECT_MAX_BYTES; return this.length > 0 && (e = this.toString("hex", 0, t).match(/.{2}/g).join(" "), this.length > t && (e += " ... ")), "<Buffer " + e + ">" }, a.prototype.compare = function (e, t, n, r, i) { if (!a.isBuffer(e)) throw new TypeError("Argument must be a Buffer"); if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), 0 > t || n > e.length || 0 > r || i > this.length) throw new RangeError("out of range index"); if (r >= i && t >= n) return 0; if (r >= i) return -1; if (t >= n) return 1; if (t >>>= 0, n >>>= 0, r >>>= 0, i >>>= 0, this === e) return 0; for (var o = i - r, l = n - t, s = Math.min(o, l), c = this.slice(r, i), u = e.slice(t, n), f = 0; s > f; ++f)if (c[f] !== u[f]) { o = c[f], l = u[f]; break } return l > o ? -1 : o > l ? 1 : 0 }, a.prototype.indexOf = function (e, t, n) { if ("string" == typeof t ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : -2147483648 > t && (t = -2147483648), t >>= 0, 0 === this.length) return -1; if (t >= this.length) return -1; if (0 > t && (t = Math.max(this.length + t, 0)), "string" == typeof e && (e = a.from(e, n)), a.isBuffer(e)) return 0 === e.length ? -1 : b(this, e, t, n); if ("number" == typeof e) return a.TYPED_ARRAY_SUPPORT && "function" === Uint8Array.prototype.indexOf ? Uint8Array.prototype.indexOf.call(this, e, t) : b(this, [e], t, n); throw new TypeError("val must be string, number or Buffer") }, a.prototype.includes = function (e, t, n) { return -1 !== this.indexOf(e, t, n) }, a.prototype.write = function (e, t, n, r) { if (void 0 === t) r = "utf8", n = this.length, t = 0; else if (void 0 === n && "string" == typeof t) r = t, n = this.length, t = 0; else { if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); t = 0 | t, isFinite(n) ? (n = 0 | n, void 0 === r && (r = "utf8")) : (r = n, n = void 0) } var i = this.length - t; if ((void 0 === n || n > i) && (n = i), e.length > 0 && (0 > n || 0 > t) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); for (var o = !1; ;)switch (r) { case "hex": return w(this, e, t, n); case "utf8": case "utf-8": return k(this, e, t, n); case "ascii": return S(this, e, t, n); case "binary": return C(this, e, t, n); case "base64": return L(this, e, t, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return T(this, e, t, n); default: if (o) throw new TypeError("Unknown encoding: " + r); r = ("" + r).toLowerCase(), o = !0 } }, a.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var Q = 4096; a.prototype.slice = function (e, t) { var n = this.length; e = ~~e, t = void 0 === t ? n : ~~t, 0 > e ? (e += n, 0 > e && (e = 0)) : e > n && (e = n), 0 > t ? (t += n, 0 > t && (t = 0)) : t > n && (t = n), e > t && (t = e); var r; if (a.TYPED_ARRAY_SUPPORT) r = this.subarray(e, t), r.__proto__ = a.prototype; else { var i = t - e; r = new a(i, void 0); for (var o = 0; i > o; o++)r[o] = this[o + e] } return r }, a.prototype.readUIntLE = function (e, t, n) { e = 0 | e, t = 0 | t, n || R(e, t, this.length); for (var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);)r += this[e + o] * i; return r }, a.prototype.readUIntBE = function (e, t, n) { e = 0 | e, t = 0 | t, n || R(e, t, this.length); for (var r = this[e + --t], i = 1; t > 0 && (i *= 256);)r += this[e + --t] * i; return r }, a.prototype.readUInt8 = function (e, t) { return t || R(e, 1, this.length), this[e] }, a.prototype.readUInt16LE = function (e, t) { return t || R(e, 2, this.length), this[e] | this[e + 1] << 8 }, a.prototype.readUInt16BE = function (e, t) { return t || R(e, 2, this.length), this[e] << 8 | this[e + 1] }, a.prototype.readUInt32LE = function (e, t) { return t || R(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3] }, a.prototype.readUInt32BE = function (e, t) { return t || R(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]) }, a.prototype.readIntLE = function (e, t, n) { e = 0 | e, t = 0 | t, n || R(e, t, this.length); for (var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);)r += this[e + o] * i; return i *= 128, r >= i && (r -= Math.pow(2, 8 * t)), r }, a.prototype.readIntBE = function (e, t, n) { e = 0 | e, t = 0 | t, n || R(e, t, this.length); for (var r = t, i = 1, o = this[e + --r]; r > 0 && (i *= 256);)o += this[e + --r] * i; return i *= 128, o >= i && (o -= Math.pow(2, 8 * t)), o }, a.prototype.readInt8 = function (e, t) { return t || R(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e] }, a.prototype.readInt16LE = function (e, t) { t || R(e, 2, this.length); var n = this[e] | this[e + 1] << 8; return 32768 & n ? 4294901760 | n : n }, a.prototype.readInt16BE = function (e, t) { t || R(e, 2, this.length); var n = this[e + 1] | this[e] << 8; return 32768 & n ? 4294901760 | n : n }, a.prototype.readInt32LE = function (e, t) { return t || R(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24 }, a.prototype.readInt32BE = function (e, t) { return t || R(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3] }, a.prototype.readFloatLE = function (e, t) { return t || R(e, 4, this.length), Z.read(this, e, !0, 23, 4) }, a.prototype.readFloatBE = function (e, t) { return t || R(e, 4, this.length), Z.read(this, e, !1, 23, 4) }, a.prototype.readDoubleLE = function (e, t) { return t || R(e, 8, this.length), Z.read(this, e, !0, 52, 8) }, a.prototype.readDoubleBE = function (e, t) { return t || R(e, 8, this.length), Z.read(this, e, !1, 52, 8) }, a.prototype.writeUIntLE = function (e, t, n, r) { if (e = +e, t = 0 | t, n = 0 | n, !r) { var i = Math.pow(2, 8 * n) - 1; D(this, e, t, n, i, 0) } var o = 1, a = 0; for (this[t] = 255 & e; ++a < n && (o *= 256);)this[t + a] = e / o & 255; return t + n }, a.prototype.writeUIntBE = function (e, t, n, r) { if (e = +e, t = 0 | t, n = 0 | n, !r) { var i = Math.pow(2, 8 * n) - 1; D(this, e, t, n, i, 0) } var o = n - 1, a = 1; for (this[t + o] = 255 & e; --o >= 0 && (a *= 256);)this[t + o] = e / a & 255; return t + n }, a.prototype.writeUInt8 = function (e, t, n) { return e = +e, t = 0 | t, n || D(this, e, t, 1, 255, 0), a.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1 }, a.prototype.writeUInt16LE = function (e, t, n) { return e = +e, t = 0 | t, n || D(this, e, t, 2, 65535, 0), a.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : H(this, e, t, !0), t + 2 }, a.prototype.writeUInt16BE = function (e, t, n) { return e = +e, t = 0 | t, n || D(this, e, t, 2, 65535, 0), a.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : H(this, e, t, !1), t + 2 }, a.prototype.writeUInt32LE = function (e, t, n) { return e = +e, t = 0 | t, n || D(this, e, t, 4, 4294967295, 0), a.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : W(this, e, t, !0), t + 4 }, a.prototype.writeUInt32BE = function (e, t, n) { return e = +e, t = 0 | t, n || D(this, e, t, 4, 4294967295, 0), a.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : W(this, e, t, !1), t + 4 }, a.prototype.writeIntLE = function (e, t, n, r) { if (e = +e, t = 0 | t, !r) { var i = Math.pow(2, 8 * n - 1); D(this, e, t, n, i - 1, -i) } var o = 0, a = 1, l = 0; for (this[t] = 255 & e; ++o < n && (a *= 256);)0 > e && 0 === l && 0 !== this[t + o - 1] && (l = 1), this[t + o] = (e / a >> 0) - l & 255; return t + n }, a.prototype.writeIntBE = function (e, t, n, r) { if (e = +e, t = 0 | t, !r) { var i = Math.pow(2, 8 * n - 1); D(this, e, t, n, i - 1, -i) } var o = n - 1, a = 1, l = 0; for (this[t + o] = 255 & e; --o >= 0 && (a *= 256);)0 > e && 0 === l && 0 !== this[t + o + 1] && (l = 1), this[t + o] = (e / a >> 0) - l & 255; return t + n }, a.prototype.writeInt8 = function (e, t, n) { return e = +e, t = 0 | t, n || D(this, e, t, 1, 127, -128), a.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), 0 > e && (e = 255 + e + 1), this[t] = 255 & e, t + 1 }, a.prototype.writeInt16LE = function (e, t, n) { return e = +e, t = 0 | t, n || D(this, e, t, 2, 32767, -32768), a.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : H(this, e, t, !0), t + 2 }, a.prototype.writeInt16BE = function (e, t, n) { return e = +e, t = 0 | t, n || D(this, e, t, 2, 32767, -32768), a.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : H(this, e, t, !1), t + 2 }, a.prototype.writeInt32LE = function (e, t, n) { return e = +e, t = 0 | t, n || D(this, e, t, 4, 2147483647, -2147483648), a.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : W(this, e, t, !0), t + 4 }, a.prototype.writeInt32BE = function (e, t, n) { return e = +e, t = 0 | t, n || D(this, e, t, 4, 2147483647, -2147483648), 0 > e && (e = 4294967295 + e + 1), a.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : W(this, e, t, !1), t + 4 }, a.prototype.writeFloatLE = function (e, t, n) { return _(this, e, t, !0, n) }, a.prototype.writeFloatBE = function (e, t, n) { return _(this, e, t, !1, n) }, a.prototype.writeDoubleLE = function (e, t, n) { return F(this, e, t, !0, n) }, a.prototype.writeDoubleBE = function (e, t, n) { return F(this, e, t, !1, n) }, a.prototype.copy = function (e, t, n, r) { if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && n > r && (r = n), r === n) return 0; if (0 === e.length || 0 === this.length) return 0; if (0 > t) throw new RangeError("targetStart out of bounds"); if (0 > n || n >= this.length) throw new RangeError("sourceStart out of bounds"); if (0 > r) throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n); var i, o = r - n; if (this === e && t > n && r > t) for (i = o - 1; i >= 0; i--)e[i + t] = this[i + n]; else if (1e3 > o || !a.TYPED_ARRAY_SUPPORT) for (i = 0; o > i; i++)e[i + t] = this[i + n]; else Uint8Array.prototype.set.call(e, this.subarray(n, n + o), t); return o }, a.prototype.fill = function (e, t, n, r) { if ("string" == typeof e) { if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === e.length) { var i = e.charCodeAt(0); 256 > i && (e = i) } if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string"); if ("string" == typeof r && !a.isEncoding(r)) throw new TypeError("Unknown encoding: " + r) } else "number" == typeof e && (e = 255 & e); if (0 > t || this.length < t || this.length < n) throw new RangeError("Out of range index"); if (t >= n) return this; t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0); var o; if ("number" == typeof e) for (o = t; n > o; o++)this[o] = e; else { var l = a.isBuffer(e) ? e : q(new a(e, r).toString()), s = l.length; for (o = 0; n - t > o; o++)this[o + t] = l[o % s] } return this }; var ee = /[^+\/0-9A-Za-z-_]/g }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "base64-js": 1, ieee754: 15, isarray: 16 }], 4: [function (e, t, n) { "use strict"; function r(e) { return e = e || {}, "function" != typeof e.codeMirrorInstance || "function" != typeof e.codeMirrorInstance.defineMode ? void console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`") : (String.prototype.includes || (String.prototype.includes = function () { return -1 !== String.prototype.indexOf.apply(this, arguments) }), void e.codeMirrorInstance.defineMode("spell-checker", function (t) { if (!r.aff_loading) { r.aff_loading = !0; var n = new XMLHttpRequest; n.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", !0), n.onload = function () { 4 === n.readyState && 200 === n.status && (r.aff_data = n.responseText, r.num_loaded++ , 2 == r.num_loaded && (r.typo = new i("en_US", r.aff_data, r.dic_data, { platform: "any" }))) }, n.send(null) } if (!r.dic_loading) { r.dic_loading = !0; var o = new XMLHttpRequest; o.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", !0), o.onload = function () { 4 === o.readyState && 200 === o.status && (r.dic_data = o.responseText, r.num_loaded++ , 2 == r.num_loaded && (r.typo = new i("en_US", r.aff_data, r.dic_data, { platform: "any" }))) }, o.send(null) } var a = '!"#$%&()*+,-./:;<=>?@[\\]^_`{|}~ ', l = { token: function (e) { var t = e.peek(), n = ""; if (a.includes(t)) return e.next(), null; for (; null != (t = e.peek()) && !a.includes(t);)n += t, e.next(); return r.typo && !r.typo.check(n) ? "spell-error" : null } }, s = e.codeMirrorInstance.getMode(t, t.backdrop || "text/plain"); return e.codeMirrorInstance.overlayMode(s, l, !0) })) } var i = e("typo-js"); r.num_loaded = 0, r.aff_loading = !1, r.dic_loading = !1, r.aff_data = "", r.dic_data = "", r.typo, t.exports = r }, { "typo-js": 18 }], 5: [function (t, n, r) { !function (i) { "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror) }(function (e) { "use strict"; function t(e) { var t = e.getWrapperElement(); e.state.fullScreenRestore = { scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset, width: t.style.width, height: t.style.height }, t.style.width = "", t.style.height = "auto", t.className += " CodeMirror-fullscreen", document.documentElement.style.overflow = "hidden", e.refresh() } function n(e) { var t = e.getWrapperElement(); t.className = t.className.replace(/\s*CodeMirror-fullscreen\b/, ""), document.documentElement.style.overflow = ""; var n = e.state.fullScreenRestore; t.style.width = n.width, t.style.height = n.height, window.scrollTo(n.scrollLeft, n.scrollTop), e.refresh() } e.defineOption("fullScreen", !1, function (r, i, o) { o == e.Init && (o = !1), !o != !i && (i ? t(r) : n(r)) }) }) }, { "../../lib/codemirror": 10 }], 6: [function (t, n, r) { !function (i) { "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror) }(function (e) { function t(e) { e.state.placeholder && (e.state.placeholder.parentNode.removeChild(e.state.placeholder), e.state.placeholder = null) } function n(e) { t(e); var n = e.state.placeholder = document.createElement("pre"); n.style.cssText = "height: 0; overflow: visible", n.className = "CodeMirror-placeholder"; var r = e.getOption("placeholder"); "string" == typeof r && (r = document.createTextNode(r)), n.appendChild(r), e.display.lineSpace.insertBefore(n, e.display.lineSpace.firstChild) } function r(e) { o(e) && n(e) } function i(e) { var r = e.getWrapperElement(), i = o(e); r.className = r.className.replace(" CodeMirror-empty", "") + (i ? " CodeMirror-empty" : ""), i ? n(e) : t(e) } function o(e) { return 1 === e.lineCount() && "" === e.getLine(0) } e.defineOption("placeholder", "", function (n, o, a) { var l = a && a != e.Init; if (o && !l) n.on("blur", r), n.on("change", i), n.on("swapDoc", i), i(n); else if (!o && l) { n.off("blur", r), n.off("change", i), n.off("swapDoc", i), t(n); var s = n.getWrapperElement(); s.className = s.className.replace(" CodeMirror-empty", "") } o && !n.hasFocus() && r(n) }) }) }, { "../../lib/codemirror": 10 }], 7: [function (t, n, r) { !function (i) { "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror) }(function (e) { "use strict"; var t = /^(\s*)(>[> ]*|[*+-]\s|(\d+)([.)]))(\s*)/, n = /^(\s*)(>[> ]*|[*+-]|(\d+)[.)])(\s*)$/, r = /[*+-]\s/; e.commands.newlineAndIndentContinueMarkdownList = function (i) { if (i.getOption("disableInput")) return e.Pass; for (var o = i.listSelections(), a = [], l = 0; l < o.length; l++) { var s = o[l].head, c = i.getStateAfter(s.line), u = c.list !== !1, f = 0 !== c.quote, h = i.getLine(s.line), d = t.exec(h); if (!o[l].empty() || !u && !f || !d) return void i.execCommand("newlineAndIndent"); if (n.test(h)) i.replaceRange("", { line: s.line, ch: 0 }, { line: s.line, ch: s.ch + 1 }), a[l] = "\n"; else { var p = d[1], m = d[5], g = r.test(d[2]) || d[2].indexOf(">") >= 0 ? d[2] : parseInt(d[3], 10) + 1 + d[4]; a[l] = "\n" + p + g + m } } i.replaceSelections(a) } }) }, { "../../lib/codemirror": 10 }], 8: [function (t, n, r) { !function (i) { "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror) }(function (e) { "use strict"; e.overlayMode = function (t, n, r) { return { startState: function () { return { base: e.startState(t), overlay: e.startState(n), basePos: 0, baseCur: null, overlayPos: 0, overlayCur: null, streamSeen: null } }, copyState: function (r) { return { base: e.copyState(t, r.base), overlay: e.copyState(n, r.overlay), basePos: r.basePos, baseCur: null, overlayPos: r.overlayPos, overlayCur: null } }, token: function (e, i) { return (e != i.streamSeen || Math.min(i.basePos, i.overlayPos) < e.start) && (i.streamSeen = e, i.basePos = i.overlayPos = e.start), e.start == i.basePos && (i.baseCur = t.token(e, i.base), i.basePos = e.pos), e.start == i.overlayPos && (e.pos = e.start, i.overlayCur = n.token(e, i.overlay), i.overlayPos = e.pos), e.pos = Math.min(i.basePos, i.overlayPos), null == i.overlayCur ? i.baseCur : null != i.baseCur && i.overlay.combineTokens || r && null == i.overlay.combineTokens ? i.baseCur + " " + i.overlayCur : i.overlayCur }, indent: t.indent && function (e, n) { return t.indent(e.base, n) }, electricChars: t.electricChars, innerMode: function (e) { return { state: e.base, mode: t } }, blankLine: function (e) { t.blankLine && t.blankLine(e.base), n.blankLine && n.blankLine(e.overlay) } } } }) }, { "../../lib/codemirror": 10 }], 9: [function (t, n, r) { !function (i) { "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror) }(function (e) { "use strict"; function t(e) { e.operation(function () { a(e) }) } function n(e) { e.state.markedSelection.length && e.operation(function () { i(e) }) } function r(e, t, n, r) { if (0 != c(t, n)) for (var i = e.state.markedSelection, o = e.state.markedSelectionStyle, a = t.line; ;) { var u = a == t.line ? t : s(a, 0), f = a + l, h = f >= n.line, d = h ? n : s(f, 0), p = e.markText(u, d, { className: o }); if (null == r ? i.push(p) : i.splice(r++, 0, p), h) break; a = f } } function i(e) { for (var t = e.state.markedSelection, n = 0; n < t.length; ++n)t[n].clear(); t.length = 0 } function o(e) { i(e); for (var t = e.listSelections(), n = 0; n < t.length; n++)r(e, t[n].from(), t[n].to()) } function a(e) { if (!e.somethingSelected()) return i(e); if (e.listSelections().length > 1) return o(e); var t = e.getCursor("start"), n = e.getCursor("end"), a = e.state.markedSelection; if (!a.length) return r(e, t, n); var s = a[0].find(), u = a[a.length - 1].find(); if (!s || !u || n.line - t.line < l || c(t, u.to) >= 0 || c(n, s.from) <= 0) return o(e); for (; c(t, s.from) > 0;)a.shift().clear(), s = a[0].find(); for (c(t, s.from) < 0 && (s.to.line - t.line < l ? (a.shift().clear(), r(e, t, s.to, 0)) : r(e, t, s.from, 0)); c(n, u.to) < 0;)a.pop().clear(), u = a[a.length - 1].find(); c(n, u.to) > 0 && (n.line - u.from.line < l ? (a.pop().clear(), r(e, u.from, n)) : r(e, u.to, n)) } e.defineOption("styleSelectedText", !1, function (r, a, l) { var s = l && l != e.Init; a && !s ? (r.state.markedSelection = [], r.state.markedSelectionStyle = "string" == typeof a ? a : "CodeMirror-selectedtext", o(r), r.on("cursorActivity", t), r.on("change", n)) : !a && s && (r.off("cursorActivity", t), r.off("change", n), i(r), r.state.markedSelection = r.state.markedSelectionStyle = null) }); var l = 8, s = e.Pos, c = e.cmpPos }) }, { "../../lib/codemirror": 10 }], 10: [function (t, n, r) {
            !function (t) { if ("object" == typeof r && "object" == typeof n) n.exports = t(); else { if ("function" == typeof e && e.amd) return e([], t); (this || window).CodeMirror = t() } }(function () {
                "use strict"; function e(n, r) { if (!(this instanceof e)) return new e(n, r); this.options = r = r ? Wi(r) : {}, Wi(ea, r, !1), d(r); var i = r.value; "string" == typeof i && (i = new Ca(i, r.mode, null, r.lineSeparator)), this.doc = i; var o = new e.inputStyles[r.inputStyle](this), a = this.display = new t(n, i, o); a.wrapper.CodeMirror = this, c(this), l(this), r.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), r.autofocus && !Ao && a.input.focus(), v(this), this.state = { keyMaps: [], overlays: [], modeGen: 0, overwrite: !1, delayingBlurEvent: !1, focused: !1, suppressEdits: !1, pasteIncoming: !1, cutIncoming: !1, selectingText: !1, draggingText: !1, highlight: new Ei, keySeq: null, specialChars: null }; var s = this; xo && 11 > bo && setTimeout(function () { s.display.input.reset(!0) }, 20), jt(this), Ki(), bt(this), this.curOp.forceUpdate = !0, Xr(this, i), r.autofocus && !Ao || s.hasFocus() ? setTimeout(Bi(vn, this), 20) : yn(this); for (var u in ta) ta.hasOwnProperty(u) && ta[u](this, r[u], na); k(this), r.finishInit && r.finishInit(this); for (var f = 0; f < aa.length; ++f)aa[f](this); kt(this), wo && r.lineWrapping && "optimizelegibility" == getComputedStyle(a.lineDiv).textRendering && (a.lineDiv.style.textRendering = "auto") } function t(e, t, n) {
                    var r = this; this.input = n, r.scrollbarFiller = ji("div", null, "CodeMirror-scrollbar-filler"), r.scrollbarFiller.setAttribute("cm-not-content", "true"), r.gutterFiller = ji("div", null, "CodeMirror-gutter-filler"), r.gutterFiller.setAttribute("cm-not-content", "true"), r.lineDiv = ji("div", null, "CodeMirror-code"), r.selectionDiv = ji("div", null, null, "position: relative; z-index: 1"), r.cursorDiv = ji("div", null, "CodeMirror-cursors"), r.measure = ji("div", null, "CodeMirror-measure"), r.lineMeasure = ji("div", null, "CodeMirror-measure"), r.lineSpace = ji("div", [r.measure, r.lineMeasure, r.selectionDiv, r.cursorDiv, r.lineDiv], null, "position: relative; outline: none"), r.mover = ji("div", [ji("div", [r.lineSpace], "CodeMirror-lines")], null, "position: relative"), r.sizer = ji("div", [r.mover], "CodeMirror-sizer"), r.sizerWidth = null, r.heightForcer = ji("div", null, null, "position: absolute; height: " + Da + "px; width: 1px;"), r.gutters = ji("div", null, "CodeMirror-gutters"), r.lineGutter = null, r.scroller = ji("div", [r.sizer, r.heightForcer, r.gutters], "CodeMirror-scroll"), r.scroller.setAttribute("tabIndex", "-1"), r.wrapper = ji("div", [r.scrollbarFiller, r.gutterFiller, r.scroller], "CodeMirror"), xo && 8 > bo && (r.gutters.style.zIndex = -1, r.scroller.style.paddingRight = 0), wo || go && Ao || (r.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(r.wrapper) : e(r.wrapper)), r.viewFrom = r.viewTo = t.first, r.reportedViewFrom = r.reportedViewTo = t.first, r.view = [], r.renderedView = null, r.externalMeasured = null, r.viewOffset = 0, r.lastWrapHeight = r.lastWrapWidth = 0, r.updateLineNumbers = null, r.nativeBarWidth = r.barHeight = r.barWidth = 0, r.scrollbarsClipped = !1, r.lineNumWidth = r.lineNumInnerWidth = r.lineNumChars = null, r.alignWidgets = !1, r.cachedCharWidth = r.cachedTextHeight = r.cachedPaddingH = null,
                        r.maxLine = null, r.maxLineLength = 0, r.maxLineChanged = !1, r.wheelDX = r.wheelDY = r.wheelStartX = r.wheelStartY = null, r.shift = !1, r.selForContextMenu = null, r.activeTouch = null, n.init(r)
                } function n(t) { t.doc.mode = e.getMode(t.options, t.doc.modeOption), r(t) } function r(e) { e.doc.iter(function (e) { e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null) }), e.doc.frontier = e.doc.first, _e(e, 100), e.state.modeGen++ , e.curOp && Dt(e) } function i(e) { e.options.lineWrapping ? (Ja(e.display.wrapper, "CodeMirror-wrap"), e.display.sizer.style.minWidth = "", e.display.sizerWidth = null) : (Za(e.display.wrapper, "CodeMirror-wrap"), h(e)), a(e), Dt(e), lt(e), setTimeout(function () { y(e) }, 100) } function o(e) { var t = yt(e.display), n = e.options.lineWrapping, r = n && Math.max(5, e.display.scroller.clientWidth / xt(e.display) - 3); return function (i) { if (kr(e.doc, i)) return 0; var o = 0; if (i.widgets) for (var a = 0; a < i.widgets.length; a++)i.widgets[a].height && (o += i.widgets[a].height); return n ? o + (Math.ceil(i.text.length / r) || 1) * t : o + t } } function a(e) { var t = e.doc, n = o(e); t.iter(function (e) { var t = n(e); t != e.height && ei(e, t) }) } function l(e) { e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + e.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), lt(e) } function s(e) { c(e), Dt(e), setTimeout(function () { w(e) }, 20) } function c(e) { var t = e.display.gutters, n = e.options.gutters; Ui(t); for (var r = 0; r < n.length; ++r) { var i = n[r], o = t.appendChild(ji("div", null, "CodeMirror-gutter " + i)); "CodeMirror-linenumbers" == i && (e.display.lineGutter = o, o.style.width = (e.display.lineNumWidth || 1) + "px") } t.style.display = r ? "" : "none", u(e) } function u(e) { var t = e.display.gutters.offsetWidth; e.display.sizer.style.marginLeft = t + "px" } function f(e) { if (0 == e.height) return 0; for (var t, n = e.text.length, r = e; t = mr(r);) { var i = t.find(0, !0); r = i.from.line, n += i.from.ch - i.to.ch } for (r = e; t = gr(r);) { var i = t.find(0, !0); n -= r.text.length - i.from.ch, r = i.to.line, n += r.text.length - i.to.ch } return n } function h(e) { var t = e.display, n = e.doc; t.maxLine = Zr(n, n.first), t.maxLineLength = f(t.maxLine), t.maxLineChanged = !0, n.iter(function (e) { var n = f(e); n > t.maxLineLength && (t.maxLineLength = n, t.maxLine = e) }) } function d(e) { var t = Pi(e.gutters, "CodeMirror-linenumbers"); -1 == t && e.lineNumbers ? e.gutters = e.gutters.concat(["CodeMirror-linenumbers"]) : t > -1 && !e.lineNumbers && (e.gutters = e.gutters.slice(0), e.gutters.splice(t, 1)) } function p(e) { var t = e.display, n = t.gutters.offsetWidth, r = Math.round(e.doc.height + qe(e.display)); return { clientHeight: t.scroller.clientHeight, viewHeight: t.wrapper.clientHeight, scrollWidth: t.scroller.scrollWidth, clientWidth: t.scroller.clientWidth, viewWidth: t.wrapper.clientWidth, barLeft: e.options.fixedGutter ? n : 0, docHeight: r, scrollHeight: r + Ye(e) + t.barHeight, nativeBarWidth: t.nativeBarWidth, gutterWidth: n } } function m(e, t, n) { this.cm = n; var r = this.vert = ji("div", [ji("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), i = this.horiz = ji("div", [ji("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar"); e(r), e(i), Ea(r, "scroll", function () { r.clientHeight && t(r.scrollTop, "vertical") }), Ea(i, "scroll", function () { i.clientWidth && t(i.scrollLeft, "horizontal") }), this.checkedZeroWidth = !1, xo && 8 > bo && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px") } function g() { } function v(t) { t.display.scrollbars && (t.display.scrollbars.clear(), t.display.scrollbars.addClass && Za(t.display.wrapper, t.display.scrollbars.addClass)), t.display.scrollbars = new e.scrollbarModel[t.options.scrollbarStyle](function (e) { t.display.wrapper.insertBefore(e, t.display.scrollbarFiller), Ea(e, "mousedown", function () { t.state.focused && setTimeout(function () { t.display.input.focus() }, 0) }), e.setAttribute("cm-not-content", "true") }, function (e, n) { "horizontal" == n ? on(t, e) : rn(t, e) }, t), t.display.scrollbars.addClass && Ja(t.display.wrapper, t.display.scrollbars.addClass) } function y(e, t) { t || (t = p(e)); var n = e.display.barWidth, r = e.display.barHeight; x(e, t); for (var i = 0; 4 > i && n != e.display.barWidth || r != e.display.barHeight; i++)n != e.display.barWidth && e.options.lineWrapping && O(e), x(e, p(e)), n = e.display.barWidth, r = e.display.barHeight } function x(e, t) { var n = e.display, r = n.scrollbars.update(t); n.sizer.style.paddingRight = (n.barWidth = r.right) + "px", n.sizer.style.paddingBottom = (n.barHeight = r.bottom) + "px", n.heightForcer.style.borderBottom = r.bottom + "px solid transparent", r.right && r.bottom ? (n.scrollbarFiller.style.display = "block", n.scrollbarFiller.style.height = r.bottom + "px", n.scrollbarFiller.style.width = r.right + "px") : n.scrollbarFiller.style.display = "", r.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (n.gutterFiller.style.display = "block", n.gutterFiller.style.height = r.bottom + "px", n.gutterFiller.style.width = t.gutterWidth + "px") : n.gutterFiller.style.display = "" } function b(e, t, n) { var r = n && null != n.top ? Math.max(0, n.top) : e.scroller.scrollTop; r = Math.floor(r - Ue(e)); var i = n && null != n.bottom ? n.bottom : r + e.wrapper.clientHeight, o = ni(t, r), a = ni(t, i); if (n && n.ensure) { var l = n.ensure.from.line, s = n.ensure.to.line; o > l ? (o = l, a = ni(t, ri(Zr(t, l)) + e.wrapper.clientHeight)) : Math.min(s, t.lastLine()) >= a && (o = ni(t, ri(Zr(t, s)) - e.wrapper.clientHeight), a = s) } return { from: o, to: Math.max(a, o + 1) } } function w(e) { var t = e.display, n = t.view; if (t.alignWidgets || t.gutters.firstChild && e.options.fixedGutter) { for (var r = C(t) - t.scroller.scrollLeft + e.doc.scrollLeft, i = t.gutters.offsetWidth, o = r + "px", a = 0; a < n.length; a++)if (!n[a].hidden) { e.options.fixedGutter && n[a].gutter && (n[a].gutter.style.left = o); var l = n[a].alignable; if (l) for (var s = 0; s < l.length; s++)l[s].style.left = o } e.options.fixedGutter && (t.gutters.style.left = r + i + "px") } } function k(e) { if (!e.options.lineNumbers) return !1; var t = e.doc, n = S(e.options, t.first + t.size - 1), r = e.display; if (n.length != r.lineNumChars) { var i = r.measure.appendChild(ji("div", [ji("div", n)], "CodeMirror-linenumber CodeMirror-gutter-elt")), o = i.firstChild.offsetWidth, a = i.offsetWidth - o; return r.lineGutter.style.width = "", r.lineNumInnerWidth = Math.max(o, r.lineGutter.offsetWidth - a) + 1, r.lineNumWidth = r.lineNumInnerWidth + a, r.lineNumChars = r.lineNumInnerWidth ? n.length : -1, r.lineGutter.style.width = r.lineNumWidth + "px", u(e), !0 } return !1 } function S(e, t) { return String(e.lineNumberFormatter(t + e.firstLineNumber)) } function C(e) { return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left } function L(e, t, n) { var r = e.display; this.viewport = t, this.visible = b(r, e.doc, t), this.editorIsHidden = !r.wrapper.offsetWidth, this.wrapperHeight = r.wrapper.clientHeight, this.wrapperWidth = r.wrapper.clientWidth, this.oldDisplayWidth = $e(e), this.force = n, this.dims = P(e), this.events = [] } function T(e) { var t = e.display; !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = Ye(e) + "px", t.sizer.style.marginBottom = -t.nativeBarWidth + "px", t.sizer.style.borderRightWidth = Ye(e) + "px", t.scrollbarsClipped = !0) } function M(e, t) { var n = e.display, r = e.doc; if (t.editorIsHidden) return Wt(e), !1; if (!t.force && t.visible.from >= n.viewFrom && t.visible.to <= n.viewTo && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo) && n.renderedView == n.view && 0 == zt(e)) return !1; k(e) && (Wt(e), t.dims = P(e)); var i = r.first + r.size, o = Math.max(t.visible.from - e.options.viewportMargin, r.first), a = Math.min(i, t.visible.to + e.options.viewportMargin); n.viewFrom < o && o - n.viewFrom < 20 && (o = Math.max(r.first, n.viewFrom)), n.viewTo > a && n.viewTo - a < 20 && (a = Math.min(i, n.viewTo)), Wo && (o = br(e.doc, o), a = wr(e.doc, a)); var l = o != n.viewFrom || a != n.viewTo || n.lastWrapHeight != t.wrapperHeight || n.lastWrapWidth != t.wrapperWidth; Ft(e, o, a), n.viewOffset = ri(Zr(e.doc, n.viewFrom)), e.display.mover.style.top = n.viewOffset + "px"; var s = zt(e); if (!l && 0 == s && !t.force && n.renderedView == n.view && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo)) return !1; var c = Gi(); return s > 4 && (n.lineDiv.style.display = "none"), R(e, n.updateLineNumbers, t.dims), s > 4 && (n.lineDiv.style.display = ""), n.renderedView = n.view, c && Gi() != c && c.offsetHeight && c.focus(), Ui(n.cursorDiv), Ui(n.selectionDiv), n.gutters.style.height = n.sizer.style.minHeight = 0, l && (n.lastWrapHeight = t.wrapperHeight, n.lastWrapWidth = t.wrapperWidth, _e(e, 400)), n.updateLineNumbers = null, !0 } function N(e, t) { for (var n = t.viewport, r = !0; (r && e.options.lineWrapping && t.oldDisplayWidth != $e(e) || (n && null != n.top && (n = { top: Math.min(e.doc.height + qe(e.display) - Ve(e), n.top) }), t.visible = b(e.display, e.doc, n), !(t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo))) && M(e, t); r = !1) { O(e); var i = p(e); Re(e), y(e, i), E(e, i) } t.signal(e, "update", e), e.display.viewFrom == e.display.reportedViewFrom && e.display.viewTo == e.display.reportedViewTo || (t.signal(e, "viewportChange", e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo) } function A(e, t) { var n = new L(e, t); if (M(e, n)) { O(e), N(e, n); var r = p(e); Re(e), y(e, r), E(e, r), n.finish() } } function E(e, t) { e.display.sizer.style.minHeight = t.docHeight + "px", e.display.heightForcer.style.top = t.docHeight + "px", e.display.gutters.style.height = t.docHeight + e.display.barHeight + Ye(e) + "px" } function O(e) { for (var t = e.display, n = t.lineDiv.offsetTop, r = 0; r < t.view.length; r++) { var i, o = t.view[r]; if (!o.hidden) { if (xo && 8 > bo) { var a = o.node.offsetTop + o.node.offsetHeight; i = a - n, n = a } else { var l = o.node.getBoundingClientRect(); i = l.bottom - l.top } var s = o.line.height - i; if (2 > i && (i = yt(t)), (s > .001 || -.001 > s) && (ei(o.line, i), I(o.line), o.rest)) for (var c = 0; c < o.rest.length; c++)I(o.rest[c]) } } } function I(e) { if (e.widgets) for (var t = 0; t < e.widgets.length; ++t)e.widgets[t].height = e.widgets[t].node.parentNode.offsetHeight } function P(e) { for (var t = e.display, n = {}, r = {}, i = t.gutters.clientLeft, o = t.gutters.firstChild, a = 0; o; o = o.nextSibling, ++a)n[e.options.gutters[a]] = o.offsetLeft + o.clientLeft + i, r[e.options.gutters[a]] = o.clientWidth; return { fixedPos: C(t), gutterTotalWidth: t.gutters.offsetWidth, gutterLeft: n, gutterWidth: r, wrapperWidth: t.wrapper.clientWidth } } function R(e, t, n) { function r(t) { var n = t.nextSibling; return wo && Eo && e.display.currentWheelTarget == t ? t.style.display = "none" : t.parentNode.removeChild(t), n } for (var i = e.display, o = e.options.lineNumbers, a = i.lineDiv, l = a.firstChild, s = i.view, c = i.viewFrom, u = 0; u < s.length; u++) { var f = s[u]; if (f.hidden); else if (f.node && f.node.parentNode == a) { for (; l != f.node;)l = r(l); var h = o && null != t && c >= t && f.lineNumber; f.changes && (Pi(f.changes, "gutter") > -1 && (h = !1), D(e, f, c, n)), h && (Ui(f.lineNumber), f.lineNumber.appendChild(document.createTextNode(S(e.options, c)))), l = f.node.nextSibling } else { var d = U(e, f, c, n); a.insertBefore(d, l) } c += f.size } for (; l;)l = r(l) } function D(e, t, n, r) { for (var i = 0; i < t.changes.length; i++) { var o = t.changes[i]; "text" == o ? _(e, t) : "gutter" == o ? z(e, t, n, r) : "class" == o ? F(t) : "widget" == o && j(e, t, r) } t.changes = null } function H(e) { return e.node == e.text && (e.node = ji("div", null, null, "position: relative"), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), xo && 8 > bo && (e.node.style.zIndex = 2)), e.node } function W(e) { var t = e.bgClass ? e.bgClass + " " + (e.line.bgClass || "") : e.line.bgClass; if (t && (t += " CodeMirror-linebackground"), e.background) t ? e.background.className = t : (e.background.parentNode.removeChild(e.background), e.background = null); else if (t) { var n = H(e); e.background = n.insertBefore(ji("div", null, t), n.firstChild) } } function B(e, t) { var n = e.display.externalMeasured; return n && n.line == t.line ? (e.display.externalMeasured = null, t.measure = n.measure, n.built) : Br(e, t) } function _(e, t) { var n = t.text.className, r = B(e, t); t.text == t.node && (t.node = r.pre), t.text.parentNode.replaceChild(r.pre, t.text), t.text = r.pre, r.bgClass != t.bgClass || r.textClass != t.textClass ? (t.bgClass = r.bgClass, t.textClass = r.textClass, F(t)) : n && (t.text.className = n) } function F(e) { W(e), e.line.wrapClass ? H(e).className = e.line.wrapClass : e.node != e.text && (e.node.className = ""); var t = e.textClass ? e.textClass + " " + (e.line.textClass || "") : e.line.textClass; e.text.className = t || "" } function z(e, t, n, r) { if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass) { var i = H(t); t.gutterBackground = ji("div", null, "CodeMirror-gutter-background " + t.line.gutterClass, "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px; width: " + r.gutterTotalWidth + "px"), i.insertBefore(t.gutterBackground, t.text) } var o = t.line.gutterMarkers; if (e.options.lineNumbers || o) { var i = H(t), a = t.gutter = ji("div", null, "CodeMirror-gutter-wrapper", "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px"); if (e.display.input.setUneditable(a), i.insertBefore(a, t.text), t.line.gutterClass && (a.className += " " + t.line.gutterClass), !e.options.lineNumbers || o && o["CodeMirror-linenumbers"] || (t.lineNumber = a.appendChild(ji("div", S(e.options, n), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + r.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + e.display.lineNumInnerWidth + "px"))), o) for (var l = 0; l < e.options.gutters.length; ++l) { var s = e.options.gutters[l], c = o.hasOwnProperty(s) && o[s]; c && a.appendChild(ji("div", [c], "CodeMirror-gutter-elt", "left: " + r.gutterLeft[s] + "px; width: " + r.gutterWidth[s] + "px")) } } } function j(e, t, n) { t.alignable && (t.alignable = null); for (var r, i = t.node.firstChild; i; i = r) { var r = i.nextSibling; "CodeMirror-linewidget" == i.className && t.node.removeChild(i) } q(e, t, n) } function U(e, t, n, r) { var i = B(e, t); return t.text = t.node = i.pre, i.bgClass && (t.bgClass = i.bgClass), i.textClass && (t.textClass = i.textClass), F(t), z(e, t, n, r), q(e, t, r), t.node } function q(e, t, n) { if (G(e, t.line, t, n, !0), t.rest) for (var r = 0; r < t.rest.length; r++)G(e, t.rest[r], t, n, !1) } function G(e, t, n, r, i) { if (t.widgets) for (var o = H(n), a = 0, l = t.widgets; a < l.length; ++a) { var s = l[a], c = ji("div", [s.node], "CodeMirror-linewidget"); s.handleMouseEvents || c.setAttribute("cm-ignore-events", "true"), Y(s, c, n, r), e.display.input.setUneditable(c), i && s.above ? o.insertBefore(c, n.gutter || n.text) : o.appendChild(c), Ci(s, "redraw") } } function Y(e, t, n, r) { if (e.noHScroll) { (n.alignable || (n.alignable = [])).push(t); var i = r.wrapperWidth; t.style.left = r.fixedPos + "px", e.coverGutter || (i -= r.gutterTotalWidth, t.style.paddingLeft = r.gutterTotalWidth + "px"), t.style.width = i + "px" } e.coverGutter && (t.style.zIndex = 5, t.style.position = "relative", e.noHScroll || (t.style.marginLeft = -r.gutterTotalWidth + "px")) } function $(e) { return Bo(e.line, e.ch) } function V(e, t) { return _o(e, t) < 0 ? t : e } function K(e, t) { return _o(e, t) < 0 ? e : t } function X(e) { e.state.focused || (e.display.input.focus(), vn(e)) } function Z(e, t, n, r, i) { var o = e.doc; e.display.shift = !1, r || (r = o.sel); var a = e.state.pasteIncoming || "paste" == i, l = o.splitLines(t), s = null; if (a && r.ranges.length > 1) if (Fo && Fo.text.join("\n") == t) { if (r.ranges.length % Fo.text.length == 0) { s = []; for (var c = 0; c < Fo.text.length; c++)s.push(o.splitLines(Fo.text[c])) } } else l.length == r.ranges.length && (s = Ri(l, function (e) { return [e] })); for (var c = r.ranges.length - 1; c >= 0; c--) { var u = r.ranges[c], f = u.from(), h = u.to(); u.empty() && (n && n > 0 ? f = Bo(f.line, f.ch - n) : e.state.overwrite && !a ? h = Bo(h.line, Math.min(Zr(o, h.line).text.length, h.ch + Ii(l).length)) : Fo && Fo.lineWise && Fo.text.join("\n") == t && (f = h = Bo(f.line, 0))); var d = e.curOp.updateInput, p = { from: f, to: h, text: s ? s[c % s.length] : l, origin: i || (a ? "paste" : e.state.cutIncoming ? "cut" : "+input") }; Tn(e.doc, p), Ci(e, "inputRead", e, p) } t && !a && Q(e, t), Bn(e), e.curOp.updateInput = d, e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = !1 } function J(e, t) { var n = e.clipboardData && e.clipboardData.getData("text/plain"); return n ? (e.preventDefault(), t.isReadOnly() || t.options.disableInput || At(t, function () { Z(t, n, 0, null, "paste") }), !0) : void 0 } function Q(e, t) { if (e.options.electricChars && e.options.smartIndent) for (var n = e.doc.sel, r = n.ranges.length - 1; r >= 0; r--) { var i = n.ranges[r]; if (!(i.head.ch > 100 || r && n.ranges[r - 1].head.line == i.head.line)) { var o = e.getModeAt(i.head), a = !1; if (o.electricChars) { for (var l = 0; l < o.electricChars.length; l++)if (t.indexOf(o.electricChars.charAt(l)) > -1) { a = Fn(e, i.head.line, "smart"); break } } else o.electricInput && o.electricInput.test(Zr(e.doc, i.head.line).text.slice(0, i.head.ch)) && (a = Fn(e, i.head.line, "smart")); a && Ci(e, "electricInput", e, i.head.line) } } } function ee(e) { for (var t = [], n = [], r = 0; r < e.doc.sel.ranges.length; r++) { var i = e.doc.sel.ranges[r].head.line, o = { anchor: Bo(i, 0), head: Bo(i + 1, 0) }; n.push(o), t.push(e.getRange(o.anchor, o.head)) } return { text: t, ranges: n } } function te(e) { e.setAttribute("autocorrect", "off"), e.setAttribute("autocapitalize", "off"), e.setAttribute("spellcheck", "false") } function ne(e) { this.cm = e, this.prevInput = "", this.pollingFast = !1, this.polling = new Ei, this.inaccurateSelection = !1, this.hasSelection = !1, this.composing = null } function re() { var e = ji("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none"), t = ji("div", [e], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"); return wo ? e.style.width = "1000px" : e.setAttribute("wrap", "off"), No && (e.style.border = "1px solid black"), te(e), t } function ie(e) { this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new Ei, this.gracePeriod = !1 } function oe(e, t) { var n = Qe(e, t.line); if (!n || n.hidden) return null; var r = Zr(e.doc, t.line), i = Xe(n, r, t.line), o = ii(r), a = "left"; if (o) { var l = co(o, t.ch); a = l % 2 ? "right" : "left" } var s = nt(i.map, t.ch, a); return s.offset = "right" == s.collapse ? s.end : s.start, s } function ae(e, t) { return t && (e.bad = !0), e } function le(e, t, n) { var r; if (t == e.display.lineDiv) { if (r = e.display.lineDiv.childNodes[n], !r) return ae(e.clipPos(Bo(e.display.viewTo - 1)), !0); t = null, n = 0 } else for (r = t; ; r = r.parentNode) { if (!r || r == e.display.lineDiv) return null; if (r.parentNode && r.parentNode == e.display.lineDiv) break } for (var i = 0; i < e.display.view.length; i++) { var o = e.display.view[i]; if (o.node == r) return se(o, t, n) } } function se(e, t, n) { function r(t, n, r) { for (var i = -1; i < (u ? u.length : 0); i++)for (var o = 0 > i ? c.map : u[i], a = 0; a < o.length; a += 3) { var l = o[a + 2]; if (l == t || l == n) { var s = ti(0 > i ? e.line : e.rest[i]), f = o[a] + r; return (0 > r || l != t) && (f = o[a + (r ? 1 : 0)]), Bo(s, f) } } } var i = e.text.firstChild, o = !1; if (!t || !Va(i, t)) return ae(Bo(ti(e.line), 0), !0); if (t == i && (o = !0, t = i.childNodes[n], n = 0, !t)) { var a = e.rest ? Ii(e.rest) : e.line; return ae(Bo(ti(a), a.text.length), o) } var l = 3 == t.nodeType ? t : null, s = t; for (l || 1 != t.childNodes.length || 3 != t.firstChild.nodeType || (l = t.firstChild, n && (n = l.nodeValue.length)); s.parentNode != i;)s = s.parentNode; var c = e.measure, u = c.maps, f = r(l, s, n); if (f) return ae(f, o); for (var h = s.nextSibling, d = l ? l.nodeValue.length - n : 0; h; h = h.nextSibling) { if (f = r(h, h.firstChild, 0)) return ae(Bo(f.line, f.ch - d), o); d += h.textContent.length } for (var p = s.previousSibling, d = n; p; p = p.previousSibling) { if (f = r(p, p.firstChild, -1)) return ae(Bo(f.line, f.ch + d), o); d += h.textContent.length } } function ce(e, t, n, r, i) { function o(e) { return function (t) { return t.id == e } } function a(t) { if (1 == t.nodeType) { var n = t.getAttribute("cm-text"); if (null != n) return "" == n && (n = t.textContent.replace(/\u200b/g, "")), void (l += n); var u, f = t.getAttribute("cm-marker"); if (f) { var h = e.findMarks(Bo(r, 0), Bo(i + 1, 0), o(+f)); return void (h.length && (u = h[0].find()) && (l += Jr(e.doc, u.from, u.to).join(c))) } if ("false" == t.getAttribute("contenteditable")) return; for (var d = 0; d < t.childNodes.length; d++)a(t.childNodes[d]); /^(pre|div|p)$/i.test(t.nodeName) && (s = !0) } else if (3 == t.nodeType) { var p = t.nodeValue; if (!p) return; s && (l += c, s = !1), l += p } } for (var l = "", s = !1, c = e.doc.lineSeparator(); a(t), t != n;)t = t.nextSibling; return l } function ue(e, t) { this.ranges = e, this.primIndex = t } function fe(e, t) { this.anchor = e, this.head = t } function he(e, t) { var n = e[t]; e.sort(function (e, t) { return _o(e.from(), t.from()) }), t = Pi(e, n); for (var r = 1; r < e.length; r++) { var i = e[r], o = e[r - 1]; if (_o(o.to(), i.from()) >= 0) { var a = K(o.from(), i.from()), l = V(o.to(), i.to()), s = o.empty() ? i.from() == i.head : o.from() == o.head; t >= r && --t, e.splice(--r, 2, new fe(s ? l : a, s ? a : l)) } } return new ue(e, t) } function de(e, t) { return new ue([new fe(e, t || e)], 0) } function pe(e, t) { return Math.max(e.first, Math.min(t, e.first + e.size - 1)) } function me(e, t) { if (t.line < e.first) return Bo(e.first, 0); var n = e.first + e.size - 1; return t.line > n ? Bo(n, Zr(e, n).text.length) : ge(t, Zr(e, t.line).text.length) } function ge(e, t) { var n = e.ch; return null == n || n > t ? Bo(e.line, t) : 0 > n ? Bo(e.line, 0) : e } function ve(e, t) { return t >= e.first && t < e.first + e.size } function ye(e, t) { for (var n = [], r = 0; r < t.length; r++)n[r] = me(e, t[r]); return n } function xe(e, t, n, r) { if (e.cm && e.cm.display.shift || e.extend) { var i = t.anchor; if (r) { var o = _o(n, i) < 0; o != _o(r, i) < 0 ? (i = n, n = r) : o != _o(n, r) < 0 && (n = r) } return new fe(i, n) } return new fe(r || n, n) } function be(e, t, n, r) { Te(e, new ue([xe(e, e.sel.primary(), t, n)], 0), r) } function we(e, t, n) { for (var r = [], i = 0; i < e.sel.ranges.length; i++)r[i] = xe(e, e.sel.ranges[i], t[i], null); var o = he(r, e.sel.primIndex); Te(e, o, n) } function ke(e, t, n, r) { var i = e.sel.ranges.slice(0); i[t] = n, Te(e, he(i, e.sel.primIndex), r) } function Se(e, t, n, r) { Te(e, de(t, n), r) } function Ce(e, t, n) { var r = { ranges: t.ranges, update: function (t) { this.ranges = []; for (var n = 0; n < t.length; n++)this.ranges[n] = new fe(me(e, t[n].anchor), me(e, t[n].head)) }, origin: n && n.origin }; return Pa(e, "beforeSelectionChange", e, r), e.cm && Pa(e.cm, "beforeSelectionChange", e.cm, r), r.ranges != t.ranges ? he(r.ranges, r.ranges.length - 1) : t } function Le(e, t, n) { var r = e.history.done, i = Ii(r); i && i.ranges ? (r[r.length - 1] = t, Me(e, t, n)) : Te(e, t, n) } function Te(e, t, n) { Me(e, t, n), fi(e, e.sel, e.cm ? e.cm.curOp.id : NaN, n) } function Me(e, t, n) { (Ni(e, "beforeSelectionChange") || e.cm && Ni(e.cm, "beforeSelectionChange")) && (t = Ce(e, t, n)); var r = n && n.bias || (_o(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1); Ne(e, Ee(e, t, r, !0)), n && n.scroll === !1 || !e.cm || Bn(e.cm) } function Ne(e, t) { t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = e.cm.curOp.selectionChanged = !0, Mi(e.cm)), Ci(e, "cursorActivity", e)) } function Ae(e) { Ne(e, Ee(e, e.sel, null, !1), Wa) } function Ee(e, t, n, r) { for (var i, o = 0; o < t.ranges.length; o++) { var a = t.ranges[o], l = t.ranges.length == e.sel.ranges.length && e.sel.ranges[o], s = Ie(e, a.anchor, l && l.anchor, n, r), c = Ie(e, a.head, l && l.head, n, r); (i || s != a.anchor || c != a.head) && (i || (i = t.ranges.slice(0, o)), i[o] = new fe(s, c)) } return i ? he(i, t.primIndex) : t } function Oe(e, t, n, r, i) { var o = Zr(e, t.line); if (o.markedSpans) for (var a = 0; a < o.markedSpans.length; ++a) { var l = o.markedSpans[a], s = l.marker; if ((null == l.from || (s.inclusiveLeft ? l.from <= t.ch : l.from < t.ch)) && (null == l.to || (s.inclusiveRight ? l.to >= t.ch : l.to > t.ch))) { if (i && (Pa(s, "beforeCursorEnter"), s.explicitlyCleared)) { if (o.markedSpans) { --a; continue } break } if (!s.atomic) continue; if (n) { var c, u = s.find(0 > r ? 1 : -1); if ((0 > r ? s.inclusiveRight : s.inclusiveLeft) && (u = Pe(e, u, -r, u && u.line == t.line ? o : null)), u && u.line == t.line && (c = _o(u, n)) && (0 > r ? 0 > c : c > 0)) return Oe(e, u, t, r, i) } var f = s.find(0 > r ? -1 : 1); return (0 > r ? s.inclusiveLeft : s.inclusiveRight) && (f = Pe(e, f, r, f.line == t.line ? o : null)), f ? Oe(e, f, t, r, i) : null } } return t } function Ie(e, t, n, r, i) { var o = r || 1, a = Oe(e, t, n, o, i) || !i && Oe(e, t, n, o, !0) || Oe(e, t, n, -o, i) || !i && Oe(e, t, n, -o, !0); return a ? a : (e.cantEdit = !0, Bo(e.first, 0)) } function Pe(e, t, n, r) { return 0 > n && 0 == t.ch ? t.line > e.first ? me(e, Bo(t.line - 1)) : null : n > 0 && t.ch == (r || Zr(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? Bo(t.line + 1, 0) : null : new Bo(t.line, t.ch + n) } function Re(e) { e.display.input.showSelection(e.display.input.prepareSelection()) } function De(e, t) { for (var n = e.doc, r = {}, i = r.cursors = document.createDocumentFragment(), o = r.selection = document.createDocumentFragment(), a = 0; a < n.sel.ranges.length; a++)if (t !== !1 || a != n.sel.primIndex) { var l = n.sel.ranges[a]; if (!(l.from().line >= e.display.viewTo || l.to().line < e.display.viewFrom)) { var s = l.empty(); (s || e.options.showCursorWhenSelecting) && He(e, l.head, i), s || We(e, l, o) } } return r } function He(e, t, n) { var r = dt(e, t, "div", null, null, !e.options.singleCursorHeightPerLine), i = n.appendChild(ji("div", " ", "CodeMirror-cursor")); if (i.style.left = r.left + "px", i.style.top = r.top + "px", i.style.height = Math.max(0, r.bottom - r.top) * e.options.cursorHeight + "px", r.other) { var o = n.appendChild(ji("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor")); o.style.display = "", o.style.left = r.other.left + "px", o.style.top = r.other.top + "px", o.style.height = .85 * (r.other.bottom - r.other.top) + "px" } } function We(e, t, n) { function r(e, t, n, r) { 0 > t && (t = 0), t = Math.round(t), r = Math.round(r), l.appendChild(ji("div", null, "CodeMirror-selected", "position: absolute; left: " + e + "px; top: " + t + "px; width: " + (null == n ? u - e : n) + "px; height: " + (r - t) + "px")) } function i(t, n, i) { function o(n, r) { return ht(e, Bo(t, n), "div", f, r) } var l, s, f = Zr(a, t), h = f.text.length; return eo(ii(f), n || 0, null == i ? h : i, function (e, t, a) { var f, d, p, m = o(e, "left"); if (e == t) f = m, d = p = m.left; else { if (f = o(t - 1, "right"), "rtl" == a) { var g = m; m = f, f = g } d = m.left, p = f.right } null == n && 0 == e && (d = c), f.top - m.top > 3 && (r(d, m.top, null, m.bottom), d = c, m.bottom < f.top && r(d, m.bottom, null, f.top)), null == i && t == h && (p = u), (!l || m.top < l.top || m.top == l.top && m.left < l.left) && (l = m), (!s || f.bottom > s.bottom || f.bottom == s.bottom && f.right > s.right) && (s = f), c + 1 > d && (d = c), r(d, f.top, p - d, f.bottom) }), { start: l, end: s } } var o = e.display, a = e.doc, l = document.createDocumentFragment(), s = Ge(e.display), c = s.left, u = Math.max(o.sizerWidth, $e(e) - o.sizer.offsetLeft) - s.right, f = t.from(), h = t.to(); if (f.line == h.line) i(f.line, f.ch, h.ch); else { var d = Zr(a, f.line), p = Zr(a, h.line), m = yr(d) == yr(p), g = i(f.line, f.ch, m ? d.text.length + 1 : null).end, v = i(h.line, m ? 0 : null, h.ch).start; m && (g.top < v.top - 2 ? (r(g.right, g.top, null, g.bottom), r(c, v.top, v.left, v.bottom)) : r(g.right, g.top, v.left - g.right, g.bottom)), g.bottom < v.top && r(c, g.bottom, null, v.top) } n.appendChild(l) } function Be(e) { if (e.state.focused) { var t = e.display; clearInterval(t.blinker); var n = !0; t.cursorDiv.style.visibility = "", e.options.cursorBlinkRate > 0 ? t.blinker = setInterval(function () { t.cursorDiv.style.visibility = (n = !n) ? "" : "hidden" }, e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = "hidden") } } function _e(e, t) { e.doc.mode.startState && e.doc.frontier < e.display.viewTo && e.state.highlight.set(t, Bi(Fe, e)) } function Fe(e) { var t = e.doc; if (t.frontier < t.first && (t.frontier = t.first), !(t.frontier >= e.display.viewTo)) { var n = +new Date + e.options.workTime, r = sa(t.mode, je(e, t.frontier)), i = []; t.iter(t.frontier, Math.min(t.first + t.size, e.display.viewTo + 500), function (o) { if (t.frontier >= e.display.viewFrom) { var a = o.styles, l = o.text.length > e.options.maxHighlightLength, s = Rr(e, o, l ? sa(t.mode, r) : r, !0); o.styles = s.styles; var c = o.styleClasses, u = s.classes; u ? o.styleClasses = u : c && (o.styleClasses = null); for (var f = !a || a.length != o.styles.length || c != u && (!c || !u || c.bgClass != u.bgClass || c.textClass != u.textClass), h = 0; !f && h < a.length; ++h)f = a[h] != o.styles[h]; f && i.push(t.frontier), o.stateAfter = l ? r : sa(t.mode, r) } else o.text.length <= e.options.maxHighlightLength && Hr(e, o.text, r), o.stateAfter = t.frontier % 5 == 0 ? sa(t.mode, r) : null; return ++t.frontier, +new Date > n ? (_e(e, e.options.workDelay), !0) : void 0 }), i.length && At(e, function () { for (var t = 0; t < i.length; t++)Ht(e, i[t], "text") }) } } function ze(e, t, n) { for (var r, i, o = e.doc, a = n ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100), l = t; l > a; --l) { if (l <= o.first) return o.first; var s = Zr(o, l - 1); if (s.stateAfter && (!n || l <= o.frontier)) return l; var c = Fa(s.text, null, e.options.tabSize); (null == i || r > c) && (i = l - 1, r = c) } return i } function je(e, t, n) { var r = e.doc, i = e.display; if (!r.mode.startState) return !0; var o = ze(e, t, n), a = o > r.first && Zr(r, o - 1).stateAfter; return a = a ? sa(r.mode, a) : ca(r.mode), r.iter(o, t, function (n) { Hr(e, n.text, a); var l = o == t - 1 || o % 5 == 0 || o >= i.viewFrom && o < i.viewTo; n.stateAfter = l ? sa(r.mode, a) : null, ++o }), n && (r.frontier = o), a } function Ue(e) { return e.lineSpace.offsetTop } function qe(e) { return e.mover.offsetHeight - e.lineSpace.offsetHeight } function Ge(e) { if (e.cachedPaddingH) return e.cachedPaddingH; var t = qi(e.measure, ji("pre", "x")), n = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle, r = { left: parseInt(n.paddingLeft), right: parseInt(n.paddingRight) }; return isNaN(r.left) || isNaN(r.right) || (e.cachedPaddingH = r), r } function Ye(e) { return Da - e.display.nativeBarWidth } function $e(e) { return e.display.scroller.clientWidth - Ye(e) - e.display.barWidth } function Ve(e) { return e.display.scroller.clientHeight - Ye(e) - e.display.barHeight } function Ke(e, t, n) { var r = e.options.lineWrapping, i = r && $e(e); if (!t.measure.heights || r && t.measure.width != i) { var o = t.measure.heights = []; if (r) { t.measure.width = i; for (var a = t.text.firstChild.getClientRects(), l = 0; l < a.length - 1; l++) { var s = a[l], c = a[l + 1]; Math.abs(s.bottom - c.bottom) > 2 && o.push((s.bottom + c.top) / 2 - n.top) } } o.push(n.bottom - n.top) } } function Xe(e, t, n) { if (e.line == t) return { map: e.measure.map, cache: e.measure.cache }; for (var r = 0; r < e.rest.length; r++)if (e.rest[r] == t) return { map: e.measure.maps[r], cache: e.measure.caches[r] }; for (var r = 0; r < e.rest.length; r++)if (ti(e.rest[r]) > n) return { map: e.measure.maps[r], cache: e.measure.caches[r], before: !0 } } function Ze(e, t) { t = yr(t); var n = ti(t), r = e.display.externalMeasured = new Pt(e.doc, t, n); r.lineN = n; var i = r.built = Br(e, r); return r.text = i.pre, qi(e.display.lineMeasure, i.pre), r } function Je(e, t, n, r) { return tt(e, et(e, t), n, r) } function Qe(e, t) { if (t >= e.display.viewFrom && t < e.display.viewTo) return e.display.view[Bt(e, t)]; var n = e.display.externalMeasured; return n && t >= n.lineN && t < n.lineN + n.size ? n : void 0 } function et(e, t) { var n = ti(t), r = Qe(e, n); r && !r.text ? r = null : r && r.changes && (D(e, r, n, P(e)), e.curOp.forceUpdate = !0), r || (r = Ze(e, t)); var i = Xe(r, t, n); return { line: t, view: r, rect: null, map: i.map, cache: i.cache, before: i.before, hasHeights: !1 } } function tt(e, t, n, r, i) { t.before && (n = -1); var o, a = n + (r || ""); return t.cache.hasOwnProperty(a) ? o = t.cache[a] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (Ke(e, t.view, t.rect), t.hasHeights = !0), o = rt(e, t, n, r), o.bogus || (t.cache[a] = o)), { left: o.left, right: o.right, top: i ? o.rtop : o.top, bottom: i ? o.rbottom : o.bottom } } function nt(e, t, n) { for (var r, i, o, a, l = 0; l < e.length; l += 3) { var s = e[l], c = e[l + 1]; if (s > t ? (i = 0, o = 1, a = "left") : c > t ? (i = t - s, o = i + 1) : (l == e.length - 3 || t == c && e[l + 3] > t) && (o = c - s, i = o - 1, t >= c && (a = "right")), null != i) { if (r = e[l + 2], s == c && n == (r.insertLeft ? "left" : "right") && (a = n), "left" == n && 0 == i) for (; l && e[l - 2] == e[l - 3] && e[l - 1].insertLeft;)r = e[(l -= 3) + 2], a = "left"; if ("right" == n && i == c - s) for (; l < e.length - 3 && e[l + 3] == e[l + 4] && !e[l + 5].insertLeft;)r = e[(l += 3) + 2], a = "right"; break } } return { node: r, start: i, end: o, collapse: a, coverStart: s, coverEnd: c } } function rt(e, t, n, r) { var i, o = nt(t.map, n, r), a = o.node, l = o.start, s = o.end, c = o.collapse; if (3 == a.nodeType) { for (var u = 0; 4 > u; u++) { for (; l && zi(t.line.text.charAt(o.coverStart + l));)--l; for (; o.coverStart + s < o.coverEnd && zi(t.line.text.charAt(o.coverStart + s));)++s; if (xo && 9 > bo && 0 == l && s == o.coverEnd - o.coverStart) i = a.parentNode.getBoundingClientRect(); else if (xo && e.options.lineWrapping) { var f = qa(a, l, s).getClientRects(); i = f.length ? f["right" == r ? f.length - 1 : 0] : qo } else i = qa(a, l, s).getBoundingClientRect() || qo; if (i.left || i.right || 0 == l) break; s = l, l -= 1, c = "right" } xo && 11 > bo && (i = it(e.display.measure, i)) } else { l > 0 && (c = r = "right"); var f; i = e.options.lineWrapping && (f = a.getClientRects()).length > 1 ? f["right" == r ? f.length - 1 : 0] : a.getBoundingClientRect() } if (xo && 9 > bo && !l && (!i || !i.left && !i.right)) { var h = a.parentNode.getClientRects()[0]; i = h ? { left: h.left, right: h.left + xt(e.display), top: h.top, bottom: h.bottom } : qo } for (var d = i.top - t.rect.top, p = i.bottom - t.rect.top, m = (d + p) / 2, g = t.view.measure.heights, u = 0; u < g.length - 1 && !(m < g[u]); u++); var v = u ? g[u - 1] : 0, y = g[u], x = { left: ("right" == c ? i.right : i.left) - t.rect.left, right: ("left" == c ? i.left : i.right) - t.rect.left, top: v, bottom: y }; return i.left || i.right || (x.bogus = !0), e.options.singleCursorHeightPerLine || (x.rtop = d, x.rbottom = p), x } function it(e, t) { if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !Qi(e)) return t; var n = screen.logicalXDPI / screen.deviceXDPI, r = screen.logicalYDPI / screen.deviceYDPI; return { left: t.left * n, right: t.right * n, top: t.top * r, bottom: t.bottom * r } } function ot(e) { if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest)) for (var t = 0; t < e.rest.length; t++)e.measure.caches[t] = {} } function at(e) { e.display.externalMeasure = null, Ui(e.display.lineMeasure); for (var t = 0; t < e.display.view.length; t++)ot(e.display.view[t]) } function lt(e) { at(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null } function st() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft } function ct() { return window.pageYOffset || (document.documentElement || document.body).scrollTop } function ut(e, t, n, r) { if (t.widgets) for (var i = 0; i < t.widgets.length; ++i)if (t.widgets[i].above) { var o = Lr(t.widgets[i]); n.top += o, n.bottom += o } if ("line" == r) return n; r || (r = "local"); var a = ri(t); if ("local" == r ? a += Ue(e.display) : a -= e.display.viewOffset, "page" == r || "window" == r) { var l = e.display.lineSpace.getBoundingClientRect(); a += l.top + ("window" == r ? 0 : ct()); var s = l.left + ("window" == r ? 0 : st()); n.left += s, n.right += s } return n.top += a, n.bottom += a, n } function ft(e, t, n) {
                    if ("div" == n) return t; var r = t.left, i = t.top; if ("page" == n) r -= st(),
                        i -= ct(); else if ("local" == n || !n) { var o = e.display.sizer.getBoundingClientRect(); r += o.left, i += o.top } var a = e.display.lineSpace.getBoundingClientRect(); return { left: r - a.left, top: i - a.top }
                } function ht(e, t, n, r, i) { return r || (r = Zr(e.doc, t.line)), ut(e, r, Je(e, r, t.ch, i), n) } function dt(e, t, n, r, i, o) { function a(t, a) { var l = tt(e, i, t, a ? "right" : "left", o); return a ? l.left = l.right : l.right = l.left, ut(e, r, l, n) } function l(e, t) { var n = s[t], r = n.level % 2; return e == to(n) && t && n.level < s[t - 1].level ? (n = s[--t], e = no(n) - (n.level % 2 ? 0 : 1), r = !0) : e == no(n) && t < s.length - 1 && n.level < s[t + 1].level && (n = s[++t], e = to(n) - n.level % 2, r = !1), r && e == n.to && e > n.from ? a(e - 1) : a(e, r) } r = r || Zr(e.doc, t.line), i || (i = et(e, r)); var s = ii(r), c = t.ch; if (!s) return a(c); var u = co(s, c), f = l(c, u); return null != al && (f.other = l(c, al)), f } function pt(e, t) { var n = 0, t = me(e.doc, t); e.options.lineWrapping || (n = xt(e.display) * t.ch); var r = Zr(e.doc, t.line), i = ri(r) + Ue(e.display); return { left: n, right: n, top: i, bottom: i + r.height } } function mt(e, t, n, r) { var i = Bo(e, t); return i.xRel = r, n && (i.outside = !0), i } function gt(e, t, n) { var r = e.doc; if (n += e.display.viewOffset, 0 > n) return mt(r.first, 0, !0, -1); var i = ni(r, n), o = r.first + r.size - 1; if (i > o) return mt(r.first + r.size - 1, Zr(r, o).text.length, !0, 1); 0 > t && (t = 0); for (var a = Zr(r, i); ;) { var l = vt(e, a, i, t, n), s = gr(a), c = s && s.find(0, !0); if (!s || !(l.ch > c.from.ch || l.ch == c.from.ch && l.xRel > 0)) return l; i = ti(a = c.to.line) } } function vt(e, t, n, r, i) { function o(r) { var i = dt(e, Bo(n, r), "line", t, c); return l = !0, a > i.bottom ? i.left - s : a < i.top ? i.left + s : (l = !1, i.left) } var a = i - ri(t), l = !1, s = 2 * e.display.wrapper.clientWidth, c = et(e, t), u = ii(t), f = t.text.length, h = ro(t), d = io(t), p = o(h), m = l, g = o(d), v = l; if (r > g) return mt(n, d, v, 1); for (; ;) { if (u ? d == h || d == fo(t, h, 1) : 1 >= d - h) { for (var y = p > r || g - r >= r - p ? h : d, x = r - (y == h ? p : g); zi(t.text.charAt(y));)++y; var b = mt(n, y, y == h ? m : v, -1 > x ? -1 : x > 1 ? 1 : 0); return b } var w = Math.ceil(f / 2), k = h + w; if (u) { k = h; for (var S = 0; w > S; ++S)k = fo(t, k, 1) } var C = o(k); C > r ? (d = k, g = C, (v = l) && (g += 1e3), f = w) : (h = k, p = C, m = l, f -= w) } } function yt(e) { if (null != e.cachedTextHeight) return e.cachedTextHeight; if (null == zo) { zo = ji("pre"); for (var t = 0; 49 > t; ++t)zo.appendChild(document.createTextNode("x")), zo.appendChild(ji("br")); zo.appendChild(document.createTextNode("x")) } qi(e.measure, zo); var n = zo.offsetHeight / 50; return n > 3 && (e.cachedTextHeight = n), Ui(e.measure), n || 1 } function xt(e) { if (null != e.cachedCharWidth) return e.cachedCharWidth; var t = ji("span", "xxxxxxxxxx"), n = ji("pre", [t]); qi(e.measure, n); var r = t.getBoundingClientRect(), i = (r.right - r.left) / 10; return i > 2 && (e.cachedCharWidth = i), i || 10 } function bt(e) { e.curOp = { cm: e, viewChanged: !1, startHeight: e.doc.height, forceUpdate: !1, updateInput: null, typing: !1, changeObjs: null, cursorActivityHandlers: null, cursorActivityCalled: 0, selectionChanged: !1, updateMaxLine: !1, scrollLeft: null, scrollTop: null, scrollToPos: null, focus: !1, id: ++Yo }, Go ? Go.ops.push(e.curOp) : e.curOp.ownsGroup = Go = { ops: [e.curOp], delayedCallbacks: [] } } function wt(e) { var t = e.delayedCallbacks, n = 0; do { for (; n < t.length; n++)t[n].call(null); for (var r = 0; r < e.ops.length; r++) { var i = e.ops[r]; if (i.cursorActivityHandlers) for (; i.cursorActivityCalled < i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null, i.cm) } } while (n < t.length) } function kt(e) { var t = e.curOp, n = t.ownsGroup; if (n) try { wt(n) } finally { Go = null; for (var r = 0; r < n.ops.length; r++)n.ops[r].cm.curOp = null; St(n) } } function St(e) { for (var t = e.ops, n = 0; n < t.length; n++)Ct(t[n]); for (var n = 0; n < t.length; n++)Lt(t[n]); for (var n = 0; n < t.length; n++)Tt(t[n]); for (var n = 0; n < t.length; n++)Mt(t[n]); for (var n = 0; n < t.length; n++)Nt(t[n]) } function Ct(e) { var t = e.cm, n = t.display; T(t), e.updateMaxLine && h(t), e.mustUpdate = e.viewChanged || e.forceUpdate || null != e.scrollTop || e.scrollToPos && (e.scrollToPos.from.line < n.viewFrom || e.scrollToPos.to.line >= n.viewTo) || n.maxLineChanged && t.options.lineWrapping, e.update = e.mustUpdate && new L(t, e.mustUpdate && { top: e.scrollTop, ensure: e.scrollToPos }, e.forceUpdate) } function Lt(e) { e.updatedDisplay = e.mustUpdate && M(e.cm, e.update) } function Tt(e) { var t = e.cm, n = t.display; e.updatedDisplay && O(t), e.barMeasure = p(t), n.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = Je(t, n.maxLine, n.maxLine.text.length).left + 3, t.display.sizerWidth = e.adjustWidthTo, e.barMeasure.scrollWidth = Math.max(n.scroller.clientWidth, n.sizer.offsetLeft + e.adjustWidthTo + Ye(t) + t.display.barWidth), e.maxScrollLeft = Math.max(0, n.sizer.offsetLeft + e.adjustWidthTo - $e(t))), (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = n.input.prepareSelection(e.focus)) } function Mt(e) { var t = e.cm; null != e.adjustWidthTo && (t.display.sizer.style.minWidth = e.adjustWidthTo + "px", e.maxScrollLeft < t.doc.scrollLeft && on(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0), t.display.maxLineChanged = !1); var n = e.focus && e.focus == Gi() && (!document.hasFocus || document.hasFocus()); e.preparedSelection && t.display.input.showSelection(e.preparedSelection, n), (e.updatedDisplay || e.startHeight != t.doc.height) && y(t, e.barMeasure), e.updatedDisplay && E(t, e.barMeasure), e.selectionChanged && Be(t), t.state.focused && e.updateInput && t.display.input.reset(e.typing), n && X(e.cm) } function Nt(e) { var t = e.cm, n = t.display, r = t.doc; if (e.updatedDisplay && N(t, e.update), null == n.wheelStartX || null == e.scrollTop && null == e.scrollLeft && !e.scrollToPos || (n.wheelStartX = n.wheelStartY = null), null == e.scrollTop || n.scroller.scrollTop == e.scrollTop && !e.forceScroll || (r.scrollTop = Math.max(0, Math.min(n.scroller.scrollHeight - n.scroller.clientHeight, e.scrollTop)), n.scrollbars.setScrollTop(r.scrollTop), n.scroller.scrollTop = r.scrollTop), null == e.scrollLeft || n.scroller.scrollLeft == e.scrollLeft && !e.forceScroll || (r.scrollLeft = Math.max(0, Math.min(n.scroller.scrollWidth - n.scroller.clientWidth, e.scrollLeft)), n.scrollbars.setScrollLeft(r.scrollLeft), n.scroller.scrollLeft = r.scrollLeft, w(t)), e.scrollToPos) { var i = Rn(t, me(r, e.scrollToPos.from), me(r, e.scrollToPos.to), e.scrollToPos.margin); e.scrollToPos.isCursor && t.state.focused && Pn(t, i) } var o = e.maybeHiddenMarkers, a = e.maybeUnhiddenMarkers; if (o) for (var l = 0; l < o.length; ++l)o[l].lines.length || Pa(o[l], "hide"); if (a) for (var l = 0; l < a.length; ++l)a[l].lines.length && Pa(a[l], "unhide"); n.wrapper.offsetHeight && (r.scrollTop = t.display.scroller.scrollTop), e.changeObjs && Pa(t, "changes", t, e.changeObjs), e.update && e.update.finish() } function At(e, t) { if (e.curOp) return t(); bt(e); try { return t() } finally { kt(e) } } function Et(e, t) { return function () { if (e.curOp) return t.apply(e, arguments); bt(e); try { return t.apply(e, arguments) } finally { kt(e) } } } function Ot(e) { return function () { if (this.curOp) return e.apply(this, arguments); bt(this); try { return e.apply(this, arguments) } finally { kt(this) } } } function It(e) { return function () { var t = this.cm; if (!t || t.curOp) return e.apply(this, arguments); bt(t); try { return e.apply(this, arguments) } finally { kt(t) } } } function Pt(e, t, n) { this.line = t, this.rest = xr(t), this.size = this.rest ? ti(Ii(this.rest)) - n + 1 : 1, this.node = this.text = null, this.hidden = kr(e, t) } function Rt(e, t, n) { for (var r, i = [], o = t; n > o; o = r) { var a = new Pt(e.doc, Zr(e.doc, o), o); r = o + a.size, i.push(a) } return i } function Dt(e, t, n, r) { null == t && (t = e.doc.first), null == n && (n = e.doc.first + e.doc.size), r || (r = 0); var i = e.display; if (r && n < i.viewTo && (null == i.updateLineNumbers || i.updateLineNumbers > t) && (i.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= i.viewTo) Wo && br(e.doc, t) < i.viewTo && Wt(e); else if (n <= i.viewFrom) Wo && wr(e.doc, n + r) > i.viewFrom ? Wt(e) : (i.viewFrom += r, i.viewTo += r); else if (t <= i.viewFrom && n >= i.viewTo) Wt(e); else if (t <= i.viewFrom) { var o = _t(e, n, n + r, 1); o ? (i.view = i.view.slice(o.index), i.viewFrom = o.lineN, i.viewTo += r) : Wt(e) } else if (n >= i.viewTo) { var o = _t(e, t, t, -1); o ? (i.view = i.view.slice(0, o.index), i.viewTo = o.lineN) : Wt(e) } else { var a = _t(e, t, t, -1), l = _t(e, n, n + r, 1); a && l ? (i.view = i.view.slice(0, a.index).concat(Rt(e, a.lineN, l.lineN)).concat(i.view.slice(l.index)), i.viewTo += r) : Wt(e) } var s = i.externalMeasured; s && (n < s.lineN ? s.lineN += r : t < s.lineN + s.size && (i.externalMeasured = null)) } function Ht(e, t, n) { e.curOp.viewChanged = !0; var r = e.display, i = e.display.externalMeasured; if (i && t >= i.lineN && t < i.lineN + i.size && (r.externalMeasured = null), !(t < r.viewFrom || t >= r.viewTo)) { var o = r.view[Bt(e, t)]; if (null != o.node) { var a = o.changes || (o.changes = []); -1 == Pi(a, n) && a.push(n) } } } function Wt(e) { e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0 } function Bt(e, t) { if (t >= e.display.viewTo) return null; if (t -= e.display.viewFrom, 0 > t) return null; for (var n = e.display.view, r = 0; r < n.length; r++)if (t -= n[r].size, 0 > t) return r } function _t(e, t, n, r) { var i, o = Bt(e, t), a = e.display.view; if (!Wo || n == e.doc.first + e.doc.size) return { index: o, lineN: n }; for (var l = 0, s = e.display.viewFrom; o > l; l++)s += a[l].size; if (s != t) { if (r > 0) { if (o == a.length - 1) return null; i = s + a[o].size - t, o++ } else i = s - t; t += i, n += i } for (; br(e.doc, n) != n;) { if (o == (0 > r ? 0 : a.length - 1)) return null; n += r * a[o - (0 > r ? 1 : 0)].size, o += r } return { index: o, lineN: n } } function Ft(e, t, n) { var r = e.display, i = r.view; 0 == i.length || t >= r.viewTo || n <= r.viewFrom ? (r.view = Rt(e, t, n), r.viewFrom = t) : (r.viewFrom > t ? r.view = Rt(e, t, r.viewFrom).concat(r.view) : r.viewFrom < t && (r.view = r.view.slice(Bt(e, t))), r.viewFrom = t, r.viewTo < n ? r.view = r.view.concat(Rt(e, r.viewTo, n)) : r.viewTo > n && (r.view = r.view.slice(0, Bt(e, n)))), r.viewTo = n } function zt(e) { for (var t = e.display.view, n = 0, r = 0; r < t.length; r++) { var i = t[r]; i.hidden || i.node && !i.changes || ++n } return n } function jt(e) { function t() { i.activeTouch && (o = setTimeout(function () { i.activeTouch = null }, 1e3), a = i.activeTouch, a.end = +new Date) } function n(e) { if (1 != e.touches.length) return !1; var t = e.touches[0]; return t.radiusX <= 1 && t.radiusY <= 1 } function r(e, t) { if (null == t.left) return !0; var n = t.left - e.left, r = t.top - e.top; return n * n + r * r > 400 } var i = e.display; Ea(i.scroller, "mousedown", Et(e, $t)), xo && 11 > bo ? Ea(i.scroller, "dblclick", Et(e, function (t) { if (!Ti(e, t)) { var n = Yt(e, t); if (n && !Jt(e, t) && !Gt(e.display, t)) { Ma(t); var r = e.findWordAt(n); be(e.doc, r.anchor, r.head) } } })) : Ea(i.scroller, "dblclick", function (t) { Ti(e, t) || Ma(t) }), Do || Ea(i.scroller, "contextmenu", function (t) { xn(e, t) }); var o, a = { end: 0 }; Ea(i.scroller, "touchstart", function (t) { if (!Ti(e, t) && !n(t)) { clearTimeout(o); var r = +new Date; i.activeTouch = { start: r, moved: !1, prev: r - a.end <= 300 ? a : null }, 1 == t.touches.length && (i.activeTouch.left = t.touches[0].pageX, i.activeTouch.top = t.touches[0].pageY) } }), Ea(i.scroller, "touchmove", function () { i.activeTouch && (i.activeTouch.moved = !0) }), Ea(i.scroller, "touchend", function (n) { var o = i.activeTouch; if (o && !Gt(i, n) && null != o.left && !o.moved && new Date - o.start < 300) { var a, l = e.coordsChar(i.activeTouch, "page"); a = !o.prev || r(o, o.prev) ? new fe(l, l) : !o.prev.prev || r(o, o.prev.prev) ? e.findWordAt(l) : new fe(Bo(l.line, 0), me(e.doc, Bo(l.line + 1, 0))), e.setSelection(a.anchor, a.head), e.focus(), Ma(n) } t() }), Ea(i.scroller, "touchcancel", t), Ea(i.scroller, "scroll", function () { i.scroller.clientHeight && (rn(e, i.scroller.scrollTop), on(e, i.scroller.scrollLeft, !0), Pa(e, "scroll", e)) }), Ea(i.scroller, "mousewheel", function (t) { an(e, t) }), Ea(i.scroller, "DOMMouseScroll", function (t) { an(e, t) }), Ea(i.wrapper, "scroll", function () { i.wrapper.scrollTop = i.wrapper.scrollLeft = 0 }), i.dragFunctions = { enter: function (t) { Ti(e, t) || Aa(t) }, over: function (t) { Ti(e, t) || (tn(e, t), Aa(t)) }, start: function (t) { en(e, t) }, drop: Et(e, Qt), leave: function (t) { Ti(e, t) || nn(e) } }; var l = i.input.getField(); Ea(l, "keyup", function (t) { pn.call(e, t) }), Ea(l, "keydown", Et(e, hn)), Ea(l, "keypress", Et(e, mn)), Ea(l, "focus", Bi(vn, e)), Ea(l, "blur", Bi(yn, e)) } function Ut(t, n, r) { var i = r && r != e.Init; if (!n != !i) { var o = t.display.dragFunctions, a = n ? Ea : Ia; a(t.display.scroller, "dragstart", o.start), a(t.display.scroller, "dragenter", o.enter), a(t.display.scroller, "dragover", o.over), a(t.display.scroller, "dragleave", o.leave), a(t.display.scroller, "drop", o.drop) } } function qt(e) { var t = e.display; t.lastWrapHeight == t.wrapper.clientHeight && t.lastWrapWidth == t.wrapper.clientWidth || (t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize()) } function Gt(e, t) { for (var n = wi(t); n != e.wrapper; n = n.parentNode)if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == e.sizer && n != e.mover) return !0 } function Yt(e, t, n, r) { var i = e.display; if (!n && "true" == wi(t).getAttribute("cm-not-content")) return null; var o, a, l = i.lineSpace.getBoundingClientRect(); try { o = t.clientX - l.left, a = t.clientY - l.top } catch (t) { return null } var s, c = gt(e, o, a); if (r && 1 == c.xRel && (s = Zr(e.doc, c.line).text).length == c.ch) { var u = Fa(s, s.length, e.options.tabSize) - s.length; c = Bo(c.line, Math.max(0, Math.round((o - Ge(e.display).left) / xt(e.display)) - u)) } return c } function $t(e) { var t = this, n = t.display; if (!(Ti(t, e) || n.activeTouch && n.input.supportsTouch())) { if (n.shift = e.shiftKey, Gt(n, e)) return void (wo || (n.scroller.draggable = !1, setTimeout(function () { n.scroller.draggable = !0 }, 100))); if (!Jt(t, e)) { var r = Yt(t, e); switch (window.focus(), ki(e)) { case 1: t.state.selectingText ? t.state.selectingText(e) : r ? Vt(t, e, r) : wi(e) == n.scroller && Ma(e); break; case 2: wo && (t.state.lastMiddleDown = +new Date), r && be(t.doc, r), setTimeout(function () { n.input.focus() }, 20), Ma(e); break; case 3: Do ? xn(t, e) : gn(t) } } } } function Vt(e, t, n) { xo ? setTimeout(Bi(X, e), 0) : e.curOp.focus = Gi(); var r, i = +new Date; Uo && Uo.time > i - 400 && 0 == _o(Uo.pos, n) ? r = "triple" : jo && jo.time > i - 400 && 0 == _o(jo.pos, n) ? (r = "double", Uo = { time: i, pos: n }) : (r = "single", jo = { time: i, pos: n }); var o, a = e.doc.sel, l = Eo ? t.metaKey : t.ctrlKey; e.options.dragDrop && el && !e.isReadOnly() && "single" == r && (o = a.contains(n)) > -1 && (_o((o = a.ranges[o]).from(), n) < 0 || n.xRel > 0) && (_o(o.to(), n) > 0 || n.xRel < 0) ? Kt(e, t, n, l) : Xt(e, t, n, r, l) } function Kt(e, t, n, r) { var i = e.display, o = +new Date, a = Et(e, function (l) { wo && (i.scroller.draggable = !1), e.state.draggingText = !1, Ia(document, "mouseup", a), Ia(i.scroller, "drop", a), Math.abs(t.clientX - l.clientX) + Math.abs(t.clientY - l.clientY) < 10 && (Ma(l), !r && +new Date - 200 < o && be(e.doc, n), wo || xo && 9 == bo ? setTimeout(function () { document.body.focus(), i.input.focus() }, 20) : i.input.focus()) }); wo && (i.scroller.draggable = !0), e.state.draggingText = a, i.scroller.dragDrop && i.scroller.dragDrop(), Ea(document, "mouseup", a), Ea(i.scroller, "drop", a) } function Xt(e, t, n, r, i) { function o(t) { if (0 != _o(g, t)) if (g = t, "rect" == r) { for (var i = [], o = e.options.tabSize, a = Fa(Zr(c, n.line).text, n.ch, o), l = Fa(Zr(c, t.line).text, t.ch, o), s = Math.min(a, l), d = Math.max(a, l), p = Math.min(n.line, t.line), m = Math.min(e.lastLine(), Math.max(n.line, t.line)); m >= p; p++) { var v = Zr(c, p).text, y = za(v, s, o); s == d ? i.push(new fe(Bo(p, y), Bo(p, y))) : v.length > y && i.push(new fe(Bo(p, y), Bo(p, za(v, d, o)))) } i.length || i.push(new fe(n, n)), Te(c, he(h.ranges.slice(0, f).concat(i), f), { origin: "*mouse", scroll: !1 }), e.scrollIntoView(t) } else { var x = u, b = x.anchor, w = t; if ("single" != r) { if ("double" == r) var k = e.findWordAt(t); else var k = new fe(Bo(t.line, 0), me(c, Bo(t.line + 1, 0))); _o(k.anchor, b) > 0 ? (w = k.head, b = K(x.from(), k.anchor)) : (w = k.anchor, b = V(x.to(), k.head)) } var i = h.ranges.slice(0); i[f] = new fe(me(c, b), w), Te(c, he(i, f), Ba) } } function a(t) { var n = ++y, i = Yt(e, t, !0, "rect" == r); if (i) if (0 != _o(i, g)) { e.curOp.focus = Gi(), o(i); var l = b(s, c); (i.line >= l.to || i.line < l.from) && setTimeout(Et(e, function () { y == n && a(t) }), 150) } else { var u = t.clientY < v.top ? -20 : t.clientY > v.bottom ? 20 : 0; u && setTimeout(Et(e, function () { y == n && (s.scroller.scrollTop += u, a(t)) }), 50) } } function l(t) { e.state.selectingText = !1, y = 1 / 0, Ma(t), s.input.focus(), Ia(document, "mousemove", x), Ia(document, "mouseup", w), c.history.lastSelOrigin = null } var s = e.display, c = e.doc; Ma(t); var u, f, h = c.sel, d = h.ranges; if (i && !t.shiftKey ? (f = c.sel.contains(n), u = f > -1 ? d[f] : new fe(n, n)) : (u = c.sel.primary(), f = c.sel.primIndex), Oo ? t.shiftKey && t.metaKey : t.altKey) r = "rect", i || (u = new fe(n, n)), n = Yt(e, t, !0, !0), f = -1; else if ("double" == r) { var p = e.findWordAt(n); u = e.display.shift || c.extend ? xe(c, u, p.anchor, p.head) : p } else if ("triple" == r) { var m = new fe(Bo(n.line, 0), me(c, Bo(n.line + 1, 0))); u = e.display.shift || c.extend ? xe(c, u, m.anchor, m.head) : m } else u = xe(c, u, n); i ? -1 == f ? (f = d.length, Te(c, he(d.concat([u]), f), { scroll: !1, origin: "*mouse" })) : d.length > 1 && d[f].empty() && "single" == r && !t.shiftKey ? (Te(c, he(d.slice(0, f).concat(d.slice(f + 1)), 0), { scroll: !1, origin: "*mouse" }), h = c.sel) : ke(c, f, u, Ba) : (f = 0, Te(c, new ue([u], 0), Ba), h = c.sel); var g = n, v = s.wrapper.getBoundingClientRect(), y = 0, x = Et(e, function (e) { ki(e) ? a(e) : l(e) }), w = Et(e, l); e.state.selectingText = w, Ea(document, "mousemove", x), Ea(document, "mouseup", w) } function Zt(e, t, n, r) { try { var i = t.clientX, o = t.clientY } catch (t) { return !1 } if (i >= Math.floor(e.display.gutters.getBoundingClientRect().right)) return !1; r && Ma(t); var a = e.display, l = a.lineDiv.getBoundingClientRect(); if (o > l.bottom || !Ni(e, n)) return bi(t); o -= l.top - a.viewOffset; for (var s = 0; s < e.options.gutters.length; ++s) { var c = a.gutters.childNodes[s]; if (c && c.getBoundingClientRect().right >= i) { var u = ni(e.doc, o), f = e.options.gutters[s]; return Pa(e, n, e, u, f, t), bi(t) } } } function Jt(e, t) { return Zt(e, t, "gutterClick", !0) } function Qt(e) { var t = this; if (nn(t), !Ti(t, e) && !Gt(t.display, e)) { Ma(e), xo && ($o = +new Date); var n = Yt(t, e, !0), r = e.dataTransfer.files; if (n && !t.isReadOnly()) if (r && r.length && window.FileReader && window.File) for (var i = r.length, o = Array(i), a = 0, l = function (e, r) { if (!t.options.allowDropFileTypes || -1 != Pi(t.options.allowDropFileTypes, e.type)) { var l = new FileReader; l.onload = Et(t, function () { var e = l.result; if (/[\x00-\x08\x0e-\x1f]{2}/.test(e) && (e = ""), o[r] = e, ++a == i) { n = me(t.doc, n); var s = { from: n, to: n, text: t.doc.splitLines(o.join(t.doc.lineSeparator())), origin: "paste" }; Tn(t.doc, s), Le(t.doc, de(n, Qo(s))) } }), l.readAsText(e) } }, s = 0; i > s; ++s)l(r[s], s); else { if (t.state.draggingText && t.doc.sel.contains(n) > -1) return t.state.draggingText(e), void setTimeout(function () { t.display.input.focus() }, 20); try { var o = e.dataTransfer.getData("Text"); if (o) { if (t.state.draggingText && !(Eo ? e.altKey : e.ctrlKey)) var c = t.listSelections(); if (Me(t.doc, de(n, n)), c) for (var s = 0; s < c.length; ++s)In(t.doc, "", c[s].anchor, c[s].head, "drag"); t.replaceSelection(o, "around", "paste"), t.display.input.focus() } } catch (e) { } } } } function en(e, t) { if (xo && (!e.state.draggingText || +new Date - $o < 100)) return void Aa(t); if (!Ti(e, t) && !Gt(e.display, t) && (t.dataTransfer.setData("Text", e.getSelection()), t.dataTransfer.effectAllowed = "copyMove", t.dataTransfer.setDragImage && !Lo)) { var n = ji("img", null, null, "position: fixed; left: 0; top: 0;"); n.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", Co && (n.width = n.height = 1, e.display.wrapper.appendChild(n), n._top = n.offsetTop), t.dataTransfer.setDragImage(n, 0, 0), Co && n.parentNode.removeChild(n) } } function tn(e, t) { var n = Yt(e, t); if (n) { var r = document.createDocumentFragment(); He(e, n, r), e.display.dragCursor || (e.display.dragCursor = ji("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)), qi(e.display.dragCursor, r) } } function nn(e) { e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null) } function rn(e, t) { Math.abs(e.doc.scrollTop - t) < 2 || (e.doc.scrollTop = t, go || A(e, { top: t }), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t), e.display.scrollbars.setScrollTop(t), go && A(e), _e(e, 100)) } function on(e, t, n) { (n ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) || (t = Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth), e.doc.scrollLeft = t, w(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t)) } function an(e, t) { var n = Xo(t), r = n.x, i = n.y, o = e.display, a = o.scroller, l = a.scrollWidth > a.clientWidth, s = a.scrollHeight > a.clientHeight; if (r && l || i && s) { if (i && Eo && wo) e: for (var c = t.target, u = o.view; c != a; c = c.parentNode)for (var f = 0; f < u.length; f++)if (u[f].node == c) { e.display.currentWheelTarget = c; break e } if (r && !go && !Co && null != Ko) return i && s && rn(e, Math.max(0, Math.min(a.scrollTop + i * Ko, a.scrollHeight - a.clientHeight))), on(e, Math.max(0, Math.min(a.scrollLeft + r * Ko, a.scrollWidth - a.clientWidth))), (!i || i && s) && Ma(t), void (o.wheelStartX = null); if (i && null != Ko) { var h = i * Ko, d = e.doc.scrollTop, p = d + o.wrapper.clientHeight; 0 > h ? d = Math.max(0, d + h - 50) : p = Math.min(e.doc.height, p + h + 50), A(e, { top: d, bottom: p }) } 20 > Vo && (null == o.wheelStartX ? (o.wheelStartX = a.scrollLeft, o.wheelStartY = a.scrollTop, o.wheelDX = r, o.wheelDY = i, setTimeout(function () { if (null != o.wheelStartX) { var e = a.scrollLeft - o.wheelStartX, t = a.scrollTop - o.wheelStartY, n = t && o.wheelDY && t / o.wheelDY || e && o.wheelDX && e / o.wheelDX; o.wheelStartX = o.wheelStartY = null, n && (Ko = (Ko * Vo + n) / (Vo + 1), ++Vo) } }, 200)) : (o.wheelDX += r, o.wheelDY += i)) } } function ln(e, t, n) { if ("string" == typeof t && (t = ua[t], !t)) return !1; e.display.input.ensurePolled(); var r = e.display.shift, i = !1; try { e.isReadOnly() && (e.state.suppressEdits = !0), n && (e.display.shift = !1), i = t(e) != Ha } finally { e.display.shift = r, e.state.suppressEdits = !1 } return i } function sn(e, t, n) { for (var r = 0; r < e.state.keyMaps.length; r++) { var i = ha(t, e.state.keyMaps[r], n, e); if (i) return i } return e.options.extraKeys && ha(t, e.options.extraKeys, n, e) || ha(t, e.options.keyMap, n, e) } function cn(e, t, n, r) { var i = e.state.keySeq; if (i) { if (da(t)) return "handled"; Zo.set(50, function () { e.state.keySeq == i && (e.state.keySeq = null, e.display.input.reset()) }), t = i + " " + t } var o = sn(e, t, r); return "multi" == o && (e.state.keySeq = t), "handled" == o && Ci(e, "keyHandled", e, t, n), "handled" != o && "multi" != o || (Ma(n), Be(e)), i && !o && /\'$/.test(t) ? (Ma(n), !0) : !!o } function un(e, t) { var n = pa(t, !0); return n ? t.shiftKey && !e.state.keySeq ? cn(e, "Shift-" + n, t, function (t) { return ln(e, t, !0) }) || cn(e, n, t, function (t) { return ("string" == typeof t ? /^go[A-Z]/.test(t) : t.motion) ? ln(e, t) : void 0 }) : cn(e, n, t, function (t) { return ln(e, t) }) : !1 } function fn(e, t, n) { return cn(e, "'" + n + "'", t, function (t) { return ln(e, t, !0) }) } function hn(e) { var t = this; if (t.curOp.focus = Gi(), !Ti(t, e)) { xo && 11 > bo && 27 == e.keyCode && (e.returnValue = !1); var n = e.keyCode; t.display.shift = 16 == n || e.shiftKey; var r = un(t, e); Co && (Jo = r ? n : null, !r && 88 == n && !rl && (Eo ? e.metaKey : e.ctrlKey) && t.replaceSelection("", null, "cut")), 18 != n || /\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) || dn(t) } } function dn(e) { function t(e) { 18 != e.keyCode && e.altKey || (Za(n, "CodeMirror-crosshair"), Ia(document, "keyup", t), Ia(document, "mouseover", t)) } var n = e.display.lineDiv; Ja(n, "CodeMirror-crosshair"), Ea(document, "keyup", t), Ea(document, "mouseover", t) } function pn(e) { 16 == e.keyCode && (this.doc.sel.shift = !1), Ti(this, e) } function mn(e) { var t = this; if (!(Gt(t.display, e) || Ti(t, e) || e.ctrlKey && !e.altKey || Eo && e.metaKey)) { var n = e.keyCode, r = e.charCode; if (Co && n == Jo) return Jo = null, void Ma(e); if (!Co || e.which && !(e.which < 10) || !un(t, e)) { var i = String.fromCharCode(null == r ? n : r); fn(t, e, i) || t.display.input.onKeyPress(e) } } } function gn(e) { e.state.delayingBlurEvent = !0, setTimeout(function () { e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, yn(e)) }, 100) } function vn(e) { e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1), "nocursor" != e.options.readOnly && (e.state.focused || (Pa(e, "focus", e), e.state.focused = !0, Ja(e.display.wrapper, "CodeMirror-focused"), e.curOp || e.display.selForContextMenu == e.doc.sel || (e.display.input.reset(), wo && setTimeout(function () { e.display.input.reset(!0) }, 20)), e.display.input.receivedFocus()), Be(e)) } function yn(e) { e.state.delayingBlurEvent || (e.state.focused && (Pa(e, "blur", e), e.state.focused = !1, Za(e.display.wrapper, "CodeMirror-focused")), clearInterval(e.display.blinker), setTimeout(function () { e.state.focused || (e.display.shift = !1) }, 150)) } function xn(e, t) { Gt(e.display, t) || bn(e, t) || Ti(e, t, "contextmenu") || e.display.input.onContextMenu(t) } function bn(e, t) { return Ni(e, "gutterContextMenu") ? Zt(e, t, "gutterContextMenu", !1) : !1 } function wn(e, t) { if (_o(e, t.from) < 0) return e; if (_o(e, t.to) <= 0) return Qo(t); var n = e.line + t.text.length - (t.to.line - t.from.line) - 1, r = e.ch; return e.line == t.to.line && (r += Qo(t).ch - t.to.ch), Bo(n, r) } function kn(e, t) { for (var n = [], r = 0; r < e.sel.ranges.length; r++) { var i = e.sel.ranges[r]; n.push(new fe(wn(i.anchor, t), wn(i.head, t))) } return he(n, e.sel.primIndex) } function Sn(e, t, n) { return e.line == t.line ? Bo(n.line, e.ch - t.ch + n.ch) : Bo(n.line + (e.line - t.line), e.ch) } function Cn(e, t, n) { for (var r = [], i = Bo(e.first, 0), o = i, a = 0; a < t.length; a++) { var l = t[a], s = Sn(l.from, i, o), c = Sn(Qo(l), i, o); if (i = l.to, o = c, "around" == n) { var u = e.sel.ranges[a], f = _o(u.head, u.anchor) < 0; r[a] = new fe(f ? c : s, f ? s : c) } else r[a] = new fe(s, s) } return new ue(r, e.sel.primIndex) } function Ln(e, t, n) { var r = { canceled: !1, from: t.from, to: t.to, text: t.text, origin: t.origin, cancel: function () { this.canceled = !0 } }; return n && (r.update = function (t, n, r, i) { t && (this.from = me(e, t)), n && (this.to = me(e, n)), r && (this.text = r), void 0 !== i && (this.origin = i) }), Pa(e, "beforeChange", e, r), e.cm && Pa(e.cm, "beforeChange", e.cm, r), r.canceled ? null : { from: r.from, to: r.to, text: r.text, origin: r.origin } } function Tn(e, t, n) { if (e.cm) { if (!e.cm.curOp) return Et(e.cm, Tn)(e, t, n); if (e.cm.state.suppressEdits) return } if (!(Ni(e, "beforeChange") || e.cm && Ni(e.cm, "beforeChange")) || (t = Ln(e, t, !0))) { var r = Ho && !n && sr(e, t.from, t.to); if (r) for (var i = r.length - 1; i >= 0; --i)Mn(e, { from: r[i].from, to: r[i].to, text: i ? [""] : t.text }); else Mn(e, t) } } function Mn(e, t) { if (1 != t.text.length || "" != t.text[0] || 0 != _o(t.from, t.to)) { var n = kn(e, t); ci(e, t, n, e.cm ? e.cm.curOp.id : NaN), En(e, t, n, or(e, t)); var r = []; Kr(e, function (e, n) { n || -1 != Pi(r, e.history) || (xi(e.history, t), r.push(e.history)), En(e, t, null, or(e, t)) }) } } function Nn(e, t, n) { if (!e.cm || !e.cm.state.suppressEdits) { for (var r, i = e.history, o = e.sel, a = "undo" == t ? i.done : i.undone, l = "undo" == t ? i.undone : i.done, s = 0; s < a.length && (r = a[s], n ? !r.ranges || r.equals(e.sel) : r.ranges); s++); if (s != a.length) { for (i.lastOrigin = i.lastSelOrigin = null; r = a.pop(), r.ranges;) { if (hi(r, l), n && !r.equals(e.sel)) return void Te(e, r, { clearRedo: !1 }); o = r } var c = []; hi(o, l), l.push({ changes: c, generation: i.generation }), i.generation = r.generation || ++i.maxGeneration; for (var u = Ni(e, "beforeChange") || e.cm && Ni(e.cm, "beforeChange"), s = r.changes.length - 1; s >= 0; --s) { var f = r.changes[s]; if (f.origin = t, u && !Ln(e, f, !1)) return void (a.length = 0); c.push(ai(e, f)); var h = s ? kn(e, f) : Ii(a); En(e, f, h, lr(e, f)), !s && e.cm && e.cm.scrollIntoView({ from: f.from, to: Qo(f) }); var d = []; Kr(e, function (e, t) { t || -1 != Pi(d, e.history) || (xi(e.history, f), d.push(e.history)), En(e, f, null, lr(e, f)) }) } } } } function An(e, t) { if (0 != t && (e.first += t, e.sel = new ue(Ri(e.sel.ranges, function (e) { return new fe(Bo(e.anchor.line + t, e.anchor.ch), Bo(e.head.line + t, e.head.ch)) }), e.sel.primIndex), e.cm)) { Dt(e.cm, e.first, e.first - t, t); for (var n = e.cm.display, r = n.viewFrom; r < n.viewTo; r++)Ht(e.cm, r, "gutter") } } function En(e, t, n, r) { if (e.cm && !e.cm.curOp) return Et(e.cm, En)(e, t, n, r); if (t.to.line < e.first) return void An(e, t.text.length - 1 - (t.to.line - t.from.line)); if (!(t.from.line > e.lastLine())) { if (t.from.line < e.first) { var i = t.text.length - 1 - (e.first - t.from.line); An(e, i), t = { from: Bo(e.first, 0), to: Bo(t.to.line + i, t.to.ch), text: [Ii(t.text)], origin: t.origin } } var o = e.lastLine(); t.to.line > o && (t = { from: t.from, to: Bo(o, Zr(e, o).text.length), text: [t.text[0]], origin: t.origin }), t.removed = Jr(e, t.from, t.to), n || (n = kn(e, t)), e.cm ? On(e.cm, t, r) : Yr(e, t, r), Me(e, n, Wa) } } function On(e, t, n) { var r = e.doc, i = e.display, a = t.from, l = t.to, s = !1, c = a.line; e.options.lineWrapping || (c = ti(yr(Zr(r, a.line))), r.iter(c, l.line + 1, function (e) { return e == i.maxLine ? (s = !0, !0) : void 0 })), r.sel.contains(t.from, t.to) > -1 && Mi(e), Yr(r, t, n, o(e)), e.options.lineWrapping || (r.iter(c, a.line + t.text.length, function (e) { var t = f(e); t > i.maxLineLength && (i.maxLine = e, i.maxLineLength = t, i.maxLineChanged = !0, s = !1) }), s && (e.curOp.updateMaxLine = !0)), r.frontier = Math.min(r.frontier, a.line), _e(e, 400); var u = t.text.length - (l.line - a.line) - 1; t.full ? Dt(e) : a.line != l.line || 1 != t.text.length || Gr(e.doc, t) ? Dt(e, a.line, l.line + 1, u) : Ht(e, a.line, "text"); var h = Ni(e, "changes"), d = Ni(e, "change"); if (d || h) { var p = { from: a, to: l, text: t.text, removed: t.removed, origin: t.origin }; d && Ci(e, "change", e, p), h && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(p) } e.display.selForContextMenu = null } function In(e, t, n, r, i) { if (r || (r = n), _o(r, n) < 0) { var o = r; r = n, n = o } "string" == typeof t && (t = e.splitLines(t)), Tn(e, { from: n, to: r, text: t, origin: i }) } function Pn(e, t) { if (!Ti(e, "scrollCursorIntoView")) { var n = e.display, r = n.sizer.getBoundingClientRect(), i = null; if (t.top + r.top < 0 ? i = !0 : t.bottom + r.top > (window.innerHeight || document.documentElement.clientHeight) && (i = !1), null != i && !Mo) { var o = ji("div", "​", null, "position: absolute; top: " + (t.top - n.viewOffset - Ue(e.display)) + "px; height: " + (t.bottom - t.top + Ye(e) + n.barHeight) + "px; left: " + t.left + "px; width: 2px;"); e.display.lineSpace.appendChild(o), o.scrollIntoView(i), e.display.lineSpace.removeChild(o) } } } function Rn(e, t, n, r) { null == r && (r = 0); for (var i = 0; 5 > i; i++) { var o = !1, a = dt(e, t), l = n && n != t ? dt(e, n) : a, s = Hn(e, Math.min(a.left, l.left), Math.min(a.top, l.top) - r, Math.max(a.left, l.left), Math.max(a.bottom, l.bottom) + r), c = e.doc.scrollTop, u = e.doc.scrollLeft; if (null != s.scrollTop && (rn(e, s.scrollTop), Math.abs(e.doc.scrollTop - c) > 1 && (o = !0)), null != s.scrollLeft && (on(e, s.scrollLeft), Math.abs(e.doc.scrollLeft - u) > 1 && (o = !0)), !o) break } return a } function Dn(e, t, n, r, i) { var o = Hn(e, t, n, r, i); null != o.scrollTop && rn(e, o.scrollTop), null != o.scrollLeft && on(e, o.scrollLeft) } function Hn(e, t, n, r, i) { var o = e.display, a = yt(e.display); 0 > n && (n = 0); var l = e.curOp && null != e.curOp.scrollTop ? e.curOp.scrollTop : o.scroller.scrollTop, s = Ve(e), c = {}; i - n > s && (i = n + s); var u = e.doc.height + qe(o), f = a > n, h = i > u - a; if (l > n) c.scrollTop = f ? 0 : n; else if (i > l + s) { var d = Math.min(n, (h ? u : i) - s); d != l && (c.scrollTop = d) } var p = e.curOp && null != e.curOp.scrollLeft ? e.curOp.scrollLeft : o.scroller.scrollLeft, m = $e(e) - (e.options.fixedGutter ? o.gutters.offsetWidth : 0), g = r - t > m; return g && (r = t + m), 10 > t ? c.scrollLeft = 0 : p > t ? c.scrollLeft = Math.max(0, t - (g ? 0 : 10)) : r > m + p - 3 && (c.scrollLeft = r + (g ? 0 : 10) - m), c } function Wn(e, t, n) { null == t && null == n || _n(e), null != t && (e.curOp.scrollLeft = (null == e.curOp.scrollLeft ? e.doc.scrollLeft : e.curOp.scrollLeft) + t), null != n && (e.curOp.scrollTop = (null == e.curOp.scrollTop ? e.doc.scrollTop : e.curOp.scrollTop) + n) } function Bn(e) { _n(e); var t = e.getCursor(), n = t, r = t; e.options.lineWrapping || (n = t.ch ? Bo(t.line, t.ch - 1) : t, r = Bo(t.line, t.ch + 1)), e.curOp.scrollToPos = { from: n, to: r, margin: e.options.cursorScrollMargin, isCursor: !0 } } function _n(e) { var t = e.curOp.scrollToPos; if (t) { e.curOp.scrollToPos = null; var n = pt(e, t.from), r = pt(e, t.to), i = Hn(e, Math.min(n.left, r.left), Math.min(n.top, r.top) - t.margin, Math.max(n.right, r.right), Math.max(n.bottom, r.bottom) + t.margin); e.scrollTo(i.scrollLeft, i.scrollTop) } } function Fn(e, t, n, r) { var i, o = e.doc; null == n && (n = "add"), "smart" == n && (o.mode.indent ? i = je(e, t) : n = "prev"); var a = e.options.tabSize, l = Zr(o, t), s = Fa(l.text, null, a); l.stateAfter && (l.stateAfter = null); var c, u = l.text.match(/^\s*/)[0]; if (r || /\S/.test(l.text)) { if ("smart" == n && (c = o.mode.indent(i, l.text.slice(u.length), l.text), c == Ha || c > 150)) { if (!r) return; n = "prev" } } else c = 0, n = "not"; "prev" == n ? c = t > o.first ? Fa(Zr(o, t - 1).text, null, a) : 0 : "add" == n ? c = s + e.options.indentUnit : "subtract" == n ? c = s - e.options.indentUnit : "number" == typeof n && (c = s + n), c = Math.max(0, c); var f = "", h = 0; if (e.options.indentWithTabs) for (var d = Math.floor(c / a); d; --d)h += a, f += "	"; if (c > h && (f += Oi(c - h)), f != u) return In(o, f, Bo(t, 0), Bo(t, u.length), "+input"), l.stateAfter = null, !0; for (var d = 0; d < o.sel.ranges.length; d++) { var p = o.sel.ranges[d]; if (p.head.line == t && p.head.ch < u.length) { var h = Bo(t, u.length); ke(o, d, new fe(h, h)); break } } } function zn(e, t, n, r) { var i = t, o = t; return "number" == typeof t ? o = Zr(e, pe(e, t)) : i = ti(t), null == i ? null : (r(o, i) && e.cm && Ht(e.cm, i, n), o) } function jn(e, t) { for (var n = e.doc.sel.ranges, r = [], i = 0; i < n.length; i++) { for (var o = t(n[i]); r.length && _o(o.from, Ii(r).to) <= 0;) { var a = r.pop(); if (_o(a.from, o.from) < 0) { o.from = a.from; break } } r.push(o) } At(e, function () { for (var t = r.length - 1; t >= 0; t--)In(e.doc, "", r[t].from, r[t].to, "+delete"); Bn(e) }) } function Un(e, t, n, r, i) { function o() { var t = l + n; return t < e.first || t >= e.first + e.size ? !1 : (l = t, u = Zr(e, t)) } function a(e) { var t = (i ? fo : ho)(u, s, n, !0); if (null == t) { if (e || !o()) return !1; s = i ? (0 > n ? io : ro)(u) : 0 > n ? u.text.length : 0 } else s = t; return !0 } var l = t.line, s = t.ch, c = n, u = Zr(e, l); if ("char" == r) a(); else if ("column" == r) a(!0); else if ("word" == r || "group" == r) for (var f = null, h = "group" == r, d = e.cm && e.cm.getHelper(t, "wordChars"), p = !0; !(0 > n) || a(!p); p = !1) { var m = u.text.charAt(s) || "\n", g = _i(m, d) ? "w" : h && "\n" == m ? "n" : !h || /\s/.test(m) ? null : "p"; if (!h || p || g || (g = "s"), f && f != g) { 0 > n && (n = 1, a()); break } if (g && (f = g), n > 0 && !a(!p)) break } var v = Ie(e, Bo(l, s), t, c, !0); return _o(t, v) || (v.hitSide = !0), v } function qn(e, t, n, r) { var i, o = e.doc, a = t.left; if ("page" == r) { var l = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight); i = t.top + n * (l - (0 > n ? 1.5 : .5) * yt(e.display)) } else "line" == r && (i = n > 0 ? t.bottom + 3 : t.top - 3); for (; ;) { var s = gt(e, a, i); if (!s.outside) break; if (0 > n ? 0 >= i : i >= o.height) { s.hitSide = !0; break } i += 5 * n } return s } function Gn(t, n, r, i) { e.defaults[t] = n, r && (ta[t] = i ? function (e, t, n) { n != na && r(e, t, n) } : r) } function Yn(e) {
                    for (var t, n, r, i, o = e.split(/-(?!$)/), e = o[o.length - 1], a = 0; a < o.length - 1; a++) {
                        var l = o[a]; if (/^(cmd|meta|m)$/i.test(l)) i = !0; else if (/^a(lt)?$/i.test(l)) t = !0; else if (/^(c|ctrl|control)$/i.test(l)) n = !0; else {
                            if (!/^s(hift)$/i.test(l)) throw new Error("Unrecognized modifier name: " + l); r = !0
                        }
                    } return t && (e = "Alt-" + e), n && (e = "Ctrl-" + e), i && (e = "Cmd-" + e), r && (e = "Shift-" + e), e
                } function $n(e) { return "string" == typeof e ? fa[e] : e } function Vn(e, t, n, r, i) { if (r && r.shared) return Kn(e, t, n, r, i); if (e.cm && !e.cm.curOp) return Et(e.cm, Vn)(e, t, n, r, i); var o = new va(e, i), a = _o(t, n); if (r && Wi(r, o, !1), a > 0 || 0 == a && o.clearWhenEmpty !== !1) return o; if (o.replacedWith && (o.collapsed = !0, o.widgetNode = ji("span", [o.replacedWith], "CodeMirror-widget"), r.handleMouseEvents || o.widgetNode.setAttribute("cm-ignore-events", "true"), r.insertLeft && (o.widgetNode.insertLeft = !0)), o.collapsed) { if (vr(e, t.line, t, n, o) || t.line != n.line && vr(e, n.line, t, n, o)) throw new Error("Inserting collapsed marker partially overlapping an existing one"); Wo = !0 } o.addToHistory && ci(e, { from: t, to: n, origin: "markText" }, e.sel, NaN); var l, s = t.line, c = e.cm; if (e.iter(s, n.line + 1, function (e) { c && o.collapsed && !c.options.lineWrapping && yr(e) == c.display.maxLine && (l = !0), o.collapsed && s != t.line && ei(e, 0), nr(e, new Qn(o, s == t.line ? t.ch : null, s == n.line ? n.ch : null)), ++s }), o.collapsed && e.iter(t.line, n.line + 1, function (t) { kr(e, t) && ei(t, 0) }), o.clearOnEnter && Ea(o, "beforeCursorEnter", function () { o.clear() }), o.readOnly && (Ho = !0, (e.history.done.length || e.history.undone.length) && e.clearHistory()), o.collapsed && (o.id = ++ga, o.atomic = !0), c) { if (l && (c.curOp.updateMaxLine = !0), o.collapsed) Dt(c, t.line, n.line + 1); else if (o.className || o.title || o.startStyle || o.endStyle || o.css) for (var u = t.line; u <= n.line; u++)Ht(c, u, "text"); o.atomic && Ae(c.doc), Ci(c, "markerAdded", c, o) } return o } function Kn(e, t, n, r, i) { r = Wi(r), r.shared = !1; var o = [Vn(e, t, n, r, i)], a = o[0], l = r.widgetNode; return Kr(e, function (e) { l && (r.widgetNode = l.cloneNode(!0)), o.push(Vn(e, me(e, t), me(e, n), r, i)); for (var s = 0; s < e.linked.length; ++s)if (e.linked[s].isParent) return; a = Ii(o) }), new ya(o, a) } function Xn(e) { return e.findMarks(Bo(e.first, 0), e.clipPos(Bo(e.lastLine())), function (e) { return e.parent }) } function Zn(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n], i = r.find(), o = e.clipPos(i.from), a = e.clipPos(i.to); if (_o(o, a)) { var l = Vn(e, o, a, r.primary, r.primary.type); r.markers.push(l), l.parent = r } } } function Jn(e) { for (var t = 0; t < e.length; t++) { var n = e[t], r = [n.primary.doc]; Kr(n.primary.doc, function (e) { r.push(e) }); for (var i = 0; i < n.markers.length; i++) { var o = n.markers[i]; -1 == Pi(r, o.doc) && (o.parent = null, n.markers.splice(i--, 1)) } } } function Qn(e, t, n) { this.marker = e, this.from = t, this.to = n } function er(e, t) { if (e) for (var n = 0; n < e.length; ++n) { var r = e[n]; if (r.marker == t) return r } } function tr(e, t) { for (var n, r = 0; r < e.length; ++r)e[r] != t && (n || (n = [])).push(e[r]); return n } function nr(e, t) { e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], t.marker.attachLine(e) } function rr(e, t, n) { if (e) for (var r, i = 0; i < e.length; ++i) { var o = e[i], a = o.marker, l = null == o.from || (a.inclusiveLeft ? o.from <= t : o.from < t); if (l || o.from == t && "bookmark" == a.type && (!n || !o.marker.insertLeft)) { var s = null == o.to || (a.inclusiveRight ? o.to >= t : o.to > t); (r || (r = [])).push(new Qn(a, o.from, s ? null : o.to)) } } return r } function ir(e, t, n) { if (e) for (var r, i = 0; i < e.length; ++i) { var o = e[i], a = o.marker, l = null == o.to || (a.inclusiveRight ? o.to >= t : o.to > t); if (l || o.from == t && "bookmark" == a.type && (!n || o.marker.insertLeft)) { var s = null == o.from || (a.inclusiveLeft ? o.from <= t : o.from < t); (r || (r = [])).push(new Qn(a, s ? null : o.from - t, null == o.to ? null : o.to - t)) } } return r } function or(e, t) { if (t.full) return null; var n = ve(e, t.from.line) && Zr(e, t.from.line).markedSpans, r = ve(e, t.to.line) && Zr(e, t.to.line).markedSpans; if (!n && !r) return null; var i = t.from.ch, o = t.to.ch, a = 0 == _o(t.from, t.to), l = rr(n, i, a), s = ir(r, o, a), c = 1 == t.text.length, u = Ii(t.text).length + (c ? i : 0); if (l) for (var f = 0; f < l.length; ++f) { var h = l[f]; if (null == h.to) { var d = er(s, h.marker); d ? c && (h.to = null == d.to ? null : d.to + u) : h.to = i } } if (s) for (var f = 0; f < s.length; ++f) { var h = s[f]; if (null != h.to && (h.to += u), null == h.from) { var d = er(l, h.marker); d || (h.from = u, c && (l || (l = [])).push(h)) } else h.from += u, c && (l || (l = [])).push(h) } l && (l = ar(l)), s && s != l && (s = ar(s)); var p = [l]; if (!c) { var m, g = t.text.length - 2; if (g > 0 && l) for (var f = 0; f < l.length; ++f)null == l[f].to && (m || (m = [])).push(new Qn(l[f].marker, null, null)); for (var f = 0; g > f; ++f)p.push(m); p.push(s) } return p } function ar(e) { for (var t = 0; t < e.length; ++t) { var n = e[t]; null != n.from && n.from == n.to && n.marker.clearWhenEmpty !== !1 && e.splice(t--, 1) } return e.length ? e : null } function lr(e, t) { var n = mi(e, t), r = or(e, t); if (!n) return r; if (!r) return n; for (var i = 0; i < n.length; ++i) { var o = n[i], a = r[i]; if (o && a) e: for (var l = 0; l < a.length; ++l) { for (var s = a[l], c = 0; c < o.length; ++c)if (o[c].marker == s.marker) continue e; o.push(s) } else a && (n[i] = a) } return n } function sr(e, t, n) { var r = null; if (e.iter(t.line, n.line + 1, function (e) { if (e.markedSpans) for (var t = 0; t < e.markedSpans.length; ++t) { var n = e.markedSpans[t].marker; !n.readOnly || r && -1 != Pi(r, n) || (r || (r = [])).push(n) } }), !r) return null; for (var i = [{ from: t, to: n }], o = 0; o < r.length; ++o)for (var a = r[o], l = a.find(0), s = 0; s < i.length; ++s) { var c = i[s]; if (!(_o(c.to, l.from) < 0 || _o(c.from, l.to) > 0)) { var u = [s, 1], f = _o(c.from, l.from), h = _o(c.to, l.to); (0 > f || !a.inclusiveLeft && !f) && u.push({ from: c.from, to: l.from }), (h > 0 || !a.inclusiveRight && !h) && u.push({ from: l.to, to: c.to }), i.splice.apply(i, u), s += u.length - 1 } } return i } function cr(e) { var t = e.markedSpans; if (t) { for (var n = 0; n < t.length; ++n)t[n].marker.detachLine(e); e.markedSpans = null } } function ur(e, t) { if (t) { for (var n = 0; n < t.length; ++n)t[n].marker.attachLine(e); e.markedSpans = t } } function fr(e) { return e.inclusiveLeft ? -1 : 0 } function hr(e) { return e.inclusiveRight ? 1 : 0 } function dr(e, t) { var n = e.lines.length - t.lines.length; if (0 != n) return n; var r = e.find(), i = t.find(), o = _o(r.from, i.from) || fr(e) - fr(t); if (o) return -o; var a = _o(r.to, i.to) || hr(e) - hr(t); return a ? a : t.id - e.id } function pr(e, t) { var n, r = Wo && e.markedSpans; if (r) for (var i, o = 0; o < r.length; ++o)i = r[o], i.marker.collapsed && null == (t ? i.from : i.to) && (!n || dr(n, i.marker) < 0) && (n = i.marker); return n } function mr(e) { return pr(e, !0) } function gr(e) { return pr(e, !1) } function vr(e, t, n, r, i) { var o = Zr(e, t), a = Wo && o.markedSpans; if (a) for (var l = 0; l < a.length; ++l) { var s = a[l]; if (s.marker.collapsed) { var c = s.marker.find(0), u = _o(c.from, n) || fr(s.marker) - fr(i), f = _o(c.to, r) || hr(s.marker) - hr(i); if (!(u >= 0 && 0 >= f || 0 >= u && f >= 0) && (0 >= u && (s.marker.inclusiveRight && i.inclusiveLeft ? _o(c.to, n) >= 0 : _o(c.to, n) > 0) || u >= 0 && (s.marker.inclusiveRight && i.inclusiveLeft ? _o(c.from, r) <= 0 : _o(c.from, r) < 0))) return !0 } } } function yr(e) { for (var t; t = mr(e);)e = t.find(-1, !0).line; return e } function xr(e) { for (var t, n; t = gr(e);)e = t.find(1, !0).line, (n || (n = [])).push(e); return n } function br(e, t) { var n = Zr(e, t), r = yr(n); return n == r ? t : ti(r) } function wr(e, t) { if (t > e.lastLine()) return t; var n, r = Zr(e, t); if (!kr(e, r)) return t; for (; n = gr(r);)r = n.find(1, !0).line; return ti(r) + 1 } function kr(e, t) { var n = Wo && t.markedSpans; if (n) for (var r, i = 0; i < n.length; ++i)if (r = n[i], r.marker.collapsed) { if (null == r.from) return !0; if (!r.marker.widgetNode && 0 == r.from && r.marker.inclusiveLeft && Sr(e, t, r)) return !0 } } function Sr(e, t, n) { if (null == n.to) { var r = n.marker.find(1, !0); return Sr(e, r.line, er(r.line.markedSpans, n.marker)) } if (n.marker.inclusiveRight && n.to == t.text.length) return !0; for (var i, o = 0; o < t.markedSpans.length; ++o)if (i = t.markedSpans[o], i.marker.collapsed && !i.marker.widgetNode && i.from == n.to && (null == i.to || i.to != n.from) && (i.marker.inclusiveLeft || n.marker.inclusiveRight) && Sr(e, t, i)) return !0 } function Cr(e, t, n) { ri(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && Wn(e, null, n) } function Lr(e) { if (null != e.height) return e.height; var t = e.doc.cm; if (!t) return 0; if (!Va(document.body, e.node)) { var n = "position: relative;"; e.coverGutter && (n += "margin-left: -" + t.display.gutters.offsetWidth + "px;"), e.noHScroll && (n += "width: " + t.display.wrapper.clientWidth + "px;"), qi(t.display.measure, ji("div", [e.node], null, n)) } return e.height = e.node.parentNode.offsetHeight } function Tr(e, t, n, r) { var i = new xa(e, n, r), o = e.cm; return o && i.noHScroll && (o.display.alignWidgets = !0), zn(e, t, "widget", function (t) { var n = t.widgets || (t.widgets = []); if (null == i.insertAt ? n.push(i) : n.splice(Math.min(n.length - 1, Math.max(0, i.insertAt)), 0, i), i.line = t, o && !kr(e, t)) { var r = ri(t) < e.scrollTop; ei(t, t.height + Lr(i)), r && Wn(o, null, i.height), o.curOp.forceUpdate = !0 } return !0 }), i } function Mr(e, t, n, r) { e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), null != e.order && (e.order = null), cr(e), ur(e, n); var i = r ? r(e) : 1; i != e.height && ei(e, i) } function Nr(e) { e.parent = null, cr(e) } function Ar(e, t) { if (e) for (; ;) { var n = e.match(/(?:^|\s+)line-(background-)?(\S+)/); if (!n) break; e = e.slice(0, n.index) + e.slice(n.index + n[0].length); var r = n[1] ? "bgClass" : "textClass"; null == t[r] ? t[r] = n[2] : new RegExp("(?:^|s)" + n[2] + "(?:$|s)").test(t[r]) || (t[r] += " " + n[2]) } return e } function Er(t, n) { if (t.blankLine) return t.blankLine(n); if (t.innerMode) { var r = e.innerMode(t, n); return r.mode.blankLine ? r.mode.blankLine(r.state) : void 0 } } function Or(t, n, r, i) { for (var o = 0; 10 > o; o++) { i && (i[0] = e.innerMode(t, r).mode); var a = t.token(n, r); if (n.pos > n.start) return a } throw new Error("Mode " + t.name + " failed to advance stream.") } function Ir(e, t, n, r) { function i(e) { return { start: f.start, end: f.pos, string: f.current(), type: o || null, state: e ? sa(a.mode, u) : u } } var o, a = e.doc, l = a.mode; t = me(a, t); var s, c = Zr(a, t.line), u = je(e, t.line, n), f = new ma(c.text, e.options.tabSize); for (r && (s = []); (r || f.pos < t.ch) && !f.eol();)f.start = f.pos, o = Or(l, f, u), r && s.push(i(!0)); return r ? s : i() } function Pr(e, t, n, r, i, o, a) { var l = n.flattenSpans; null == l && (l = e.options.flattenSpans); var s, c = 0, u = null, f = new ma(t, e.options.tabSize), h = e.options.addModeClass && [null]; for ("" == t && Ar(Er(n, r), o); !f.eol();) { if (f.pos > e.options.maxHighlightLength ? (l = !1, a && Hr(e, t, r, f.pos), f.pos = t.length, s = null) : s = Ar(Or(n, f, r, h), o), h) { var d = h[0].name; d && (s = "m-" + (s ? d + " " + s : d)) } if (!l || u != s) { for (; c < f.start;)c = Math.min(f.start, c + 5e4), i(c, u); u = s } f.start = f.pos } for (; c < f.pos;) { var p = Math.min(f.pos, c + 5e4); i(p, u), c = p } } function Rr(e, t, n, r) { var i = [e.state.modeGen], o = {}; Pr(e, t.text, e.doc.mode, n, function (e, t) { i.push(e, t) }, o, r); for (var a = 0; a < e.state.overlays.length; ++a) { var l = e.state.overlays[a], s = 1, c = 0; Pr(e, t.text, l.mode, !0, function (e, t) { for (var n = s; e > c;) { var r = i[s]; r > e && i.splice(s, 1, e, i[s + 1], r), s += 2, c = Math.min(e, r) } if (t) if (l.opaque) i.splice(n, s - n, e, "cm-overlay " + t), s = n + 2; else for (; s > n; n += 2) { var o = i[n + 1]; i[n + 1] = (o ? o + " " : "") + "cm-overlay " + t } }, o) } return { styles: i, classes: o.bgClass || o.textClass ? o : null } } function Dr(e, t, n) { if (!t.styles || t.styles[0] != e.state.modeGen) { var r = je(e, ti(t)), i = Rr(e, t, t.text.length > e.options.maxHighlightLength ? sa(e.doc.mode, r) : r); t.stateAfter = r, t.styles = i.styles, i.classes ? t.styleClasses = i.classes : t.styleClasses && (t.styleClasses = null), n === e.doc.frontier && e.doc.frontier++ } return t.styles } function Hr(e, t, n, r) { var i = e.doc.mode, o = new ma(t, e.options.tabSize); for (o.start = o.pos = r || 0, "" == t && Er(i, n); !o.eol();)Or(i, o, n), o.start = o.pos } function Wr(e, t) { if (!e || /^\s*$/.test(e)) return null; var n = t.addModeClass ? ka : wa; return n[e] || (n[e] = e.replace(/\S+/g, "cm-$&")) } function Br(e, t) { var n = ji("span", null, null, wo ? "padding-right: .1px" : null), r = { pre: ji("pre", [n], "CodeMirror-line"), content: n, col: 0, pos: 0, cm: e, splitSpaces: (xo || wo) && e.getOption("lineWrapping") }; t.measure = {}; for (var i = 0; i <= (t.rest ? t.rest.length : 0); i++) { var o, a = i ? t.rest[i - 1] : t.line; r.pos = 0, r.addToken = Fr, Ji(e.display.measure) && (o = ii(a)) && (r.addToken = jr(r.addToken, o)), r.map = []; var l = t != e.display.externalMeasured && ti(a); qr(a, r, Dr(e, a, l)), a.styleClasses && (a.styleClasses.bgClass && (r.bgClass = $i(a.styleClasses.bgClass, r.bgClass || "")), a.styleClasses.textClass && (r.textClass = $i(a.styleClasses.textClass, r.textClass || ""))), 0 == r.map.length && r.map.push(0, 0, r.content.appendChild(Zi(e.display.measure))), 0 == i ? (t.measure.map = r.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(r.map), (t.measure.caches || (t.measure.caches = [])).push({})) } if (wo) { var s = r.content.lastChild; (/\bcm-tab\b/.test(s.className) || s.querySelector && s.querySelector(".cm-tab")) && (r.content.className = "cm-tab-wrap-hack") } return Pa(e, "renderLine", e, t.line, r.pre), r.pre.className && (r.textClass = $i(r.pre.className, r.textClass || "")), r } function _r(e) { var t = ji("span", "•", "cm-invalidchar"); return t.title = "\\u" + e.charCodeAt(0).toString(16), t.setAttribute("aria-label", t.title), t } function Fr(e, t, n, r, i, o, a) { if (t) { var l = e.splitSpaces ? t.replace(/ {3,}/g, zr) : t, s = e.cm.state.specialChars, c = !1; if (s.test(t)) for (var u = document.createDocumentFragment(), f = 0; ;) { s.lastIndex = f; var h = s.exec(t), d = h ? h.index - f : t.length - f; if (d) { var p = document.createTextNode(l.slice(f, f + d)); xo && 9 > bo ? u.appendChild(ji("span", [p])) : u.appendChild(p), e.map.push(e.pos, e.pos + d, p), e.col += d, e.pos += d } if (!h) break; if (f += d + 1, "	" == h[0]) { var m = e.cm.options.tabSize, g = m - e.col % m, p = u.appendChild(ji("span", Oi(g), "cm-tab")); p.setAttribute("role", "presentation"), p.setAttribute("cm-text", "	"), e.col += g } else if ("\r" == h[0] || "\n" == h[0]) { var p = u.appendChild(ji("span", "\r" == h[0] ? "␍" : "␤", "cm-invalidchar")); p.setAttribute("cm-text", h[0]), e.col += 1 } else { var p = e.cm.options.specialCharPlaceholder(h[0]); p.setAttribute("cm-text", h[0]), xo && 9 > bo ? u.appendChild(ji("span", [p])) : u.appendChild(p), e.col += 1 } e.map.push(e.pos, e.pos + 1, p), e.pos++ } else { e.col += t.length; var u = document.createTextNode(l); e.map.push(e.pos, e.pos + t.length, u), xo && 9 > bo && (c = !0), e.pos += t.length } if (n || r || i || c || a) { var v = n || ""; r && (v += r), i && (v += i); var y = ji("span", [u], v, a); return o && (y.title = o), e.content.appendChild(y) } e.content.appendChild(u) } } function zr(e) { for (var t = " ", n = 0; n < e.length - 2; ++n)t += n % 2 ? " " : " "; return t += " " } function jr(e, t) { return function (n, r, i, o, a, l, s) { i = i ? i + " cm-force-border" : "cm-force-border"; for (var c = n.pos, u = c + r.length; ;) { for (var f = 0; f < t.length; f++) { var h = t[f]; if (h.to > c && h.from <= c) break } if (h.to >= u) return e(n, r, i, o, a, l, s); e(n, r.slice(0, h.to - c), i, o, null, l, s), o = null, r = r.slice(h.to - c), c = h.to } } } function Ur(e, t, n, r) { var i = !r && n.widgetNode; i && e.map.push(e.pos, e.pos + t, i), !r && e.cm.display.input.needsContentAttribute && (i || (i = e.content.appendChild(document.createElement("span"))), i.setAttribute("cm-marker", n.id)), i && (e.cm.display.input.setUneditable(i), e.content.appendChild(i)), e.pos += t } function qr(e, t, n) { var r = e.markedSpans, i = e.text, o = 0; if (r) for (var a, l, s, c, u, f, h, d = i.length, p = 0, m = 1, g = "", v = 0; ;) { if (v == p) { s = c = u = f = l = "", h = null, v = 1 / 0; for (var y, x = [], b = 0; b < r.length; ++b) { var w = r[b], k = w.marker; "bookmark" == k.type && w.from == p && k.widgetNode ? x.push(k) : w.from <= p && (null == w.to || w.to > p || k.collapsed && w.to == p && w.from == p) ? (null != w.to && w.to != p && v > w.to && (v = w.to, c = ""), k.className && (s += " " + k.className), k.css && (l = (l ? l + ";" : "") + k.css), k.startStyle && w.from == p && (u += " " + k.startStyle), k.endStyle && w.to == v && (y || (y = [])).push(k.endStyle, w.to), k.title && !f && (f = k.title), k.collapsed && (!h || dr(h.marker, k) < 0) && (h = w)) : w.from > p && v > w.from && (v = w.from) } if (y) for (var b = 0; b < y.length; b += 2)y[b + 1] == v && (c += " " + y[b]); if (!h || h.from == p) for (var b = 0; b < x.length; ++b)Ur(t, 0, x[b]); if (h && (h.from || 0) == p) { if (Ur(t, (null == h.to ? d + 1 : h.to) - p, h.marker, null == h.from), null == h.to) return; h.to == p && (h = !1) } } if (p >= d) break; for (var S = Math.min(d, v); ;) { if (g) { var C = p + g.length; if (!h) { var L = C > S ? g.slice(0, S - p) : g; t.addToken(t, L, a ? a + s : s, u, p + L.length == v ? c : "", f, l) } if (C >= S) { g = g.slice(S - p), p = S; break } p = C, u = "" } g = i.slice(o, o = n[m++]), a = Wr(n[m++], t.cm.options) } } else for (var m = 1; m < n.length; m += 2)t.addToken(t, i.slice(o, o = n[m]), Wr(n[m + 1], t.cm.options)) } function Gr(e, t) { return 0 == t.from.ch && 0 == t.to.ch && "" == Ii(t.text) && (!e.cm || e.cm.options.wholeLineUpdateBefore) } function Yr(e, t, n, r) { function i(e) { return n ? n[e] : null } function o(e, n, i) { Mr(e, n, i, r), Ci(e, "change", e, t) } function a(e, t) { for (var n = e, o = []; t > n; ++n)o.push(new ba(c[n], i(n), r)); return o } var l = t.from, s = t.to, c = t.text, u = Zr(e, l.line), f = Zr(e, s.line), h = Ii(c), d = i(c.length - 1), p = s.line - l.line; if (t.full) e.insert(0, a(0, c.length)), e.remove(c.length, e.size - c.length); else if (Gr(e, t)) { var m = a(0, c.length - 1); o(f, f.text, d), p && e.remove(l.line, p), m.length && e.insert(l.line, m) } else if (u == f) if (1 == c.length) o(u, u.text.slice(0, l.ch) + h + u.text.slice(s.ch), d); else { var m = a(1, c.length - 1); m.push(new ba(h + u.text.slice(s.ch), d, r)), o(u, u.text.slice(0, l.ch) + c[0], i(0)), e.insert(l.line + 1, m) } else if (1 == c.length) o(u, u.text.slice(0, l.ch) + c[0] + f.text.slice(s.ch), i(0)), e.remove(l.line + 1, p); else { o(u, u.text.slice(0, l.ch) + c[0], i(0)), o(f, h + f.text.slice(s.ch), d); var m = a(1, c.length - 1); p > 1 && e.remove(l.line + 1, p - 1), e.insert(l.line + 1, m) } Ci(e, "change", e, t) } function $r(e) { this.lines = e, this.parent = null; for (var t = 0, n = 0; t < e.length; ++t)e[t].parent = this, n += e[t].height; this.height = n } function Vr(e) { this.children = e; for (var t = 0, n = 0, r = 0; r < e.length; ++r) { var i = e[r]; t += i.chunkSize(), n += i.height, i.parent = this } this.size = t, this.height = n, this.parent = null } function Kr(e, t, n) { function r(e, i, o) { if (e.linked) for (var a = 0; a < e.linked.length; ++a) { var l = e.linked[a]; if (l.doc != i) { var s = o && l.sharedHist; n && !s || (t(l.doc, s), r(l.doc, e, s)) } } } r(e, null, !0) } function Xr(e, t) { if (t.cm) throw new Error("This document is already in use."); e.doc = t, t.cm = e, a(e), n(e), e.options.lineWrapping || h(e), e.options.mode = t.modeOption, Dt(e) } function Zr(e, t) { if (t -= e.first, 0 > t || t >= e.size) throw new Error("There is no line " + (t + e.first) + " in the document."); for (var n = e; !n.lines;)for (var r = 0; ; ++r) { var i = n.children[r], o = i.chunkSize(); if (o > t) { n = i; break } t -= o } return n.lines[t] } function Jr(e, t, n) { var r = [], i = t.line; return e.iter(t.line, n.line + 1, function (e) { var o = e.text; i == n.line && (o = o.slice(0, n.ch)), i == t.line && (o = o.slice(t.ch)), r.push(o), ++i }), r } function Qr(e, t, n) { var r = []; return e.iter(t, n, function (e) { r.push(e.text) }), r } function ei(e, t) { var n = t - e.height; if (n) for (var r = e; r; r = r.parent)r.height += n } function ti(e) { if (null == e.parent) return null; for (var t = e.parent, n = Pi(t.lines, e), r = t.parent; r; t = r, r = r.parent)for (var i = 0; r.children[i] != t; ++i)n += r.children[i].chunkSize(); return n + t.first } function ni(e, t) { var n = e.first; e: do { for (var r = 0; r < e.children.length; ++r) { var i = e.children[r], o = i.height; if (o > t) { e = i; continue e } t -= o, n += i.chunkSize() } return n } while (!e.lines); for (var r = 0; r < e.lines.length; ++r) { var a = e.lines[r], l = a.height; if (l > t) break; t -= l } return n + r } function ri(e) { e = yr(e); for (var t = 0, n = e.parent, r = 0; r < n.lines.length; ++r) { var i = n.lines[r]; if (i == e) break; t += i.height } for (var o = n.parent; o; n = o, o = n.parent)for (var r = 0; r < o.children.length; ++r) { var a = o.children[r]; if (a == n) break; t += a.height } return t } function ii(e) { var t = e.order; return null == t && (t = e.order = ll(e.text)), t } function oi(e) { this.done = [], this.undone = [], this.undoDepth = 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e || 1 } function ai(e, t) { var n = { from: $(t.from), to: Qo(t), text: Jr(e, t.from, t.to) }; return di(e, n, t.from.line, t.to.line + 1), Kr(e, function (e) { di(e, n, t.from.line, t.to.line + 1) }, !0), n } function li(e) { for (; e.length;) { var t = Ii(e); if (!t.ranges) break; e.pop() } } function si(e, t) { return t ? (li(e.done), Ii(e.done)) : e.done.length && !Ii(e.done).ranges ? Ii(e.done) : e.done.length > 1 && !e.done[e.done.length - 2].ranges ? (e.done.pop(), Ii(e.done)) : void 0 } function ci(e, t, n, r) { var i = e.history; i.undone.length = 0; var o, a = +new Date; if ((i.lastOp == r || i.lastOrigin == t.origin && t.origin && ("+" == t.origin.charAt(0) && e.cm && i.lastModTime > a - e.cm.options.historyEventDelay || "*" == t.origin.charAt(0))) && (o = si(i, i.lastOp == r))) { var l = Ii(o.changes); 0 == _o(t.from, t.to) && 0 == _o(t.from, l.to) ? l.to = Qo(t) : o.changes.push(ai(e, t)) } else { var s = Ii(i.done); for (s && s.ranges || hi(e.sel, i.done), o = { changes: [ai(e, t)], generation: i.generation }, i.done.push(o); i.done.length > i.undoDepth;)i.done.shift(), i.done[0].ranges || i.done.shift() } i.done.push(n), i.generation = ++i.maxGeneration, i.lastModTime = i.lastSelTime = a, i.lastOp = i.lastSelOp = r, i.lastOrigin = i.lastSelOrigin = t.origin, l || Pa(e, "historyAdded") } function ui(e, t, n, r) { var i = t.charAt(0); return "*" == i || "+" == i && n.ranges.length == r.ranges.length && n.somethingSelected() == r.somethingSelected() && new Date - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500) } function fi(e, t, n, r) { var i = e.history, o = r && r.origin; n == i.lastSelOp || o && i.lastSelOrigin == o && (i.lastModTime == i.lastSelTime && i.lastOrigin == o || ui(e, o, Ii(i.done), t)) ? i.done[i.done.length - 1] = t : hi(t, i.done), i.lastSelTime = +new Date, i.lastSelOrigin = o, i.lastSelOp = n, r && r.clearRedo !== !1 && li(i.undone) } function hi(e, t) { var n = Ii(t); n && n.ranges && n.equals(e) || t.push(e) } function di(e, t, n, r) { var i = t["spans_" + e.id], o = 0; e.iter(Math.max(e.first, n), Math.min(e.first + e.size, r), function (n) { n.markedSpans && ((i || (i = t["spans_" + e.id] = {}))[o] = n.markedSpans), ++o }) } function pi(e) { if (!e) return null; for (var t, n = 0; n < e.length; ++n)e[n].marker.explicitlyCleared ? t || (t = e.slice(0, n)) : t && t.push(e[n]); return t ? t.length ? t : null : e } function mi(e, t) { var n = t["spans_" + e.id]; if (!n) return null; for (var r = 0, i = []; r < t.text.length; ++r)i.push(pi(n[r])); return i } function gi(e, t, n) { for (var r = 0, i = []; r < e.length; ++r) { var o = e[r]; if (o.ranges) i.push(n ? ue.prototype.deepCopy.call(o) : o); else { var a = o.changes, l = []; i.push({ changes: l }); for (var s = 0; s < a.length; ++s) { var c, u = a[s]; if (l.push({ from: u.from, to: u.to, text: u.text }), t) for (var f in u) (c = f.match(/^spans_(\d+)$/)) && Pi(t, Number(c[1])) > -1 && (Ii(l)[f] = u[f], delete u[f]) } } } return i } function vi(e, t, n, r) { n < e.line ? e.line += r : t < e.line && (e.line = t, e.ch = 0) } function yi(e, t, n, r) { for (var i = 0; i < e.length; ++i) { var o = e[i], a = !0; if (o.ranges) { o.copied || (o = e[i] = o.deepCopy(), o.copied = !0); for (var l = 0; l < o.ranges.length; l++)vi(o.ranges[l].anchor, t, n, r), vi(o.ranges[l].head, t, n, r) } else { for (var l = 0; l < o.changes.length; ++l) { var s = o.changes[l]; if (n < s.from.line) s.from = Bo(s.from.line + r, s.from.ch), s.to = Bo(s.to.line + r, s.to.ch); else if (t <= s.to.line) { a = !1; break } } a || (e.splice(0, i + 1), i = 0) } } } function xi(e, t) { var n = t.from.line, r = t.to.line, i = t.text.length - (r - n) - 1; yi(e.done, n, r, i), yi(e.undone, n, r, i) } function bi(e) { return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue } function wi(e) { return e.target || e.srcElement } function ki(e) { var t = e.which; return null == t && (1 & e.button ? t = 1 : 2 & e.button ? t = 3 : 4 & e.button && (t = 2)), Eo && e.ctrlKey && 1 == t && (t = 3), t } function Si(e, t, n) { var r = e._handlers && e._handlers[t]; return n ? r && r.length > 0 ? r.slice() : Oa : r || Oa } function Ci(e, t) { function n(e) { return function () { e.apply(null, o) } } var r = Si(e, t, !1); if (r.length) { var i, o = Array.prototype.slice.call(arguments, 2); Go ? i = Go.delayedCallbacks : Ra ? i = Ra : (i = Ra = [], setTimeout(Li, 0)); for (var a = 0; a < r.length; ++a)i.push(n(r[a])) } } function Li() { var e = Ra; Ra = null; for (var t = 0; t < e.length; ++t)e[t]() } function Ti(e, t, n) { return "string" == typeof t && (t = { type: t, preventDefault: function () { this.defaultPrevented = !0 } }), Pa(e, n || t.type, e, t), bi(t) || t.codemirrorIgnore } function Mi(e) { var t = e._handlers && e._handlers.cursorActivity; if (t) for (var n = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []), r = 0; r < t.length; ++r)-1 == Pi(n, t[r]) && n.push(t[r]) } function Ni(e, t) { return Si(e, t).length > 0 } function Ai(e) { e.prototype.on = function (e, t) { Ea(this, e, t) }, e.prototype.off = function (e, t) { Ia(this, e, t) } } function Ei() { this.id = null } function Oi(e) { for (; ja.length <= e;)ja.push(Ii(ja) + " "); return ja[e] } function Ii(e) { return e[e.length - 1] } function Pi(e, t) { for (var n = 0; n < e.length; ++n)if (e[n] == t) return n; return -1 } function Ri(e, t) { for (var n = [], r = 0; r < e.length; r++)n[r] = t(e[r], r); return n } function Di() { } function Hi(e, t) { var n; return Object.create ? n = Object.create(e) : (Di.prototype = e, n = new Di), t && Wi(t, n), n } function Wi(e, t, n) { t || (t = {}); for (var r in e) !e.hasOwnProperty(r) || n === !1 && t.hasOwnProperty(r) || (t[r] = e[r]); return t } function Bi(e) { var t = Array.prototype.slice.call(arguments, 1); return function () { return e.apply(null, t) } } function _i(e, t) { return t ? t.source.indexOf("\\w") > -1 && Ya(e) ? !0 : t.test(e) : Ya(e) } function Fi(e) { for (var t in e) if (e.hasOwnProperty(t) && e[t]) return !1; return !0 } function zi(e) { return e.charCodeAt(0) >= 768 && $a.test(e) } function ji(e, t, n, r) { var i = document.createElement(e); if (n && (i.className = n), r && (i.style.cssText = r), "string" == typeof t) i.appendChild(document.createTextNode(t)); else if (t) for (var o = 0; o < t.length; ++o)i.appendChild(t[o]); return i } function Ui(e) { for (var t = e.childNodes.length; t > 0; --t)e.removeChild(e.firstChild); return e } function qi(e, t) { return Ui(e).appendChild(t) } function Gi() { for (var e = document.activeElement; e && e.root && e.root.activeElement;)e = e.root.activeElement; return e } function Yi(e) { return new RegExp("(^|\\s)" + e + "(?:$|\\s)\\s*") } function $i(e, t) { for (var n = e.split(" "), r = 0; r < n.length; r++)n[r] && !Yi(n[r]).test(t) && (t += " " + n[r]); return t } function Vi(e) { if (document.body.getElementsByClassName) for (var t = document.body.getElementsByClassName("CodeMirror"), n = 0; n < t.length; n++) { var r = t[n].CodeMirror; r && e(r) } } function Ki() { Qa || (Xi(), Qa = !0) } function Xi() { var e; Ea(window, "resize", function () { null == e && (e = setTimeout(function () { e = null, Vi(qt) }, 100)) }), Ea(window, "blur", function () { Vi(yn) }) } function Zi(e) { if (null == Ka) { var t = ji("span", "​"); qi(e, ji("span", [t, document.createTextNode("x")])), 0 != e.firstChild.offsetHeight && (Ka = t.offsetWidth <= 1 && t.offsetHeight > 2 && !(xo && 8 > bo)) } var n = Ka ? ji("span", "​") : ji("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px"); return n.setAttribute("cm-text", ""), n } function Ji(e) { if (null != Xa) return Xa; var t = qi(e, document.createTextNode("AخA")), n = qa(t, 0, 1).getBoundingClientRect(); if (!n || n.left == n.right) return !1; var r = qa(t, 1, 2).getBoundingClientRect(); return Xa = r.right - n.right < 3 } function Qi(e) { if (null != il) return il; var t = qi(e, ji("span", "x")), n = t.getBoundingClientRect(), r = qa(t, 0, 1).getBoundingClientRect(); return il = Math.abs(n.left - r.left) > 1 } function eo(e, t, n, r) { if (!e) return r(t, n, "ltr"); for (var i = !1, o = 0; o < e.length; ++o) { var a = e[o]; (a.from < n && a.to > t || t == n && a.to == t) && (r(Math.max(a.from, t), Math.min(a.to, n), 1 == a.level ? "rtl" : "ltr"), i = !0) } i || r(t, n, "ltr") } function to(e) { return e.level % 2 ? e.to : e.from } function no(e) { return e.level % 2 ? e.from : e.to } function ro(e) { var t = ii(e); return t ? to(t[0]) : 0 } function io(e) { var t = ii(e); return t ? no(Ii(t)) : e.text.length } function oo(e, t) { var n = Zr(e.doc, t), r = yr(n); r != n && (t = ti(r)); var i = ii(r), o = i ? i[0].level % 2 ? io(r) : ro(r) : 0; return Bo(t, o) } function ao(e, t) { for (var n, r = Zr(e.doc, t); n = gr(r);)r = n.find(1, !0).line, t = null; var i = ii(r), o = i ? i[0].level % 2 ? ro(r) : io(r) : r.text.length; return Bo(null == t ? ti(r) : t, o) } function lo(e, t) { var n = oo(e, t.line), r = Zr(e.doc, n.line), i = ii(r); if (!i || 0 == i[0].level) { var o = Math.max(0, r.text.search(/\S/)), a = t.line == n.line && t.ch <= o && t.ch; return Bo(n.line, a ? 0 : o) } return n } function so(e, t, n) { var r = e[0].level; return t == r ? !0 : n == r ? !1 : n > t } function co(e, t) { al = null; for (var n, r = 0; r < e.length; ++r) { var i = e[r]; if (i.from < t && i.to > t) return r; if (i.from == t || i.to == t) { if (null != n) return so(e, i.level, e[n].level) ? (i.from != i.to && (al = n), r) : (i.from != i.to && (al = r), n); n = r } } return n } function uo(e, t, n, r) { if (!r) return t + n; do t += n; while (t > 0 && zi(e.text.charAt(t))); return t } function fo(e, t, n, r) { var i = ii(e); if (!i) return ho(e, t, n, r); for (var o = co(i, t), a = i[o], l = uo(e, t, a.level % 2 ? -n : n, r); ;) { if (l > a.from && l < a.to) return l; if (l == a.from || l == a.to) return co(i, l) == o ? l : (a = i[o += n], n > 0 == a.level % 2 ? a.to : a.from); if (a = i[o += n], !a) return null; l = n > 0 == a.level % 2 ? uo(e, a.to, -1, r) : uo(e, a.from, 1, r) } } function ho(e, t, n, r) { var i = t + n; if (r) for (; i > 0 && zi(e.text.charAt(i));)i += n; return 0 > i || i > e.text.length ? null : i } var po = navigator.userAgent, mo = navigator.platform, go = /gecko\/\d/i.test(po), vo = /MSIE \d/.test(po), yo = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(po), xo = vo || yo, bo = xo && (vo ? document.documentMode || 6 : yo[1]), wo = /WebKit\//.test(po), ko = wo && /Qt\/\d+\.\d+/.test(po), So = /Chrome\//.test(po), Co = /Opera\//.test(po), Lo = /Apple Computer/.test(navigator.vendor), To = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(po), Mo = /PhantomJS/.test(po), No = /AppleWebKit/.test(po) && /Mobile\/\w+/.test(po), Ao = No || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(po), Eo = No || /Mac/.test(mo), Oo = /\bCrOS\b/.test(po), Io = /win/i.test(mo), Po = Co && po.match(/Version\/(\d*\.\d*)/); Po && (Po = Number(Po[1])), Po && Po >= 15 && (Co = !1, wo = !0); var Ro = Eo && (ko || Co && (null == Po || 12.11 > Po)), Do = go || xo && bo >= 9, Ho = !1, Wo = !1; m.prototype = Wi({ update: function (e) { var t = e.scrollWidth > e.clientWidth + 1, n = e.scrollHeight > e.clientHeight + 1, r = e.nativeBarWidth; if (n) { this.vert.style.display = "block", this.vert.style.bottom = t ? r + "px" : "0"; var i = e.viewHeight - (t ? r : 0); this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + i) + "px" } else this.vert.style.display = "", this.vert.firstChild.style.height = "0"; if (t) { this.horiz.style.display = "block", this.horiz.style.right = n ? r + "px" : "0", this.horiz.style.left = e.barLeft + "px"; var o = e.viewWidth - e.barLeft - (n ? r : 0); this.horiz.firstChild.style.width = e.scrollWidth - e.clientWidth + o + "px" } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0"; return !this.checkedZeroWidth && e.clientHeight > 0 && (0 == r && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: n ? r : 0, bottom: t ? r : 0 } }, setScrollLeft: function (e) { this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz) }, setScrollTop: function (e) { this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert) }, zeroWidthHack: function () { var e = Eo && !To ? "12px" : "18px"; this.horiz.style.height = this.vert.style.width = e, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", this.disableHoriz = new Ei, this.disableVert = new Ei }, enableZeroWidthBar: function (e, t) { function n() { var r = e.getBoundingClientRect(), i = document.elementFromPoint(r.left + 1, r.bottom - 1); i != e ? e.style.pointerEvents = "none" : t.set(1e3, n) } e.style.pointerEvents = "auto", t.set(1e3, n) }, clear: function () { var e = this.horiz.parentNode; e.removeChild(this.horiz), e.removeChild(this.vert) } }, m.prototype), g.prototype = Wi({ update: function () { return { bottom: 0, right: 0 } }, setScrollLeft: function () { }, setScrollTop: function () { }, clear: function () { } }, g.prototype), e.scrollbarModel = { "native": m, "null": g }, L.prototype.signal = function (e, t) { Ni(e, t) && this.events.push(arguments) }, L.prototype.finish = function () { for (var e = 0; e < this.events.length; e++)Pa.apply(null, this.events[e]) }; var Bo = e.Pos = function (e, t) { return this instanceof Bo ? (this.line = e, void (this.ch = t)) : new Bo(e, t) }, _o = e.cmpPos = function (e, t) { return e.line - t.line || e.ch - t.ch }, Fo = null; ne.prototype = Wi({
                    init: function (e) { function t(e) { if (!Ti(r, e)) { if (r.somethingSelected()) Fo = { lineWise: !1, text: r.getSelections() }, n.inaccurateSelection && (n.prevInput = "", n.inaccurateSelection = !1, o.value = Fo.text.join("\n"), Ua(o)); else { if (!r.options.lineWiseCopyCut) return; var t = ee(r); Fo = { lineWise: !0, text: t.text }, "cut" == e.type ? r.setSelections(t.ranges, null, Wa) : (n.prevInput = "", o.value = t.text.join("\n"), Ua(o)) } "cut" == e.type && (r.state.cutIncoming = !0) } } var n = this, r = this.cm, i = this.wrapper = re(), o = this.textarea = i.firstChild; e.wrapper.insertBefore(i, e.wrapper.firstChild), No && (o.style.width = "0px"), Ea(o, "input", function () { xo && bo >= 9 && n.hasSelection && (n.hasSelection = null), n.poll() }), Ea(o, "paste", function (e) { Ti(r, e) || J(e, r) || (r.state.pasteIncoming = !0, n.fastPoll()) }), Ea(o, "cut", t), Ea(o, "copy", t), Ea(e.scroller, "paste", function (t) { Gt(e, t) || Ti(r, t) || (r.state.pasteIncoming = !0, n.focus()) }), Ea(e.lineSpace, "selectstart", function (t) { Gt(e, t) || Ma(t) }), Ea(o, "compositionstart", function () { var e = r.getCursor("from"); n.composing && n.composing.range.clear(), n.composing = { start: e, range: r.markText(e, r.getCursor("to"), { className: "CodeMirror-composing" }) } }), Ea(o, "compositionend", function () { n.composing && (n.poll(), n.composing.range.clear(), n.composing = null) }) }, prepareSelection: function () { var e = this.cm, t = e.display, n = e.doc, r = De(e); if (e.options.moveInputWithCursor) { var i = dt(e, n.sel.primary().head, "div"), o = t.wrapper.getBoundingClientRect(), a = t.lineDiv.getBoundingClientRect(); r.teTop = Math.max(0, Math.min(t.wrapper.clientHeight - 10, i.top + a.top - o.top)), r.teLeft = Math.max(0, Math.min(t.wrapper.clientWidth - 10, i.left + a.left - o.left)) } return r }, showSelection: function (e) { var t = this.cm, n = t.display; qi(n.cursorDiv, e.cursors), qi(n.selectionDiv, e.selection), null != e.teTop && (this.wrapper.style.top = e.teTop + "px", this.wrapper.style.left = e.teLeft + "px") }, reset: function (e) { if (!this.contextMenuPending) { var t, n, r = this.cm, i = r.doc; if (r.somethingSelected()) { this.prevInput = ""; var o = i.sel.primary(); t = rl && (o.to().line - o.from().line > 100 || (n = r.getSelection()).length > 1e3); var a = t ? "-" : n || r.getSelection(); this.textarea.value = a, r.state.focused && Ua(this.textarea), xo && bo >= 9 && (this.hasSelection = a) } else e || (this.prevInput = this.textarea.value = "", xo && bo >= 9 && (this.hasSelection = null)); this.inaccurateSelection = t } }, getField: function () { return this.textarea }, supportsTouch: function () { return !1 }, focus: function () { if ("nocursor" != this.cm.options.readOnly && (!Ao || Gi() != this.textarea)) try { this.textarea.focus() } catch (e) { } }, blur: function () { this.textarea.blur() }, resetPosition: function () {
                        this.wrapper.style.top = this.wrapper.style.left = 0;
                    }, receivedFocus: function () { this.slowPoll() }, slowPoll: function () { var e = this; e.pollingFast || e.polling.set(this.cm.options.pollInterval, function () { e.poll(), e.cm.state.focused && e.slowPoll() }) }, fastPoll: function () { function e() { var r = n.poll(); r || t ? (n.pollingFast = !1, n.slowPoll()) : (t = !0, n.polling.set(60, e)) } var t = !1, n = this; n.pollingFast = !0, n.polling.set(20, e) }, poll: function () { var e = this.cm, t = this.textarea, n = this.prevInput; if (this.contextMenuPending || !e.state.focused || nl(t) && !n && !this.composing || e.isReadOnly() || e.options.disableInput || e.state.keySeq) return !1; var r = t.value; if (r == n && !e.somethingSelected()) return !1; if (xo && bo >= 9 && this.hasSelection === r || Eo && /[\uf700-\uf7ff]/.test(r)) return e.display.input.reset(), !1; if (e.doc.sel == e.display.selForContextMenu) { var i = r.charCodeAt(0); if (8203 != i || n || (n = "​"), 8666 == i) return this.reset(), this.cm.execCommand("undo") } for (var o = 0, a = Math.min(n.length, r.length); a > o && n.charCodeAt(o) == r.charCodeAt(o);)++o; var l = this; return At(e, function () { Z(e, r.slice(o), n.length - o, null, l.composing ? "*compose" : null), r.length > 1e3 || r.indexOf("\n") > -1 ? t.value = l.prevInput = "" : l.prevInput = r, l.composing && (l.composing.range.clear(), l.composing.range = e.markText(l.composing.start, e.getCursor("to"), { className: "CodeMirror-composing" })) }), !0 }, ensurePolled: function () { this.pollingFast && this.poll() && (this.pollingFast = !1) }, onKeyPress: function () { xo && bo >= 9 && (this.hasSelection = null), this.fastPoll() }, onContextMenu: function (e) { function t() { if (null != a.selectionStart) { var e = i.somethingSelected(), t = "​" + (e ? a.value : ""); a.value = "⇚", a.value = t, r.prevInput = e ? "" : "​", a.selectionStart = 1, a.selectionEnd = t.length, o.selForContextMenu = i.doc.sel } } function n() { if (r.contextMenuPending = !1, r.wrapper.style.cssText = f, a.style.cssText = u, xo && 9 > bo && o.scrollbars.setScrollTop(o.scroller.scrollTop = s), null != a.selectionStart) { (!xo || xo && 9 > bo) && t(); var e = 0, n = function () { o.selForContextMenu == i.doc.sel && 0 == a.selectionStart && a.selectionEnd > 0 && "​" == r.prevInput ? Et(i, ua.selectAll)(i) : e++ < 10 ? o.detectingSelectAll = setTimeout(n, 500) : o.input.reset() }; o.detectingSelectAll = setTimeout(n, 200) } } var r = this, i = r.cm, o = i.display, a = r.textarea, l = Yt(i, e), s = o.scroller.scrollTop; if (l && !Co) { var c = i.options.resetSelectionOnContextMenu; c && -1 == i.doc.sel.contains(l) && Et(i, Te)(i.doc, de(l), Wa); var u = a.style.cssText, f = r.wrapper.style.cssText; r.wrapper.style.cssText = "position: absolute"; var h = r.wrapper.getBoundingClientRect(); if (a.style.cssText = "position: absolute; width: 30px; height: 30px; top: " + (e.clientY - h.top - 5) + "px; left: " + (e.clientX - h.left - 5) + "px; z-index: 1000; background: " + (xo ? "rgba(255, 255, 255, .05)" : "transparent") + "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);", wo) var d = window.scrollY; if (o.input.focus(), wo && window.scrollTo(null, d), o.input.reset(), i.somethingSelected() || (a.value = r.prevInput = " "), r.contextMenuPending = !0, o.selForContextMenu = i.doc.sel, clearTimeout(o.detectingSelectAll), xo && bo >= 9 && t(), Do) { Aa(e); var p = function () { Ia(window, "mouseup", p), setTimeout(n, 20) }; Ea(window, "mouseup", p) } else setTimeout(n, 50) } }, readOnlyChanged: function (e) { e || this.reset() }, setUneditable: Di, needsContentAttribute: !1
                }, ne.prototype), ie.prototype = Wi({ init: function (e) { function t(e) { if (!Ti(r, e)) { if (r.somethingSelected()) Fo = { lineWise: !1, text: r.getSelections() }, "cut" == e.type && r.replaceSelection("", null, "cut"); else { if (!r.options.lineWiseCopyCut) return; var t = ee(r); Fo = { lineWise: !0, text: t.text }, "cut" == e.type && r.operation(function () { r.setSelections(t.ranges, 0, Wa), r.replaceSelection("", null, "cut") }) } if (e.clipboardData && !No) e.preventDefault(), e.clipboardData.clearData(), e.clipboardData.setData("text/plain", Fo.text.join("\n")); else { var n = re(), i = n.firstChild; r.display.lineSpace.insertBefore(n, r.display.lineSpace.firstChild), i.value = Fo.text.join("\n"); var o = document.activeElement; Ua(i), setTimeout(function () { r.display.lineSpace.removeChild(n), o.focus() }, 50) } } } var n = this, r = n.cm, i = n.div = e.lineDiv; te(i), Ea(i, "paste", function (e) { Ti(r, e) || J(e, r) }), Ea(i, "compositionstart", function (e) { var t = e.data; if (n.composing = { sel: r.doc.sel, data: t, startData: t }, t) { var i = r.doc.sel.primary(), o = r.getLine(i.head.line), a = o.indexOf(t, Math.max(0, i.head.ch - t.length)); a > -1 && a <= i.head.ch && (n.composing.sel = de(Bo(i.head.line, a), Bo(i.head.line, a + t.length))) } }), Ea(i, "compositionupdate", function (e) { n.composing.data = e.data }), Ea(i, "compositionend", function (e) { var t = n.composing; t && (e.data == t.startData || /\u200b/.test(e.data) || (t.data = e.data), setTimeout(function () { t.handled || n.applyComposition(t), n.composing == t && (n.composing = null) }, 50)) }), Ea(i, "touchstart", function () { n.forceCompositionEnd() }), Ea(i, "input", function () { n.composing || !r.isReadOnly() && n.pollContent() || At(n.cm, function () { Dt(r) }) }), Ea(i, "copy", t), Ea(i, "cut", t) }, prepareSelection: function () { var e = De(this.cm, !1); return e.focus = this.cm.state.focused, e }, showSelection: function (e, t) { e && this.cm.display.view.length && ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e)) }, showPrimarySelection: function () { var e = window.getSelection(), t = this.cm.doc.sel.primary(), n = le(this.cm, e.anchorNode, e.anchorOffset), r = le(this.cm, e.focusNode, e.focusOffset); if (!n || n.bad || !r || r.bad || 0 != _o(K(n, r), t.from()) || 0 != _o(V(n, r), t.to())) { var i = oe(this.cm, t.from()), o = oe(this.cm, t.to()); if (i || o) { var a = this.cm.display.view, l = e.rangeCount && e.getRangeAt(0); if (i) { if (!o) { var s = a[a.length - 1].measure, c = s.maps ? s.maps[s.maps.length - 1] : s.map; o = { node: c[c.length - 1], offset: c[c.length - 2] - c[c.length - 3] } } } else i = { node: a[0].measure.map[2], offset: 0 }; try { var u = qa(i.node, i.offset, o.offset, o.node) } catch (f) { } u && (!go && this.cm.state.focused ? (e.collapse(i.node, i.offset), u.collapsed || e.addRange(u)) : (e.removeAllRanges(), e.addRange(u)), l && null == e.anchorNode ? e.addRange(l) : go && this.startGracePeriod()), this.rememberSelection() } } }, startGracePeriod: function () { var e = this; clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function () { e.gracePeriod = !1, e.selectionChanged() && e.cm.operation(function () { e.cm.curOp.selectionChanged = !0 }) }, 20) }, showMultipleSelections: function (e) { qi(this.cm.display.cursorDiv, e.cursors), qi(this.cm.display.selectionDiv, e.selection) }, rememberSelection: function () { var e = window.getSelection(); this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset }, selectionInEditor: function () { var e = window.getSelection(); if (!e.rangeCount) return !1; var t = e.getRangeAt(0).commonAncestorContainer; return Va(this.div, t) }, focus: function () { "nocursor" != this.cm.options.readOnly && this.div.focus() }, blur: function () { this.div.blur() }, getField: function () { return this.div }, supportsTouch: function () { return !0 }, receivedFocus: function () { function e() { t.cm.state.focused && (t.pollSelection(), t.polling.set(t.cm.options.pollInterval, e)) } var t = this; this.selectionInEditor() ? this.pollSelection() : At(this.cm, function () { t.cm.curOp.selectionChanged = !0 }), this.polling.set(this.cm.options.pollInterval, e) }, selectionChanged: function () { var e = window.getSelection(); return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset }, pollSelection: function () { if (!this.composing && !this.gracePeriod && this.selectionChanged()) { var e = window.getSelection(), t = this.cm; this.rememberSelection(); var n = le(t, e.anchorNode, e.anchorOffset), r = le(t, e.focusNode, e.focusOffset); n && r && At(t, function () { Te(t.doc, de(n, r), Wa), (n.bad || r.bad) && (t.curOp.selectionChanged = !0) }) } }, pollContent: function () { var e = this.cm, t = e.display, n = e.doc.sel.primary(), r = n.from(), i = n.to(); if (r.line < t.viewFrom || i.line > t.viewTo - 1) return !1; var o; if (r.line == t.viewFrom || 0 == (o = Bt(e, r.line))) var a = ti(t.view[0].line), l = t.view[0].node; else var a = ti(t.view[o].line), l = t.view[o - 1].node.nextSibling; var s = Bt(e, i.line); if (s == t.view.length - 1) var c = t.viewTo - 1, u = t.lineDiv.lastChild; else var c = ti(t.view[s + 1].line) - 1, u = t.view[s + 1].node.previousSibling; for (var f = e.doc.splitLines(ce(e, l, u, a, c)), h = Jr(e.doc, Bo(a, 0), Bo(c, Zr(e.doc, c).text.length)); f.length > 1 && h.length > 1;)if (Ii(f) == Ii(h)) f.pop(), h.pop(), c--; else { if (f[0] != h[0]) break; f.shift(), h.shift(), a++ } for (var d = 0, p = 0, m = f[0], g = h[0], v = Math.min(m.length, g.length); v > d && m.charCodeAt(d) == g.charCodeAt(d);)++d; for (var y = Ii(f), x = Ii(h), b = Math.min(y.length - (1 == f.length ? d : 0), x.length - (1 == h.length ? d : 0)); b > p && y.charCodeAt(y.length - p - 1) == x.charCodeAt(x.length - p - 1);)++p; f[f.length - 1] = y.slice(0, y.length - p), f[0] = f[0].slice(d); var w = Bo(a, d), k = Bo(c, h.length ? Ii(h).length - p : 0); return f.length > 1 || f[0] || _o(w, k) ? (In(e.doc, f, w, k, "+input"), !0) : void 0 }, ensurePolled: function () { this.forceCompositionEnd() }, reset: function () { this.forceCompositionEnd() }, forceCompositionEnd: function () { this.composing && !this.composing.handled && (this.applyComposition(this.composing), this.composing.handled = !0, this.div.blur(), this.div.focus()) }, applyComposition: function (e) { this.cm.isReadOnly() ? Et(this.cm, Dt)(this.cm) : e.data && e.data != e.startData && Et(this.cm, Z)(this.cm, e.data, 0, e.sel) }, setUneditable: function (e) { e.contentEditable = "false" }, onKeyPress: function (e) { e.preventDefault(), this.cm.isReadOnly() || Et(this.cm, Z)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0) }, readOnlyChanged: function (e) { this.div.contentEditable = String("nocursor" != e) }, onContextMenu: Di, resetPosition: Di, needsContentAttribute: !0 }, ie.prototype), e.inputStyles = { textarea: ne, contenteditable: ie }, ue.prototype = { primary: function () { return this.ranges[this.primIndex] }, equals: function (e) { if (e == this) return !0; if (e.primIndex != this.primIndex || e.ranges.length != this.ranges.length) return !1; for (var t = 0; t < this.ranges.length; t++) { var n = this.ranges[t], r = e.ranges[t]; if (0 != _o(n.anchor, r.anchor) || 0 != _o(n.head, r.head)) return !1 } return !0 }, deepCopy: function () { for (var e = [], t = 0; t < this.ranges.length; t++)e[t] = new fe($(this.ranges[t].anchor), $(this.ranges[t].head)); return new ue(e, this.primIndex) }, somethingSelected: function () { for (var e = 0; e < this.ranges.length; e++)if (!this.ranges[e].empty()) return !0; return !1 }, contains: function (e, t) { t || (t = e); for (var n = 0; n < this.ranges.length; n++) { var r = this.ranges[n]; if (_o(t, r.from()) >= 0 && _o(e, r.to()) <= 0) return n } return -1 } }, fe.prototype = { from: function () { return K(this.anchor, this.head) }, to: function () { return V(this.anchor, this.head) }, empty: function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch } }; var zo, jo, Uo, qo = { left: 0, right: 0, top: 0, bottom: 0 }, Go = null, Yo = 0, $o = 0, Vo = 0, Ko = null; xo ? Ko = -.53 : go ? Ko = 15 : So ? Ko = -.7 : Lo && (Ko = -1 / 3); var Xo = function (e) { var t = e.wheelDeltaX, n = e.wheelDeltaY; return null == t && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), null == n && e.detail && e.axis == e.VERTICAL_AXIS ? n = e.detail : null == n && (n = e.wheelDelta), { x: t, y: n } }; e.wheelEventPixels = function (e) { var t = Xo(e); return t.x *= Ko, t.y *= Ko, t }; var Zo = new Ei, Jo = null, Qo = e.changeEnd = function (e) { return e.text ? Bo(e.from.line + e.text.length - 1, Ii(e.text).length + (1 == e.text.length ? e.from.ch : 0)) : e.to }; e.prototype = { constructor: e, focus: function () { window.focus(), this.display.input.focus() }, setOption: function (e, t) { var n = this.options, r = n[e]; n[e] == t && "mode" != e || (n[e] = t, ta.hasOwnProperty(e) && Et(this, ta[e])(this, t, r)) }, getOption: function (e) { return this.options[e] }, getDoc: function () { return this.doc }, addKeyMap: function (e, t) { this.state.keyMaps[t ? "push" : "unshift"]($n(e)) }, removeKeyMap: function (e) { for (var t = this.state.keyMaps, n = 0; n < t.length; ++n)if (t[n] == e || t[n].name == e) return t.splice(n, 1), !0 }, addOverlay: Ot(function (t, n) { var r = t.token ? t : e.getMode(this.options, t); if (r.startState) throw new Error("Overlays may not be stateful."); this.state.overlays.push({ mode: r, modeSpec: t, opaque: n && n.opaque }), this.state.modeGen++ , Dt(this) }), removeOverlay: Ot(function (e) { for (var t = this.state.overlays, n = 0; n < t.length; ++n) { var r = t[n].modeSpec; if (r == e || "string" == typeof e && r.name == e) return t.splice(n, 1), this.state.modeGen++ , void Dt(this) } }), indentLine: Ot(function (e, t, n) { "string" != typeof t && "number" != typeof t && (t = null == t ? this.options.smartIndent ? "smart" : "prev" : t ? "add" : "subtract"), ve(this.doc, e) && Fn(this, e, t, n) }), indentSelection: Ot(function (e) { for (var t = this.doc.sel.ranges, n = -1, r = 0; r < t.length; r++) { var i = t[r]; if (i.empty()) i.head.line > n && (Fn(this, i.head.line, e, !0), n = i.head.line, r == this.doc.sel.primIndex && Bn(this)); else { var o = i.from(), a = i.to(), l = Math.max(n, o.line); n = Math.min(this.lastLine(), a.line - (a.ch ? 0 : 1)) + 1; for (var s = l; n > s; ++s)Fn(this, s, e); var c = this.doc.sel.ranges; 0 == o.ch && t.length == c.length && c[r].from().ch > 0 && ke(this.doc, r, new fe(o, c[r].to()), Wa) } } }), getTokenAt: function (e, t) { return Ir(this, e, t) }, getLineTokens: function (e, t) { return Ir(this, Bo(e), t, !0) }, getTokenTypeAt: function (e) { e = me(this.doc, e); var t, n = Dr(this, Zr(this.doc, e.line)), r = 0, i = (n.length - 1) / 2, o = e.ch; if (0 == o) t = n[2]; else for (; ;) { var a = r + i >> 1; if ((a ? n[2 * a - 1] : 0) >= o) i = a; else { if (!(n[2 * a + 1] < o)) { t = n[2 * a + 2]; break } r = a + 1 } } var l = t ? t.indexOf("cm-overlay ") : -1; return 0 > l ? t : 0 == l ? null : t.slice(0, l - 1) }, getModeAt: function (t) { var n = this.doc.mode; return n.innerMode ? e.innerMode(n, this.getTokenAt(t).state).mode : n }, getHelper: function (e, t) { return this.getHelpers(e, t)[0] }, getHelpers: function (e, t) { var n = []; if (!la.hasOwnProperty(t)) return n; var r = la[t], i = this.getModeAt(e); if ("string" == typeof i[t]) r[i[t]] && n.push(r[i[t]]); else if (i[t]) for (var o = 0; o < i[t].length; o++) { var a = r[i[t][o]]; a && n.push(a) } else i.helperType && r[i.helperType] ? n.push(r[i.helperType]) : r[i.name] && n.push(r[i.name]); for (var o = 0; o < r._global.length; o++) { var l = r._global[o]; l.pred(i, this) && -1 == Pi(n, l.val) && n.push(l.val) } return n }, getStateAfter: function (e, t) { var n = this.doc; return e = pe(n, null == e ? n.first + n.size - 1 : e), je(this, e + 1, t) }, cursorCoords: function (e, t) { var n, r = this.doc.sel.primary(); return n = null == e ? r.head : "object" == typeof e ? me(this.doc, e) : e ? r.from() : r.to(), dt(this, n, t || "page") }, charCoords: function (e, t) { return ht(this, me(this.doc, e), t || "page") }, coordsChar: function (e, t) { return e = ft(this, e, t || "page"), gt(this, e.left, e.top) }, lineAtHeight: function (e, t) { return e = ft(this, { top: e, left: 0 }, t || "page").top, ni(this.doc, e + this.display.viewOffset) }, heightAtLine: function (e, t) { var n, r = !1; if ("number" == typeof e) { var i = this.doc.first + this.doc.size - 1; e < this.doc.first ? e = this.doc.first : e > i && (e = i, r = !0), n = Zr(this.doc, e) } else n = e; return ut(this, n, { top: 0, left: 0 }, t || "page").top + (r ? this.doc.height - ri(n) : 0) }, defaultTextHeight: function () { return yt(this.display) }, defaultCharWidth: function () { return xt(this.display) }, setGutterMarker: Ot(function (e, t, n) { return zn(this.doc, e, "gutter", function (e) { var r = e.gutterMarkers || (e.gutterMarkers = {}); return r[t] = n, !n && Fi(r) && (e.gutterMarkers = null), !0 }) }), clearGutter: Ot(function (e) { var t = this, n = t.doc, r = n.first; n.iter(function (n) { n.gutterMarkers && n.gutterMarkers[e] && (n.gutterMarkers[e] = null, Ht(t, r, "gutter"), Fi(n.gutterMarkers) && (n.gutterMarkers = null)), ++r }) }), lineInfo: function (e) { if ("number" == typeof e) { if (!ve(this.doc, e)) return null; var t = e; if (e = Zr(this.doc, e), !e) return null } else { var t = ti(e); if (null == t) return null } return { line: t, handle: e, text: e.text, gutterMarkers: e.gutterMarkers, textClass: e.textClass, bgClass: e.bgClass, wrapClass: e.wrapClass, widgets: e.widgets } }, getViewport: function () { return { from: this.display.viewFrom, to: this.display.viewTo } }, addWidget: function (e, t, n, r, i) { var o = this.display; e = dt(this, me(this.doc, e)); var a = e.bottom, l = e.left; if (t.style.position = "absolute", t.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(t), o.sizer.appendChild(t), "over" == r) a = e.top; else if ("above" == r || "near" == r) { var s = Math.max(o.wrapper.clientHeight, this.doc.height), c = Math.max(o.sizer.clientWidth, o.lineSpace.clientWidth); ("above" == r || e.bottom + t.offsetHeight > s) && e.top > t.offsetHeight ? a = e.top - t.offsetHeight : e.bottom + t.offsetHeight <= s && (a = e.bottom), l + t.offsetWidth > c && (l = c - t.offsetWidth) } t.style.top = a + "px", t.style.left = t.style.right = "", "right" == i ? (l = o.sizer.clientWidth - t.offsetWidth, t.style.right = "0px") : ("left" == i ? l = 0 : "middle" == i && (l = (o.sizer.clientWidth - t.offsetWidth) / 2), t.style.left = l + "px"), n && Dn(this, l, a, l + t.offsetWidth, a + t.offsetHeight) }, triggerOnKeyDown: Ot(hn), triggerOnKeyPress: Ot(mn), triggerOnKeyUp: pn, execCommand: function (e) { return ua.hasOwnProperty(e) ? ua[e].call(null, this) : void 0 }, triggerElectric: Ot(function (e) { Q(this, e) }), findPosH: function (e, t, n, r) { var i = 1; 0 > t && (i = -1, t = -t); for (var o = 0, a = me(this.doc, e); t > o && (a = Un(this.doc, a, i, n, r), !a.hitSide); ++o); return a }, moveH: Ot(function (e, t) { var n = this; n.extendSelectionsBy(function (r) { return n.display.shift || n.doc.extend || r.empty() ? Un(n.doc, r.head, e, t, n.options.rtlMoveVisually) : 0 > e ? r.from() : r.to() }, _a) }), deleteH: Ot(function (e, t) { var n = this.doc.sel, r = this.doc; n.somethingSelected() ? r.replaceSelection("", null, "+delete") : jn(this, function (n) { var i = Un(r, n.head, e, t, !1); return 0 > e ? { from: i, to: n.head } : { from: n.head, to: i } }) }), findPosV: function (e, t, n, r) { var i = 1, o = r; 0 > t && (i = -1, t = -t); for (var a = 0, l = me(this.doc, e); t > a; ++a) { var s = dt(this, l, "div"); if (null == o ? o = s.left : s.left = o, l = qn(this, s, i, n), l.hitSide) break } return l }, moveV: Ot(function (e, t) { var n = this, r = this.doc, i = [], o = !n.display.shift && !r.extend && r.sel.somethingSelected(); if (r.extendSelectionsBy(function (a) { if (o) return 0 > e ? a.from() : a.to(); var l = dt(n, a.head, "div"); null != a.goalColumn && (l.left = a.goalColumn), i.push(l.left); var s = qn(n, l, e, t); return "page" == t && a == r.sel.primary() && Wn(n, null, ht(n, s, "div").top - l.top), s }, _a), i.length) for (var a = 0; a < r.sel.ranges.length; a++)r.sel.ranges[a].goalColumn = i[a] }), findWordAt: function (e) { var t = this.doc, n = Zr(t, e.line).text, r = e.ch, i = e.ch; if (n) { var o = this.getHelper(e, "wordChars"); (e.xRel < 0 || i == n.length) && r ? --r : ++i; for (var a = n.charAt(r), l = _i(a, o) ? function (e) { return _i(e, o) } : /\s/.test(a) ? function (e) { return /\s/.test(e) } : function (e) { return !/\s/.test(e) && !_i(e) }; r > 0 && l(n.charAt(r - 1));)--r; for (; i < n.length && l(n.charAt(i));)++i } return new fe(Bo(e.line, r), Bo(e.line, i)) }, toggleOverwrite: function (e) { null != e && e == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? Ja(this.display.cursorDiv, "CodeMirror-overwrite") : Za(this.display.cursorDiv, "CodeMirror-overwrite"), Pa(this, "overwriteToggle", this, this.state.overwrite)) }, hasFocus: function () { return this.display.input.getField() == Gi() }, isReadOnly: function () { return !(!this.options.readOnly && !this.doc.cantEdit) }, scrollTo: Ot(function (e, t) { null == e && null == t || _n(this), null != e && (this.curOp.scrollLeft = e), null != t && (this.curOp.scrollTop = t) }), getScrollInfo: function () { var e = this.display.scroller; return { left: e.scrollLeft, top: e.scrollTop, height: e.scrollHeight - Ye(this) - this.display.barHeight, width: e.scrollWidth - Ye(this) - this.display.barWidth, clientHeight: Ve(this), clientWidth: $e(this) } }, scrollIntoView: Ot(function (e, t) { if (null == e ? (e = { from: this.doc.sel.primary().head, to: null }, null == t && (t = this.options.cursorScrollMargin)) : "number" == typeof e ? e = { from: Bo(e, 0), to: null } : null == e.from && (e = { from: e, to: null }), e.to || (e.to = e.from), e.margin = t || 0, null != e.from.line) _n(this), this.curOp.scrollToPos = e; else { var n = Hn(this, Math.min(e.from.left, e.to.left), Math.min(e.from.top, e.to.top) - e.margin, Math.max(e.from.right, e.to.right), Math.max(e.from.bottom, e.to.bottom) + e.margin); this.scrollTo(n.scrollLeft, n.scrollTop) } }), setSize: Ot(function (e, t) { function n(e) { return "number" == typeof e || /^\d+$/.test(String(e)) ? e + "px" : e } var r = this; null != e && (r.display.wrapper.style.width = n(e)), null != t && (r.display.wrapper.style.height = n(t)), r.options.lineWrapping && at(this); var i = r.display.viewFrom; r.doc.iter(i, r.display.viewTo, function (e) { if (e.widgets) for (var t = 0; t < e.widgets.length; t++)if (e.widgets[t].noHScroll) { Ht(r, i, "widget"); break } ++i }), r.curOp.forceUpdate = !0, Pa(r, "refresh", this) }), operation: function (e) { return At(this, e) }, refresh: Ot(function () { var e = this.display.cachedTextHeight; Dt(this), this.curOp.forceUpdate = !0, lt(this), this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop), u(this), (null == e || Math.abs(e - yt(this.display)) > .5) && a(this), Pa(this, "refresh", this) }), swapDoc: Ot(function (e) { var t = this.doc; return t.cm = null, Xr(this, e), lt(this), this.display.input.reset(), this.scrollTo(e.scrollLeft, e.scrollTop), this.curOp.forceScroll = !0, Ci(this, "swapDoc", this, t), t }), getInputField: function () { return this.display.input.getField() }, getWrapperElement: function () { return this.display.wrapper }, getScrollerElement: function () { return this.display.scroller }, getGutterElement: function () { return this.display.gutters } }, Ai(e); var ea = e.defaults = {}, ta = e.optionHandlers = {}, na = e.Init = { toString: function () { return "CodeMirror.Init" } }; Gn("value", "", function (e, t) { e.setValue(t) }, !0), Gn("mode", null, function (e, t) { e.doc.modeOption = t, n(e) }, !0), Gn("indentUnit", 2, n, !0), Gn("indentWithTabs", !1), Gn("smartIndent", !0), Gn("tabSize", 4, function (e) { r(e), lt(e), Dt(e) }, !0), Gn("lineSeparator", null, function (e, t) { if (e.doc.lineSep = t, t) { var n = [], r = e.doc.first; e.doc.iter(function (e) { for (var i = 0; ;) { var o = e.text.indexOf(t, i); if (-1 == o) break; i = o + t.length, n.push(Bo(r, o)) } r++ }); for (var i = n.length - 1; i >= 0; i--)In(e.doc, t, n[i], Bo(n[i].line, n[i].ch + t.length)) } }), Gn("specialChars", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function (t, n, r) { t.state.specialChars = new RegExp(n.source + (n.test("	") ? "" : "|	"), "g"), r != e.Init && t.refresh() }), Gn("specialCharPlaceholder", _r, function (e) { e.refresh() }, !0), Gn("electricChars", !0), Gn("inputStyle", Ao ? "contenteditable" : "textarea", function () { throw new Error("inputStyle can not (yet) be changed in a running editor") }, !0), Gn("rtlMoveVisually", !Io), Gn("wholeLineUpdateBefore", !0), Gn("theme", "default", function (e) { l(e), s(e) }, !0), Gn("keyMap", "default", function (t, n, r) { var i = $n(n), o = r != e.Init && $n(r); o && o.detach && o.detach(t, i), i.attach && i.attach(t, o || null) }), Gn("extraKeys", null), Gn("lineWrapping", !1, i, !0), Gn("gutters", [], function (e) { d(e.options), s(e) }, !0), Gn("fixedGutter", !0, function (e, t) { e.display.gutters.style.left = t ? C(e.display) + "px" : "0", e.refresh() }, !0), Gn("coverGutterNextToScrollbar", !1, function (e) { y(e) }, !0), Gn("scrollbarStyle", "native", function (e) { v(e), y(e), e.display.scrollbars.setScrollTop(e.doc.scrollTop), e.display.scrollbars.setScrollLeft(e.doc.scrollLeft) }, !0), Gn("lineNumbers", !1, function (e) { d(e.options), s(e) }, !0), Gn("firstLineNumber", 1, s, !0), Gn("lineNumberFormatter", function (e) { return e }, s, !0), Gn("showCursorWhenSelecting", !1, Re, !0), Gn("resetSelectionOnContextMenu", !0), Gn("lineWiseCopyCut", !0), Gn("readOnly", !1, function (e, t) { "nocursor" == t ? (yn(e), e.display.input.blur(), e.display.disabled = !0) : e.display.disabled = !1, e.display.input.readOnlyChanged(t) }), Gn("disableInput", !1, function (e, t) { t || e.display.input.reset() }, !0), Gn("dragDrop", !0, Ut), Gn("allowDropFileTypes", null), Gn("cursorBlinkRate", 530), Gn("cursorScrollMargin", 0), Gn("cursorHeight", 1, Re, !0), Gn("singleCursorHeightPerLine", !0, Re, !0), Gn("workTime", 100), Gn("workDelay", 100), Gn("flattenSpans", !0, r, !0), Gn("addModeClass", !1, r, !0), Gn("pollInterval", 100), Gn("undoDepth", 200, function (e, t) { e.doc.history.undoDepth = t }), Gn("historyEventDelay", 1250), Gn("viewportMargin", 10, function (e) { e.refresh() }, !0), Gn("maxHighlightLength", 1e4, r, !0), Gn("moveInputWithCursor", !0, function (e, t) { t || e.display.input.resetPosition() }), Gn("tabindex", null, function (e, t) { e.display.input.getField().tabIndex = t || "" }), Gn("autofocus", null); var ra = e.modes = {}, ia = e.mimeModes = {}; e.defineMode = function (t, n) { e.defaults.mode || "null" == t || (e.defaults.mode = t), arguments.length > 2 && (n.dependencies = Array.prototype.slice.call(arguments, 2)), ra[t] = n }, e.defineMIME = function (e, t) { ia[e] = t }, e.resolveMode = function (t) { if ("string" == typeof t && ia.hasOwnProperty(t)) t = ia[t]; else if (t && "string" == typeof t.name && ia.hasOwnProperty(t.name)) { var n = ia[t.name]; "string" == typeof n && (n = { name: n }), t = Hi(n, t), t.name = n.name } else if ("string" == typeof t && /^[\w\-]+\/[\w\-]+\+xml$/.test(t)) return e.resolveMode("application/xml"); return "string" == typeof t ? { name: t } : t || { name: "null" } }, e.getMode = function (t, n) { var n = e.resolveMode(n), r = ra[n.name]; if (!r) return e.getMode(t, "text/plain"); var i = r(t, n); if (oa.hasOwnProperty(n.name)) { var o = oa[n.name]; for (var a in o) o.hasOwnProperty(a) && (i.hasOwnProperty(a) && (i["_" + a] = i[a]), i[a] = o[a]) } if (i.name = n.name, n.helperType && (i.helperType = n.helperType), n.modeProps) for (var a in n.modeProps) i[a] = n.modeProps[a]; return i }, e.defineMode("null", function () { return { token: function (e) { e.skipToEnd() } } }), e.defineMIME("text/plain", "null"); var oa = e.modeExtensions = {}; e.extendMode = function (e, t) { var n = oa.hasOwnProperty(e) ? oa[e] : oa[e] = {}; Wi(t, n) }, e.defineExtension = function (t, n) { e.prototype[t] = n }, e.defineDocExtension = function (e, t) { Ca.prototype[e] = t }, e.defineOption = Gn; var aa = []; e.defineInitHook = function (e) { aa.push(e) }; var la = e.helpers = {}; e.registerHelper = function (t, n, r) { la.hasOwnProperty(t) || (la[t] = e[t] = { _global: [] }), la[t][n] = r }, e.registerGlobalHelper = function (t, n, r, i) { e.registerHelper(t, n, i), la[t]._global.push({ pred: r, val: i }) }; var sa = e.copyState = function (e, t) { if (t === !0) return t; if (e.copyState) return e.copyState(t); var n = {}; for (var r in t) { var i = t[r]; i instanceof Array && (i = i.concat([])), n[r] = i } return n }, ca = e.startState = function (e, t, n) { return e.startState ? e.startState(t, n) : !0 }; e.innerMode = function (e, t) { for (; e.innerMode;) { var n = e.innerMode(t); if (!n || n.mode == e) break; t = n.state, e = n.mode } return n || { mode: e, state: t } }; var ua = e.commands = { selectAll: function (e) { e.setSelection(Bo(e.firstLine(), 0), Bo(e.lastLine()), Wa) }, singleSelection: function (e) { e.setSelection(e.getCursor("anchor"), e.getCursor("head"), Wa) }, killLine: function (e) { jn(e, function (t) { if (t.empty()) { var n = Zr(e.doc, t.head.line).text.length; return t.head.ch == n && t.head.line < e.lastLine() ? { from: t.head, to: Bo(t.head.line + 1, 0) } : { from: t.head, to: Bo(t.head.line, n) } } return { from: t.from(), to: t.to() } }) }, deleteLine: function (e) { jn(e, function (t) { return { from: Bo(t.from().line, 0), to: me(e.doc, Bo(t.to().line + 1, 0)) } }) }, delLineLeft: function (e) { jn(e, function (e) { return { from: Bo(e.from().line, 0), to: e.from() } }) }, delWrappedLineLeft: function (e) { jn(e, function (t) { var n = e.charCoords(t.head, "div").top + 5, r = e.coordsChar({ left: 0, top: n }, "div"); return { from: r, to: t.from() } }) }, delWrappedLineRight: function (e) { jn(e, function (t) { var n = e.charCoords(t.head, "div").top + 5, r = e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: n }, "div"); return { from: t.from(), to: r } }) }, undo: function (e) { e.undo() }, redo: function (e) { e.redo() }, undoSelection: function (e) { e.undoSelection() }, redoSelection: function (e) { e.redoSelection() }, goDocStart: function (e) { e.extendSelection(Bo(e.firstLine(), 0)) }, goDocEnd: function (e) { e.extendSelection(Bo(e.lastLine())) }, goLineStart: function (e) { e.extendSelectionsBy(function (t) { return oo(e, t.head.line) }, { origin: "+move", bias: 1 }) }, goLineStartSmart: function (e) { e.extendSelectionsBy(function (t) { return lo(e, t.head) }, { origin: "+move", bias: 1 }) }, goLineEnd: function (e) { e.extendSelectionsBy(function (t) { return ao(e, t.head.line) }, { origin: "+move", bias: -1 }) }, goLineRight: function (e) { e.extendSelectionsBy(function (t) { var n = e.charCoords(t.head, "div").top + 5; return e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: n }, "div") }, _a) }, goLineLeft: function (e) { e.extendSelectionsBy(function (t) { var n = e.charCoords(t.head, "div").top + 5; return e.coordsChar({ left: 0, top: n }, "div") }, _a) }, goLineLeftSmart: function (e) { e.extendSelectionsBy(function (t) { var n = e.charCoords(t.head, "div").top + 5, r = e.coordsChar({ left: 0, top: n }, "div"); return r.ch < e.getLine(r.line).search(/\S/) ? lo(e, t.head) : r }, _a) }, goLineUp: function (e) { e.moveV(-1, "line") }, goLineDown: function (e) { e.moveV(1, "line") }, goPageUp: function (e) { e.moveV(-1, "page") }, goPageDown: function (e) { e.moveV(1, "page") }, goCharLeft: function (e) { e.moveH(-1, "char") }, goCharRight: function (e) { e.moveH(1, "char") }, goColumnLeft: function (e) { e.moveH(-1, "column") }, goColumnRight: function (e) { e.moveH(1, "column") }, goWordLeft: function (e) { e.moveH(-1, "word") }, goGroupRight: function (e) { e.moveH(1, "group") }, goGroupLeft: function (e) { e.moveH(-1, "group") }, goWordRight: function (e) { e.moveH(1, "word") }, delCharBefore: function (e) { e.deleteH(-1, "char") }, delCharAfter: function (e) { e.deleteH(1, "char") }, delWordBefore: function (e) { e.deleteH(-1, "word") }, delWordAfter: function (e) { e.deleteH(1, "word") }, delGroupBefore: function (e) { e.deleteH(-1, "group") }, delGroupAfter: function (e) { e.deleteH(1, "group") }, indentAuto: function (e) { e.indentSelection("smart") }, indentMore: function (e) { e.indentSelection("add") }, indentLess: function (e) { e.indentSelection("subtract") }, insertTab: function (e) { e.replaceSelection("	") }, insertSoftTab: function (e) { for (var t = [], n = e.listSelections(), r = e.options.tabSize, i = 0; i < n.length; i++) { var o = n[i].from(), a = Fa(e.getLine(o.line), o.ch, r); t.push(Oi(r - a % r)) } e.replaceSelections(t) }, defaultTab: function (e) { e.somethingSelected() ? e.indentSelection("add") : e.execCommand("insertTab") }, transposeChars: function (e) { At(e, function () { for (var t = e.listSelections(), n = [], r = 0; r < t.length; r++) { var i = t[r].head, o = Zr(e.doc, i.line).text; if (o) if (i.ch == o.length && (i = new Bo(i.line, i.ch - 1)), i.ch > 0) i = new Bo(i.line, i.ch + 1), e.replaceRange(o.charAt(i.ch - 1) + o.charAt(i.ch - 2), Bo(i.line, i.ch - 2), i, "+transpose"); else if (i.line > e.doc.first) { var a = Zr(e.doc, i.line - 1).text; a && e.replaceRange(o.charAt(0) + e.doc.lineSeparator() + a.charAt(a.length - 1), Bo(i.line - 1, a.length - 1), Bo(i.line, 1), "+transpose") } n.push(new fe(i, i)) } e.setSelections(n) }) }, newlineAndIndent: function (e) { At(e, function () { for (var t = e.listSelections().length, n = 0; t > n; n++) { var r = e.listSelections()[n]; e.replaceRange(e.doc.lineSeparator(), r.anchor, r.head, "+input"), e.indentLine(r.from().line + 1, null, !0) } Bn(e) }) }, openLine: function (e) { e.replaceSelection("\n", "start") }, toggleOverwrite: function (e) { e.toggleOverwrite() } }, fa = e.keyMap = {}; fa.basic = { Left: "goCharLeft", Right: "goCharRight", Up: "goLineUp", Down: "goLineDown", End: "goLineEnd", Home: "goLineStartSmart", PageUp: "goPageUp", PageDown: "goPageDown", Delete: "delCharAfter", Backspace: "delCharBefore", "Shift-Backspace": "delCharBefore", Tab: "defaultTab", "Shift-Tab": "indentAuto", Enter: "newlineAndIndent", Insert: "toggleOverwrite", Esc: "singleSelection" }, fa.pcDefault = { "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo", "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown", "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd", "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find", "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll", "Ctrl-[": "indentLess", "Ctrl-]": "indentMore", "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection", fallthrough: "basic" }, fa.emacsy = { "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown", "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars", "Ctrl-O": "openLine" }, fa.macDefault = { "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo", "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft", "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore", "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find", "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll", "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight", "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd", fallthrough: ["basic", "emacsy"] }, fa["default"] = Eo ? fa.macDefault : fa.pcDefault, e.normalizeKeyMap = function (e) { var t = {}; for (var n in e) if (e.hasOwnProperty(n)) { var r = e[n]; if (/^(name|fallthrough|(de|at)tach)$/.test(n)) continue; if ("..." == r) { delete e[n]; continue } for (var i = Ri(n.split(" "), Yn), o = 0; o < i.length; o++) { var a, l; o == i.length - 1 ? (l = i.join(" "), a = r) : (l = i.slice(0, o + 1).join(" "), a = "..."); var s = t[l]; if (s) { if (s != a) throw new Error("Inconsistent bindings for " + l) } else t[l] = a } delete e[n] } for (var c in t) e[c] = t[c]; return e }; var ha = e.lookupKey = function (e, t, n, r) {
                    t = $n(t); var i = t.call ? t.call(e, r) : t[e]; if (i === !1) return "nothing"; if ("..." === i) return "multi"; if (null != i && n(i)) return "handled"; if (t.fallthrough) {
                        if ("[object Array]" != Object.prototype.toString.call(t.fallthrough)) return ha(e, t.fallthrough, n, r); for (var o = 0; o < t.fallthrough.length; o++) {
                            var a = ha(e, t.fallthrough[o], n, r);
                            if (a) return a
                        }
                    }
                }, da = e.isModifierKey = function (e) { var t = "string" == typeof e ? e : ol[e.keyCode]; return "Ctrl" == t || "Alt" == t || "Shift" == t || "Mod" == t }, pa = e.keyName = function (e, t) { if (Co && 34 == e.keyCode && e["char"]) return !1; var n = ol[e.keyCode], r = n; return null == r || e.altGraphKey ? !1 : (e.altKey && "Alt" != n && (r = "Alt-" + r), (Ro ? e.metaKey : e.ctrlKey) && "Ctrl" != n && (r = "Ctrl-" + r), (Ro ? e.ctrlKey : e.metaKey) && "Cmd" != n && (r = "Cmd-" + r), !t && e.shiftKey && "Shift" != n && (r = "Shift-" + r), r) }; e.fromTextArea = function (t, n) { function r() { t.value = c.getValue() } if (n = n ? Wi(n) : {}, n.value = t.value, !n.tabindex && t.tabIndex && (n.tabindex = t.tabIndex), !n.placeholder && t.placeholder && (n.placeholder = t.placeholder), null == n.autofocus) { var i = Gi(); n.autofocus = i == t || null != t.getAttribute("autofocus") && i == document.body } if (t.form && (Ea(t.form, "submit", r), !n.leaveSubmitMethodAlone)) { var o = t.form, a = o.submit; try { var l = o.submit = function () { r(), o.submit = a, o.submit(), o.submit = l } } catch (s) { } } n.finishInit = function (e) { e.save = r, e.getTextArea = function () { return t }, e.toTextArea = function () { e.toTextArea = isNaN, r(), t.parentNode.removeChild(e.getWrapperElement()), t.style.display = "", t.form && (Ia(t.form, "submit", r), "function" == typeof t.form.submit && (t.form.submit = a)) } }, t.style.display = "none"; var c = e(function (e) { t.parentNode.insertBefore(e, t.nextSibling) }, n); return c }; var ma = e.StringStream = function (e, t) { this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0 }; ma.prototype = { eol: function () { return this.pos >= this.string.length }, sol: function () { return this.pos == this.lineStart }, peek: function () { return this.string.charAt(this.pos) || void 0 }, next: function () { return this.pos < this.string.length ? this.string.charAt(this.pos++) : void 0 }, eat: function (e) { var t = this.string.charAt(this.pos); if ("string" == typeof e) var n = t == e; else var n = t && (e.test ? e.test(t) : e(t)); return n ? (++this.pos, t) : void 0 }, eatWhile: function (e) { for (var t = this.pos; this.eat(e);); return this.pos > t }, eatSpace: function () { for (var e = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos; return this.pos > e }, skipToEnd: function () { this.pos = this.string.length }, skipTo: function (e) { var t = this.string.indexOf(e, this.pos); return t > -1 ? (this.pos = t, !0) : void 0 }, backUp: function (e) { this.pos -= e }, column: function () { return this.lastColumnPos < this.start && (this.lastColumnValue = Fa(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? Fa(this.string, this.lineStart, this.tabSize) : 0) }, indentation: function () { return Fa(this.string, null, this.tabSize) - (this.lineStart ? Fa(this.string, this.lineStart, this.tabSize) : 0) }, match: function (e, t, n) { if ("string" != typeof e) { var r = this.string.slice(this.pos).match(e); return r && r.index > 0 ? null : (r && t !== !1 && (this.pos += r[0].length), r) } var i = function (e) { return n ? e.toLowerCase() : e }, o = this.string.substr(this.pos, e.length); return i(o) == i(e) ? (t !== !1 && (this.pos += e.length), !0) : void 0 }, current: function () { return this.string.slice(this.start, this.pos) }, hideFirstChars: function (e, t) { this.lineStart += e; try { return t() } finally { this.lineStart -= e } } }; var ga = 0, va = e.TextMarker = function (e, t) { this.lines = [], this.type = t, this.doc = e, this.id = ++ga }; Ai(va), va.prototype.clear = function () { if (!this.explicitlyCleared) { var e = this.doc.cm, t = e && !e.curOp; if (t && bt(e), Ni(this, "clear")) { var n = this.find(); n && Ci(this, "clear", n.from, n.to) } for (var r = null, i = null, o = 0; o < this.lines.length; ++o) { var a = this.lines[o], l = er(a.markedSpans, this); e && !this.collapsed ? Ht(e, ti(a), "text") : e && (null != l.to && (i = ti(a)), null != l.from && (r = ti(a))), a.markedSpans = tr(a.markedSpans, l), null == l.from && this.collapsed && !kr(this.doc, a) && e && ei(a, yt(e.display)) } if (e && this.collapsed && !e.options.lineWrapping) for (var o = 0; o < this.lines.length; ++o) { var s = yr(this.lines[o]), c = f(s); c > e.display.maxLineLength && (e.display.maxLine = s, e.display.maxLineLength = c, e.display.maxLineChanged = !0) } null != r && e && this.collapsed && Dt(e, r, i + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && Ae(e.doc)), e && Ci(e, "markerCleared", e, this), t && kt(e), this.parent && this.parent.clear() } }, va.prototype.find = function (e, t) { null == e && "bookmark" == this.type && (e = 1); for (var n, r, i = 0; i < this.lines.length; ++i) { var o = this.lines[i], a = er(o.markedSpans, this); if (null != a.from && (n = Bo(t ? o : ti(o), a.from), -1 == e)) return n; if (null != a.to && (r = Bo(t ? o : ti(o), a.to), 1 == e)) return r } return n && { from: n, to: r } }, va.prototype.changed = function () { var e = this.find(-1, !0), t = this, n = this.doc.cm; e && n && At(n, function () { var r = e.line, i = ti(e.line), o = Qe(n, i); if (o && (ot(o), n.curOp.selectionChanged = n.curOp.forceUpdate = !0), n.curOp.updateMaxLine = !0, !kr(t.doc, r) && null != t.height) { var a = t.height; t.height = null; var l = Lr(t) - a; l && ei(r, r.height + l) } }) }, va.prototype.attachLine = function (e) { if (!this.lines.length && this.doc.cm) { var t = this.doc.cm.curOp; t.maybeHiddenMarkers && -1 != Pi(t.maybeHiddenMarkers, this) || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this) } this.lines.push(e) }, va.prototype.detachLine = function (e) { if (this.lines.splice(Pi(this.lines, e), 1), !this.lines.length && this.doc.cm) { var t = this.doc.cm.curOp; (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this) } }; var ga = 0, ya = e.SharedTextMarker = function (e, t) { this.markers = e, this.primary = t; for (var n = 0; n < e.length; ++n)e[n].parent = this }; Ai(ya), ya.prototype.clear = function () { if (!this.explicitlyCleared) { this.explicitlyCleared = !0; for (var e = 0; e < this.markers.length; ++e)this.markers[e].clear(); Ci(this, "clear") } }, ya.prototype.find = function (e, t) { return this.primary.find(e, t) }; var xa = e.LineWidget = function (e, t, n) { if (n) for (var r in n) n.hasOwnProperty(r) && (this[r] = n[r]); this.doc = e, this.node = t }; Ai(xa), xa.prototype.clear = function () { var e = this.doc.cm, t = this.line.widgets, n = this.line, r = ti(n); if (null != r && t) { for (var i = 0; i < t.length; ++i)t[i] == this && t.splice(i--, 1); t.length || (n.widgets = null); var o = Lr(this); ei(n, Math.max(0, n.height - o)), e && At(e, function () { Cr(e, n, -o), Ht(e, r, "widget") }) } }, xa.prototype.changed = function () { var e = this.height, t = this.doc.cm, n = this.line; this.height = null; var r = Lr(this) - e; r && (ei(n, n.height + r), t && At(t, function () { t.curOp.forceUpdate = !0, Cr(t, n, r) })) }; var ba = e.Line = function (e, t, n) { this.text = e, ur(this, t), this.height = n ? n(this) : 1 }; Ai(ba), ba.prototype.lineNo = function () { return ti(this) }; var wa = {}, ka = {}; $r.prototype = { chunkSize: function () { return this.lines.length }, removeInner: function (e, t) { for (var n = e, r = e + t; r > n; ++n) { var i = this.lines[n]; this.height -= i.height, Nr(i), Ci(i, "delete") } this.lines.splice(e, t) }, collapse: function (e) { e.push.apply(e, this.lines) }, insertInner: function (e, t, n) { this.height += n, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e)); for (var r = 0; r < t.length; ++r)t[r].parent = this }, iterN: function (e, t, n) { for (var r = e + t; r > e; ++e)if (n(this.lines[e])) return !0 } }, Vr.prototype = { chunkSize: function () { return this.size }, removeInner: function (e, t) { this.size -= t; for (var n = 0; n < this.children.length; ++n) { var r = this.children[n], i = r.chunkSize(); if (i > e) { var o = Math.min(t, i - e), a = r.height; if (r.removeInner(e, o), this.height -= a - r.height, i == o && (this.children.splice(n--, 1), r.parent = null), 0 == (t -= o)) break; e = 0 } else e -= i } if (this.size - t < 25 && (this.children.length > 1 || !(this.children[0] instanceof $r))) { var l = []; this.collapse(l), this.children = [new $r(l)], this.children[0].parent = this } }, collapse: function (e) { for (var t = 0; t < this.children.length; ++t)this.children[t].collapse(e) }, insertInner: function (e, t, n) { this.size += t.length, this.height += n; for (var r = 0; r < this.children.length; ++r) { var i = this.children[r], o = i.chunkSize(); if (o >= e) { if (i.insertInner(e, t, n), i.lines && i.lines.length > 50) { for (var a = i.lines.length % 25 + 25, l = a; l < i.lines.length;) { var s = new $r(i.lines.slice(l, l += 25)); i.height -= s.height, this.children.splice(++r, 0, s), s.parent = this } i.lines = i.lines.slice(0, a), this.maybeSpill() } break } e -= o } }, maybeSpill: function () { if (!(this.children.length <= 10)) { var e = this; do { var t = e.children.splice(e.children.length - 5, 5), n = new Vr(t); if (e.parent) { e.size -= n.size, e.height -= n.height; var r = Pi(e.parent.children, e); e.parent.children.splice(r + 1, 0, n) } else { var i = new Vr(e.children); i.parent = e, e.children = [i, n], e = i } n.parent = e.parent } while (e.children.length > 10); e.parent.maybeSpill() } }, iterN: function (e, t, n) { for (var r = 0; r < this.children.length; ++r) { var i = this.children[r], o = i.chunkSize(); if (o > e) { var a = Math.min(t, o - e); if (i.iterN(e, a, n)) return !0; if (0 == (t -= a)) break; e = 0 } else e -= o } } }; var Sa = 0, Ca = e.Doc = function (e, t, n, r) { if (!(this instanceof Ca)) return new Ca(e, t, n, r); null == n && (n = 0), Vr.call(this, [new $r([new ba("", null)])]), this.first = n, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.frontier = n; var i = Bo(n, 0); this.sel = de(i), this.history = new oi(null), this.id = ++Sa, this.modeOption = t, this.lineSep = r, this.extend = !1, "string" == typeof e && (e = this.splitLines(e)), Yr(this, { from: i, to: i, text: e }), Te(this, de(i), Wa) }; Ca.prototype = Hi(Vr.prototype, { constructor: Ca, iter: function (e, t, n) { n ? this.iterN(e - this.first, t - e, n) : this.iterN(this.first, this.first + this.size, e) }, insert: function (e, t) { for (var n = 0, r = 0; r < t.length; ++r)n += t[r].height; this.insertInner(e - this.first, t, n) }, remove: function (e, t) { this.removeInner(e - this.first, t) }, getValue: function (e) { var t = Qr(this, this.first, this.first + this.size); return e === !1 ? t : t.join(e || this.lineSeparator()) }, setValue: It(function (e) { var t = Bo(this.first, 0), n = this.first + this.size - 1; Tn(this, { from: t, to: Bo(n, Zr(this, n).text.length), text: this.splitLines(e), origin: "setValue", full: !0 }, !0), Te(this, de(t)) }), replaceRange: function (e, t, n, r) { t = me(this, t), n = n ? me(this, n) : t, In(this, e, t, n, r) }, getRange: function (e, t, n) { var r = Jr(this, me(this, e), me(this, t)); return n === !1 ? r : r.join(n || this.lineSeparator()) }, getLine: function (e) { var t = this.getLineHandle(e); return t && t.text }, getLineHandle: function (e) { return ve(this, e) ? Zr(this, e) : void 0 }, getLineNumber: function (e) { return ti(e) }, getLineHandleVisualStart: function (e) { return "number" == typeof e && (e = Zr(this, e)), yr(e) }, lineCount: function () { return this.size }, firstLine: function () { return this.first }, lastLine: function () { return this.first + this.size - 1 }, clipPos: function (e) { return me(this, e) }, getCursor: function (e) { var t, n = this.sel.primary(); return t = null == e || "head" == e ? n.head : "anchor" == e ? n.anchor : "end" == e || "to" == e || e === !1 ? n.to() : n.from() }, listSelections: function () { return this.sel.ranges }, somethingSelected: function () { return this.sel.somethingSelected() }, setCursor: It(function (e, t, n) { Se(this, me(this, "number" == typeof e ? Bo(e, t || 0) : e), null, n) }), setSelection: It(function (e, t, n) { Se(this, me(this, e), me(this, t || e), n) }), extendSelection: It(function (e, t, n) { be(this, me(this, e), t && me(this, t), n) }), extendSelections: It(function (e, t) { we(this, ye(this, e), t) }), extendSelectionsBy: It(function (e, t) { var n = Ri(this.sel.ranges, e); we(this, ye(this, n), t) }), setSelections: It(function (e, t, n) { if (e.length) { for (var r = 0, i = []; r < e.length; r++)i[r] = new fe(me(this, e[r].anchor), me(this, e[r].head)); null == t && (t = Math.min(e.length - 1, this.sel.primIndex)), Te(this, he(i, t), n) } }), addSelection: It(function (e, t, n) { var r = this.sel.ranges.slice(0); r.push(new fe(me(this, e), me(this, t || e))), Te(this, he(r, r.length - 1), n) }), getSelection: function (e) { for (var t, n = this.sel.ranges, r = 0; r < n.length; r++) { var i = Jr(this, n[r].from(), n[r].to()); t = t ? t.concat(i) : i } return e === !1 ? t : t.join(e || this.lineSeparator()) }, getSelections: function (e) { for (var t = [], n = this.sel.ranges, r = 0; r < n.length; r++) { var i = Jr(this, n[r].from(), n[r].to()); e !== !1 && (i = i.join(e || this.lineSeparator())), t[r] = i } return t }, replaceSelection: function (e, t, n) { for (var r = [], i = 0; i < this.sel.ranges.length; i++)r[i] = e; this.replaceSelections(r, t, n || "+input") }, replaceSelections: It(function (e, t, n) { for (var r = [], i = this.sel, o = 0; o < i.ranges.length; o++) { var a = i.ranges[o]; r[o] = { from: a.from(), to: a.to(), text: this.splitLines(e[o]), origin: n } } for (var l = t && "end" != t && Cn(this, r, t), o = r.length - 1; o >= 0; o--)Tn(this, r[o]); l ? Le(this, l) : this.cm && Bn(this.cm) }), undo: It(function () { Nn(this, "undo") }), redo: It(function () { Nn(this, "redo") }), undoSelection: It(function () { Nn(this, "undo", !0) }), redoSelection: It(function () { Nn(this, "redo", !0) }), setExtending: function (e) { this.extend = e }, getExtending: function () { return this.extend }, historySize: function () { for (var e = this.history, t = 0, n = 0, r = 0; r < e.done.length; r++)e.done[r].ranges || ++t; for (var r = 0; r < e.undone.length; r++)e.undone[r].ranges || ++n; return { undo: t, redo: n } }, clearHistory: function () { this.history = new oi(this.history.maxGeneration) }, markClean: function () { this.cleanGeneration = this.changeGeneration(!0) }, changeGeneration: function (e) { return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation }, isClean: function (e) { return this.history.generation == (e || this.cleanGeneration) }, getHistory: function () { return { done: gi(this.history.done), undone: gi(this.history.undone) } }, setHistory: function (e) { var t = this.history = new oi(this.history.maxGeneration); t.done = gi(e.done.slice(0), null, !0), t.undone = gi(e.undone.slice(0), null, !0) }, addLineClass: It(function (e, t, n) { return zn(this, e, "gutter" == t ? "gutter" : "class", function (e) { var r = "text" == t ? "textClass" : "background" == t ? "bgClass" : "gutter" == t ? "gutterClass" : "wrapClass"; if (e[r]) { if (Yi(n).test(e[r])) return !1; e[r] += " " + n } else e[r] = n; return !0 }) }), removeLineClass: It(function (e, t, n) { return zn(this, e, "gutter" == t ? "gutter" : "class", function (e) { var r = "text" == t ? "textClass" : "background" == t ? "bgClass" : "gutter" == t ? "gutterClass" : "wrapClass", i = e[r]; if (!i) return !1; if (null == n) e[r] = null; else { var o = i.match(Yi(n)); if (!o) return !1; var a = o.index + o[0].length; e[r] = i.slice(0, o.index) + (o.index && a != i.length ? " " : "") + i.slice(a) || null } return !0 }) }), addLineWidget: It(function (e, t, n) { return Tr(this, e, t, n) }), removeLineWidget: function (e) { e.clear() }, markText: function (e, t, n) { return Vn(this, me(this, e), me(this, t), n, n && n.type || "range") }, setBookmark: function (e, t) { var n = { replacedWith: t && (null == t.nodeType ? t.widget : t), insertLeft: t && t.insertLeft, clearWhenEmpty: !1, shared: t && t.shared, handleMouseEvents: t && t.handleMouseEvents }; return e = me(this, e), Vn(this, e, e, n, "bookmark") }, findMarksAt: function (e) { e = me(this, e); var t = [], n = Zr(this, e.line).markedSpans; if (n) for (var r = 0; r < n.length; ++r) { var i = n[r]; (null == i.from || i.from <= e.ch) && (null == i.to || i.to >= e.ch) && t.push(i.marker.parent || i.marker) } return t }, findMarks: function (e, t, n) { e = me(this, e), t = me(this, t); var r = [], i = e.line; return this.iter(e.line, t.line + 1, function (o) { var a = o.markedSpans; if (a) for (var l = 0; l < a.length; l++) { var s = a[l]; null != s.to && i == e.line && e.ch >= s.to || null == s.from && i != e.line || null != s.from && i == t.line && s.from >= t.ch || n && !n(s.marker) || r.push(s.marker.parent || s.marker) } ++i }), r }, getAllMarks: function () { var e = []; return this.iter(function (t) { var n = t.markedSpans; if (n) for (var r = 0; r < n.length; ++r)null != n[r].from && e.push(n[r].marker) }), e }, posFromIndex: function (e) { var t, n = this.first, r = this.lineSeparator().length; return this.iter(function (i) { var o = i.text.length + r; return o > e ? (t = e, !0) : (e -= o, void ++n) }), me(this, Bo(n, t)) }, indexFromPos: function (e) { e = me(this, e); var t = e.ch; if (e.line < this.first || e.ch < 0) return 0; var n = this.lineSeparator().length; return this.iter(this.first, e.line, function (e) { t += e.text.length + n }), t }, copy: function (e) { var t = new Ca(Qr(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep); return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t }, linkedDoc: function (e) { e || (e = {}); var t = this.first, n = this.first + this.size; null != e.from && e.from > t && (t = e.from), null != e.to && e.to < n && (n = e.to); var r = new Ca(Qr(this, t, n), e.mode || this.modeOption, t, this.lineSep); return e.sharedHist && (r.history = this.history), (this.linked || (this.linked = [])).push({ doc: r, sharedHist: e.sharedHist }), r.linked = [{ doc: this, isParent: !0, sharedHist: e.sharedHist }], Zn(r, Xn(this)), r }, unlinkDoc: function (t) { if (t instanceof e && (t = t.doc), this.linked) for (var n = 0; n < this.linked.length; ++n) { var r = this.linked[n]; if (r.doc == t) { this.linked.splice(n, 1), t.unlinkDoc(this), Jn(Xn(this)); break } } if (t.history == this.history) { var i = [t.id]; Kr(t, function (e) { i.push(e.id) }, !0), t.history = new oi(null), t.history.done = gi(this.history.done, i), t.history.undone = gi(this.history.undone, i) } }, iterLinkedDocs: function (e) { Kr(this, e) }, getMode: function () { return this.mode }, getEditor: function () { return this.cm }, splitLines: function (e) { return this.lineSep ? e.split(this.lineSep) : tl(e) }, lineSeparator: function () { return this.lineSep || "\n" } }), Ca.prototype.eachLine = Ca.prototype.iter; var La = "iter insert remove copy getEditor constructor".split(" "); for (var Ta in Ca.prototype) Ca.prototype.hasOwnProperty(Ta) && Pi(La, Ta) < 0 && (e.prototype[Ta] = function (e) { return function () { return e.apply(this.doc, arguments) } }(Ca.prototype[Ta])); Ai(Ca); var Ma = e.e_preventDefault = function (e) { e.preventDefault ? e.preventDefault() : e.returnValue = !1 }, Na = e.e_stopPropagation = function (e) { e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0 }, Aa = e.e_stop = function (e) { Ma(e), Na(e) }, Ea = e.on = function (e, t, n) { if (e.addEventListener) e.addEventListener(t, n, !1); else if (e.attachEvent) e.attachEvent("on" + t, n); else { var r = e._handlers || (e._handlers = {}), i = r[t] || (r[t] = []); i.push(n) } }, Oa = [], Ia = e.off = function (e, t, n) { if (e.removeEventListener) e.removeEventListener(t, n, !1); else if (e.detachEvent) e.detachEvent("on" + t, n); else for (var r = Si(e, t, !1), i = 0; i < r.length; ++i)if (r[i] == n) { r.splice(i, 1); break } }, Pa = e.signal = function (e, t) { var n = Si(e, t, !0); if (n.length) for (var r = Array.prototype.slice.call(arguments, 2), i = 0; i < n.length; ++i)n[i].apply(null, r) }, Ra = null, Da = 30, Ha = e.Pass = { toString: function () { return "CodeMirror.Pass" } }, Wa = { scroll: !1 }, Ba = { origin: "*mouse" }, _a = { origin: "+move" }; Ei.prototype.set = function (e, t) { clearTimeout(this.id), this.id = setTimeout(t, e) }; var Fa = e.countColumn = function (e, t, n, r, i) { null == t && (t = e.search(/[^\s\u00a0]/), -1 == t && (t = e.length)); for (var o = r || 0, a = i || 0; ;) { var l = e.indexOf("	", o); if (0 > l || l >= t) return a + (t - o); a += l - o, a += n - a % n, o = l + 1 } }, za = e.findColumn = function (e, t, n) { for (var r = 0, i = 0; ;) { var o = e.indexOf("	", r); -1 == o && (o = e.length); var a = o - r; if (o == e.length || i + a >= t) return r + Math.min(a, t - i); if (i += o - r, i += n - i % n, r = o + 1, i >= t) return r } }, ja = [""], Ua = function (e) { e.select() }; No ? Ua = function (e) { e.selectionStart = 0, e.selectionEnd = e.value.length } : xo && (Ua = function (e) { try { e.select() } catch (t) { } }); var qa, Ga = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/, Ya = e.isWordChar = function (e) { return /\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || Ga.test(e)) }, $a = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/; qa = document.createRange ? function (e, t, n, r) { var i = document.createRange(); return i.setEnd(r || e, n), i.setStart(e, t), i } : function (e, t, n) { var r = document.body.createTextRange(); try { r.moveToElementText(e.parentNode) } catch (i) { return r } return r.collapse(!0), r.moveEnd("character", n), r.moveStart("character", t), r }; var Va = e.contains = function (e, t) { if (3 == t.nodeType && (t = t.parentNode), e.contains) return e.contains(t); do if (11 == t.nodeType && (t = t.host), t == e) return !0; while (t = t.parentNode) }; xo && 11 > bo && (Gi = function () { try { return document.activeElement } catch (e) { return document.body } }); var Ka, Xa, Za = e.rmClass = function (e, t) { var n = e.className, r = Yi(t).exec(n); if (r) { var i = n.slice(r.index + r[0].length); e.className = n.slice(0, r.index) + (i ? r[1] + i : "") } }, Ja = e.addClass = function (e, t) { var n = e.className; Yi(t).test(n) || (e.className += (n ? " " : "") + t) }, Qa = !1, el = function () { if (xo && 9 > bo) return !1; var e = ji("div"); return "draggable" in e || "dragDrop" in e }(), tl = e.splitLines = 3 != "\n\nb".split(/\n/).length ? function (e) { for (var t = 0, n = [], r = e.length; r >= t;) { var i = e.indexOf("\n", t); -1 == i && (i = e.length); var o = e.slice(t, "\r" == e.charAt(i - 1) ? i - 1 : i), a = o.indexOf("\r"); -1 != a ? (n.push(o.slice(0, a)), t += a + 1) : (n.push(o), t = i + 1) } return n } : function (e) { return e.split(/\r\n?|\n/) }, nl = window.getSelection ? function (e) { try { return e.selectionStart != e.selectionEnd } catch (t) { return !1 } } : function (e) { try { var t = e.ownerDocument.selection.createRange() } catch (n) { } return t && t.parentElement() == e ? 0 != t.compareEndPoints("StartToEnd", t) : !1 }, rl = function () { var e = ji("div"); return "oncopy" in e ? !0 : (e.setAttribute("oncopy", "return;"), "function" == typeof e.oncopy) }(), il = null, ol = e.keyNames = { 3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete", 63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert" }; !function () { for (var e = 0; 10 > e; e++)ol[e + 48] = ol[e + 96] = String(e); for (var e = 65; 90 >= e; e++)ol[e] = String.fromCharCode(e); for (var e = 1; 12 >= e; e++)ol[e + 111] = ol[e + 63235] = "F" + e }(); var al, ll = function () { function e(e) { return 247 >= e ? n.charAt(e) : e >= 1424 && 1524 >= e ? "R" : e >= 1536 && 1773 >= e ? r.charAt(e - 1536) : e >= 1774 && 2220 >= e ? "r" : e >= 8192 && 8203 >= e ? "w" : 8204 == e ? "b" : "L" } function t(e, t, n) { this.level = e, this.from = t, this.to = n } var n = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", r = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm", i = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, o = /[stwN]/, a = /[LRr]/, l = /[Lb1n]/, s = /[1n]/, c = "L"; return function (n) { if (!i.test(n)) return !1; for (var r, u = n.length, f = [], h = 0; u > h; ++h)f.push(r = e(n.charCodeAt(h))); for (var h = 0, d = c; u > h; ++h) { var r = f[h]; "m" == r ? f[h] = d : d = r } for (var h = 0, p = c; u > h; ++h) { var r = f[h]; "1" == r && "r" == p ? f[h] = "n" : a.test(r) && (p = r, "r" == r && (f[h] = "R")) } for (var h = 1, d = f[0]; u - 1 > h; ++h) { var r = f[h]; "+" == r && "1" == d && "1" == f[h + 1] ? f[h] = "1" : "," != r || d != f[h + 1] || "1" != d && "n" != d || (f[h] = d), d = r } for (var h = 0; u > h; ++h) { var r = f[h]; if ("," == r) f[h] = "N"; else if ("%" == r) { for (var m = h + 1; u > m && "%" == f[m]; ++m); for (var g = h && "!" == f[h - 1] || u > m && "1" == f[m] ? "1" : "N", v = h; m > v; ++v)f[v] = g; h = m - 1 } } for (var h = 0, p = c; u > h; ++h) { var r = f[h]; "L" == p && "1" == r ? f[h] = "L" : a.test(r) && (p = r) } for (var h = 0; u > h; ++h)if (o.test(f[h])) { for (var m = h + 1; u > m && o.test(f[m]); ++m); for (var y = "L" == (h ? f[h - 1] : c), x = "L" == (u > m ? f[m] : c), g = y || x ? "L" : "R", v = h; m > v; ++v)f[v] = g; h = m - 1 } for (var b, w = [], h = 0; u > h;)if (l.test(f[h])) { var k = h; for (++h; u > h && l.test(f[h]); ++h); w.push(new t(0, k, h)) } else { var S = h, C = w.length; for (++h; u > h && "L" != f[h]; ++h); for (var v = S; h > v;)if (s.test(f[v])) { v > S && w.splice(C, 0, new t(1, S, v)); var L = v; for (++v; h > v && s.test(f[v]); ++v); w.splice(C, 0, new t(2, L, v)), S = v } else ++v; h > S && w.splice(C, 0, new t(1, S, h)) } return 1 == w[0].level && (b = n.match(/^\s+/)) && (w[0].from = b[0].length, w.unshift(new t(0, 0, b[0].length))), 1 == Ii(w).level && (b = n.match(/\s+$/)) && (Ii(w).to -= b[0].length, w.push(new t(0, u - b[0].length, u))), 2 == w[0].level && w.unshift(new t(1, w[0].to, w[0].to)), w[0].level != Ii(w).level && w.push(new t(w[0].level, u, u)), w } }(); return e.version = "5.15.2", e
            })
        }, {}], 11: [function (t, n, r) { !function (i) { "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror"), t("../markdown/markdown"), t("../../addon/mode/overlay")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], i) : i(CodeMirror) }(function (e) { "use strict"; var t = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?«»“”‘’]))/i; e.defineMode("gfm", function (n, r) { function i(e) { return e.code = !1, null } var o = 0, a = { startState: function () { return { code: !1, codeBlock: !1, ateSpace: !1 } }, copyState: function (e) { return { code: e.code, codeBlock: e.codeBlock, ateSpace: e.ateSpace } }, token: function (e, n) { if (n.combineTokens = null, n.codeBlock) return e.match(/^```+/) ? (n.codeBlock = !1, null) : (e.skipToEnd(), null); if (e.sol() && (n.code = !1), e.sol() && e.match(/^```+/)) return e.skipToEnd(), n.codeBlock = !0, null; if ("`" === e.peek()) { e.next(); var i = e.pos; e.eatWhile("`"); var a = 1 + e.pos - i; return n.code ? a === o && (n.code = !1) : (o = a, n.code = !0), null } if (n.code) return e.next(), null; if (e.eatSpace()) return n.ateSpace = !0, null; if ((e.sol() || n.ateSpace) && (n.ateSpace = !1, r.gitHubSpice !== !1)) { if (e.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/)) return n.combineTokens = !0, "link"; if (e.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) return n.combineTokens = !0, "link" } return e.match(t) && "](" != e.string.slice(e.start - 2, e.start) && (0 == e.start || /\W/.test(e.string.charAt(e.start - 1))) ? (n.combineTokens = !0, "link") : (e.next(), null) }, blankLine: i }, l = { underscoresBreakWords: !1, taskLists: !0, fencedCodeBlocks: "```", strikethrough: !0 }; for (var s in r) l[s] = r[s]; return l.name = "markdown", e.overlayMode(e.getMode(n, l), a) }, "markdown"), e.defineMIME("text/x-gfm", "gfm") }) }, { "../../addon/mode/overlay": 8, "../../lib/codemirror": 10, "../markdown/markdown": 12 }], 12: [function (t, n, r) {
            !function (i) { "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror"), t("../xml/xml"), t("../meta")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror", "../xml/xml", "../meta"], i) : i(CodeMirror) }(function (e) {
                "use strict"; e.defineMode("markdown", function (t, n) {
                    function r(n) { if (e.findModeByName) { var r = e.findModeByName(n); r && (n = r.mime || r.mimes[0]) } var i = e.getMode(t, n); return "null" == i.name ? null : i } function i(e, t, n) { return t.f = t.inline = n, n(e, t) } function o(e, t, n) { return t.f = t.block = n, n(e, t) } function a(e) { return !e || !/\S/.test(e.string) } function l(e) { return e.linkTitle = !1, e.em = !1, e.strong = !1, e.strikethrough = !1, e.quote = 0, e.indentedCode = !1, k && e.f == c && (e.f = p, e.block = s), e.trailingSpace = 0, e.trailingSpaceNewLine = !1, e.prevLine = e.thisLine, e.thisLine = null, null } function s(t, o) { var l = t.sol(), s = o.list !== !1, c = o.indentedCode; o.indentedCode = !1, s && (o.indentationDiff >= 0 ? (o.indentationDiff < 4 && (o.indentation -= o.indentationDiff), o.list = null) : o.indentation > 0 ? o.list = null : o.list = !1); var f = null; if (o.indentationDiff >= 4) return t.skipToEnd(), c || a(o.prevLine) ? (o.indentation -= 4, o.indentedCode = !0, S.code) : null; if (t.eatSpace()) return null; if ((f = t.match(A)) && f[1].length <= 6) return o.header = f[1].length, n.highlightFormatting && (o.formatting = "header"), o.f = o.inline, h(o); if (!(a(o.prevLine) || o.quote || s || c) && (f = t.match(E))) return o.header = "=" == f[0].charAt(0) ? 1 : 2, n.highlightFormatting && (o.formatting = "header"), o.f = o.inline, h(o); if (t.eat(">")) return o.quote = l ? 1 : o.quote + 1, n.highlightFormatting && (o.formatting = "quote"), t.eatSpace(), h(o); if ("[" === t.peek()) return i(t, o, y); if (t.match(L, !0)) return o.hr = !0, S.hr; if ((a(o.prevLine) || s) && (t.match(T, !1) || t.match(M, !1))) { var d = null; for (t.match(T, !0) ? d = "ul" : (t.match(M, !0), d = "ol"), o.indentation = t.column() + t.current().length, o.list = !0; o.listStack && t.column() < o.listStack[o.listStack.length - 1];)o.listStack.pop(); return o.listStack.push(o.indentation), n.taskLists && t.match(N, !1) && (o.taskList = !0), o.f = o.inline, n.highlightFormatting && (o.formatting = ["list", "list-" + d]), h(o) } return n.fencedCodeBlocks && (f = t.match(I, !0)) ? (o.fencedChars = f[1], o.localMode = r(f[2]), o.localMode && (o.localState = e.startState(o.localMode)), o.f = o.block = u, n.highlightFormatting && (o.formatting = "code-block"), o.code = -1, h(o)) : i(t, o, o.inline) } function c(t, n) { var r = w.token(t, n.htmlState); if (!k) { var i = e.innerMode(w, n.htmlState); ("xml" == i.mode.name && null === i.state.tagStart && !i.state.context && i.state.tokenize.isInText || n.md_inside && t.current().indexOf(">") > -1) && (n.f = p, n.block = s, n.htmlState = null) } return r } function u(e, t) { return t.fencedChars && e.match(t.fencedChars, !1) ? (t.localMode = t.localState = null, t.f = t.block = f, null) : t.localMode ? t.localMode.token(e, t.localState) : (e.skipToEnd(), S.code) } function f(e, t) { e.match(t.fencedChars), t.block = s, t.f = p, t.fencedChars = null, n.highlightFormatting && (t.formatting = "code-block"), t.code = 1; var r = h(t); return t.code = 0, r } function h(e) { var t = []; if (e.formatting) { t.push(S.formatting), "string" == typeof e.formatting && (e.formatting = [e.formatting]); for (var r = 0; r < e.formatting.length; r++)t.push(S.formatting + "-" + e.formatting[r]), "header" === e.formatting[r] && t.push(S.formatting + "-" + e.formatting[r] + "-" + e.header), "quote" === e.formatting[r] && (!n.maxBlockquoteDepth || n.maxBlockquoteDepth >= e.quote ? t.push(S.formatting + "-" + e.formatting[r] + "-" + e.quote) : t.push("error")) } if (e.taskOpen) return t.push("meta"), t.length ? t.join(" ") : null; if (e.taskClosed) return t.push("property"), t.length ? t.join(" ") : null; if (e.linkHref ? t.push(S.linkHref, "url") : (e.strong && t.push(S.strong), e.em && t.push(S.em), e.strikethrough && t.push(S.strikethrough), e.linkText && t.push(S.linkText), e.code && t.push(S.code)), e.header && t.push(S.header, S.header + "-" + e.header), e.quote && (t.push(S.quote), !n.maxBlockquoteDepth || n.maxBlockquoteDepth >= e.quote ? t.push(S.quote + "-" + e.quote) : t.push(S.quote + "-" + n.maxBlockquoteDepth)), e.list !== !1) { var i = (e.listStack.length - 1) % 3; i ? 1 === i ? t.push(S.list2) : t.push(S.list3) : t.push(S.list1) } return e.trailingSpaceNewLine ? t.push("trailing-space-new-line") : e.trailingSpace && t.push("trailing-space-" + (e.trailingSpace % 2 ? "a" : "b")), t.length ? t.join(" ") : null } function d(e, t) { return e.match(O, !0) ? h(t) : void 0 } function p(t, r) {
                        var i = r.text(t, r); if ("undefined" != typeof i) return i; if (r.list) return r.list = null, h(r); if (r.taskList) { var a = "x" !== t.match(N, !0)[1]; return a ? r.taskOpen = !0 : r.taskClosed = !0, n.highlightFormatting && (r.formatting = "task"), r.taskList = !1, h(r) } if (r.taskOpen = !1, r.taskClosed = !1, r.header && t.match(/^#+$/, !0)) return n.highlightFormatting && (r.formatting = "header"),
                            h(r); var l = t.sol(), s = t.next(); if (r.linkTitle) { r.linkTitle = !1; var u = s; "(" === s && (u = ")"), u = (u + "").replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"); var f = "^\\s*(?:[^" + u + "\\\\]+|\\\\\\\\|\\\\.)" + u; if (t.match(new RegExp(f), !0)) return S.linkHref } if ("`" === s) { var d = r.formatting; n.highlightFormatting && (r.formatting = "code"), t.eatWhile("`"); var p = t.current().length; if (0 == r.code) return r.code = p, h(r); if (p == r.code) { var v = h(r); return r.code = 0, v } return r.formatting = d, h(r) } if (r.code) return h(r); if ("\\" === s && (t.next(), n.highlightFormatting)) { var y = h(r), x = S.formatting + "-escape"; return y ? y + " " + x : x } if ("!" === s && t.match(/\[[^\]]*\] ?(?:\(|\[)/, !1)) return t.match(/\[[^\]]*\]/), r.inline = r.f = g, S.image; if ("[" === s && t.match(/[^\]]*\](\(.*\)| ?\[.*?\])/, !1)) return r.linkText = !0, n.highlightFormatting && (r.formatting = "link"), h(r); if ("]" === s && r.linkText && t.match(/\(.*?\)| ?\[.*?\]/, !1)) { n.highlightFormatting && (r.formatting = "link"); var y = h(r); return r.linkText = !1, r.inline = r.f = g, y } if ("<" === s && t.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, !1)) { r.f = r.inline = m, n.highlightFormatting && (r.formatting = "link"); var y = h(r); return y ? y += " " : y = "", y + S.linkInline } if ("<" === s && t.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, !1)) { r.f = r.inline = m, n.highlightFormatting && (r.formatting = "link"); var y = h(r); return y ? y += " " : y = "", y + S.linkEmail } if ("<" === s && t.match(/^(!--|\w)/, !1)) { var b = t.string.indexOf(">", t.pos); if (-1 != b) { var k = t.string.substring(t.start, b); /markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(k) && (r.md_inside = !0) } return t.backUp(1), r.htmlState = e.startState(w), o(t, r, c) } if ("<" === s && t.match(/^\/\w*?>/)) return r.md_inside = !1, "tag"; var C = !1; if (!n.underscoresBreakWords && "_" === s && "_" !== t.peek() && t.match(/(\w)/, !1)) { var L = t.pos - 2; if (L >= 0) { var T = t.string.charAt(L); "_" !== T && T.match(/(\w)/, !1) && (C = !0) } } if ("*" === s || "_" === s && !C) if (l && " " === t.peek()); else { if (r.strong === s && t.eat(s)) { n.highlightFormatting && (r.formatting = "strong"); var v = h(r); return r.strong = !1, v } if (!r.strong && t.eat(s)) return r.strong = s, n.highlightFormatting && (r.formatting = "strong"), h(r); if (r.em === s) { n.highlightFormatting && (r.formatting = "em"); var v = h(r); return r.em = !1, v } if (!r.em) return r.em = s, n.highlightFormatting && (r.formatting = "em"), h(r) } else if (" " === s && (t.eat("*") || t.eat("_"))) { if (" " === t.peek()) return h(r); t.backUp(1) } if (n.strikethrough) if ("~" === s && t.eatWhile(s)) { if (r.strikethrough) { n.highlightFormatting && (r.formatting = "strikethrough"); var v = h(r); return r.strikethrough = !1, v } if (t.match(/^[^\s]/, !1)) return r.strikethrough = !0, n.highlightFormatting && (r.formatting = "strikethrough"), h(r) } else if (" " === s && t.match(/^~~/, !0)) { if (" " === t.peek()) return h(r); t.backUp(2) } return " " === s && (t.match(/ +$/, !1) ? r.trailingSpace++ : r.trailingSpace && (r.trailingSpaceNewLine = !0)), h(r)
                    } function m(e, t) { var r = e.next(); if (">" === r) { t.f = t.inline = p, n.highlightFormatting && (t.formatting = "link"); var i = h(t); return i ? i += " " : i = "", i + S.linkInline } return e.match(/^[^>]+/, !0), S.linkInline } function g(e, t) { if (e.eatSpace()) return null; var r = e.next(); return "(" === r || "[" === r ? (t.f = t.inline = v("(" === r ? ")" : "]", 0), n.highlightFormatting && (t.formatting = "link-string"), t.linkHref = !0, h(t)) : "error" } function v(e) { return function (t, r) { var i = t.next(); if (i === e) { r.f = r.inline = p, n.highlightFormatting && (r.formatting = "link-string"); var o = h(r); return r.linkHref = !1, o } return t.match(P[e]), r.linkHref = !0, h(r) } } function y(e, t) { return e.match(/^([^\]\\]|\\.)*\]:/, !1) ? (t.f = x, e.next(), n.highlightFormatting && (t.formatting = "link"), t.linkText = !0, h(t)) : i(e, t, p) } function x(e, t) { if (e.match(/^\]:/, !0)) { t.f = t.inline = b, n.highlightFormatting && (t.formatting = "link"); var r = h(t); return t.linkText = !1, r } return e.match(/^([^\]\\]|\\.)+/, !0), S.linkText } function b(e, t) { return e.eatSpace() ? null : (e.match(/^[^\s]+/, !0), void 0 === e.peek() ? t.linkTitle = !0 : e.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, !0), t.f = t.inline = p, S.linkHref + " url") } var w = e.getMode(t, "text/html"), k = "null" == w.name; void 0 === n.highlightFormatting && (n.highlightFormatting = !1), void 0 === n.maxBlockquoteDepth && (n.maxBlockquoteDepth = 0), void 0 === n.underscoresBreakWords && (n.underscoresBreakWords = !0), void 0 === n.taskLists && (n.taskLists = !1), void 0 === n.strikethrough && (n.strikethrough = !1), void 0 === n.tokenTypeOverrides && (n.tokenTypeOverrides = {}); var S = { header: "header", code: "comment", quote: "quote", list1: "variable-2", list2: "variable-3", list3: "keyword", hr: "hr", image: "tag", formatting: "formatting", linkInline: "link", linkEmail: "link", linkText: "link", linkHref: "string", em: "em", strong: "strong", strikethrough: "strikethrough" }; for (var C in S) S.hasOwnProperty(C) && n.tokenTypeOverrides[C] && (S[C] = n.tokenTypeOverrides[C]); var L = /^([*\-_])(?:\s*\1){2,}\s*$/, T = /^[*\-+]\s+/, M = /^[0-9]+([.)])\s+/, N = /^\[(x| )\](?=\s)/, A = n.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/, E = /^ *(?:\={1,}|-{1,})\s*$/, O = /^[^#!\[\]*_\\<>` "'(~]+/, I = new RegExp("^(" + (n.fencedCodeBlocks === !0 ? "~~~+|```+" : n.fencedCodeBlocks) + ")[ \\t]*([\\w+#-]*)"), P = { ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/, "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\\]]|\\.)*\])*?(?=\])/ }, R = { startState: function () { return { f: s, prevLine: null, thisLine: null, block: s, htmlState: null, indentation: 0, inline: p, text: d, formatting: !1, linkText: !1, linkHref: !1, linkTitle: !1, code: 0, em: !1, strong: !1, header: 0, hr: !1, taskList: !1, list: !1, listStack: [], quote: 0, trailingSpace: 0, trailingSpaceNewLine: !1, strikethrough: !1, fencedChars: null } }, copyState: function (t) { return { f: t.f, prevLine: t.prevLine, thisLine: t.thisLine, block: t.block, htmlState: t.htmlState && e.copyState(w, t.htmlState), indentation: t.indentation, localMode: t.localMode, localState: t.localMode ? e.copyState(t.localMode, t.localState) : null, inline: t.inline, text: t.text, formatting: !1, linkTitle: t.linkTitle, code: t.code, em: t.em, strong: t.strong, strikethrough: t.strikethrough, header: t.header, hr: t.hr, taskList: t.taskList, list: t.list, listStack: t.listStack.slice(0), quote: t.quote, indentedCode: t.indentedCode, trailingSpace: t.trailingSpace, trailingSpaceNewLine: t.trailingSpaceNewLine, md_inside: t.md_inside, fencedChars: t.fencedChars } }, token: function (e, t) { if (t.formatting = !1, e != t.thisLine) { var n = t.header || t.hr; if (t.header = 0, t.hr = !1, e.match(/^\s*$/, !0) || n) { if (l(t), !n) return null; t.prevLine = null } t.prevLine = t.thisLine, t.thisLine = e, t.taskList = !1, t.trailingSpace = 0, t.trailingSpaceNewLine = !1, t.f = t.block; var r = e.match(/^\s*/, !0)[0].replace(/\t/g, "    ").length; if (t.indentationDiff = Math.min(r - t.indentation, 4), t.indentation = t.indentation + t.indentationDiff, r > 0) return null } return t.f(e, t) }, innerMode: function (e) { return e.block == c ? { state: e.htmlState, mode: w } : e.localState ? { state: e.localState, mode: e.localMode } : { state: e, mode: R } }, blankLine: l, getType: h, fold: "markdown" }; return R
                }, "xml"), e.defineMIME("text/x-markdown", "markdown")
            })
        }, { "../../lib/codemirror": 10, "../meta": 13, "../xml/xml": 14 }], 13: [function (t, n, r) { !function (i) { "object" == typeof r && "object" == typeof n ? i(t("../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../lib/codemirror"], i) : i(CodeMirror) }(function (e) { "use strict"; e.modeInfo = [{ name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"] }, { name: "PGP", mimes: ["application/pgp", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["pgp"] }, { name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"] }, { name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i }, { name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"] }, { name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h"] }, { name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"] }, { name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"] }, { name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp"] }, { name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"] }, { name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"] }, { name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"] }, { name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists.txt$/ }, { name: "CoffeeScript", mime: "text/x-coffeescript", mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"] }, { name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"] }, { name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"] }, { name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"] }, { name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"] }, { name: "CSS", mime: "text/css", mode: "css", ext: ["css"] }, { name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"] }, { name: "D", mime: "text/x-d", mode: "d", ext: ["d"] }, { name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"] }, { name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"] }, { name: "Django", mime: "text/x-django", mode: "django" }, { name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/ }, { name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"] }, { name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"] }, { name: "EBNF", mime: "text/x-ebnf", mode: "ebnf" }, { name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"] }, { name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"] }, { name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"] }, { name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"] }, { name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"] }, { name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"] }, { name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"] }, { name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"] }, { name: "FCL", mime: "text/x-fcl", mode: "fcl" }, { name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"] }, { name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90"] }, { name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"] }, { name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"] }, { name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"] }, { name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history).md$/i }, { name: "Go", mime: "text/x-go", mode: "go", ext: ["go"] }, { name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"] }, { name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"] }, { name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"] }, { name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"] }, { name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"] }, { name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"] }, { name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"] }, { name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm"], alias: ["xhtml"] }, { name: "HTTP", mime: "message/http", mode: "http" }, { name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"] }, { name: "Jade", mime: "text/x-jade", mode: "jade", ext: ["jade"] }, { name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"] }, { name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"] }, { name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"], mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"] }, { name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"] }, { name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"] }, { name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"] }, { name: "Jinja2", mime: "null", mode: "jinja2" }, { name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"] }, { name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"] }, { name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"] }, { name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"] }, { name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"] }, { name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"] }, { name: "mIRC", mime: "text/mirc", mode: "mirc" }, { name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql" }, { name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb"] }, { name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"] }, { name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"] }, { name: "MS SQL", mime: "text/x-mssql", mode: "sql" }, { name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"] }, { name: "MySQL", mime: "text/x-mysql", mode: "sql" }, { name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i }, { name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"] }, { name: "NTriples", mime: "text/n-triples", mode: "ntriples", ext: ["nt"] }, { name: "Objective C", mime: "text/x-objectivec", mode: "clike", ext: ["m", "mm"], alias: ["objective-c", "objc"] }, { name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"] }, { name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"] }, { name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"] }, { name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"] }, { name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"] }, { name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"] }, { name: "PHP", mime: "application/x-httpd-php", mode: "php", ext: ["php", "php3", "php4", "php5", "phtml"] }, { name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"] }, { name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"] }, { name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"] }, { name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"] }, { name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"] }, { name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"] }, { name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/ }, { name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"] }, { name: "Q", mime: "text/x-q", mode: "q", ext: ["q"] }, { name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r"], alias: ["rscript"] }, { name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"] }, { name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm" }, { name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"] }, { name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"] }, { name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"] }, { name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"] }, { name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"] }, { name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"] }, { name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"] }, { name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"] }, { name: "Shell", mime: "text/x-sh", mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/ }, { name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"] }, { name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"] }, { name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"] }, { name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"] }, { name: "Solr", mime: "text/x-solr", mode: "solr" }, { name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"] }, { name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"] }, { name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"] }, { name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"] }, { name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"] }, { name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"] }, { name: "sTeX", mime: "text/x-stex", mode: "stex" }, { name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx"], alias: ["tex"] }, { name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v"] }, { name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"] }, { name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"] }, { name: "TiddlyWiki ", mime: "text/x-tiddlywiki", mode: "tiddlywiki" }, { name: "Tiki wiki", mime: "text/tiki", mode: "tiki" }, { name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"] }, { name: "Tornado", mime: "text/x-tornado", mode: "tornado" }, { name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"] }, { name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"] }, { name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"] }, { name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"] }, { name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"] }, { name: "Twig", mime: "text/x-twig", mode: "twig" }, { name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"] }, { name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"] }, { name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"] }, { name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"] }, { name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"] }, { name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"] }, { name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd"], alias: ["rss", "wsdl", "xsd"] }, { name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"] }, { name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"] }, { name: "YAML", mime: "text/x-yaml", mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"] }, { name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"] }, { name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"] }, { name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"] }, { name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"] }]; for (var t = 0; t < e.modeInfo.length; t++) { var n = e.modeInfo[t]; n.mimes && (n.mime = n.mimes[0]) } e.findModeByMIME = function (t) { t = t.toLowerCase(); for (var n = 0; n < e.modeInfo.length; n++) { var r = e.modeInfo[n]; if (r.mime == t) return r; if (r.mimes) for (var i = 0; i < r.mimes.length; i++)if (r.mimes[i] == t) return r } }, e.findModeByExtension = function (t) { for (var n = 0; n < e.modeInfo.length; n++) { var r = e.modeInfo[n]; if (r.ext) for (var i = 0; i < r.ext.length; i++)if (r.ext[i] == t) return r } }, e.findModeByFileName = function (t) { for (var n = 0; n < e.modeInfo.length; n++) { var r = e.modeInfo[n]; if (r.file && r.file.test(t)) return r } var i = t.lastIndexOf("."), o = i > -1 && t.substring(i + 1, t.length); return o ? e.findModeByExtension(o) : void 0 }, e.findModeByName = function (t) { t = t.toLowerCase(); for (var n = 0; n < e.modeInfo.length; n++) { var r = e.modeInfo[n]; if (r.name.toLowerCase() == t) return r; if (r.alias) for (var i = 0; i < r.alias.length; i++)if (r.alias[i].toLowerCase() == t) return r } } }) }, { "../lib/codemirror": 10 }], 14: [function (t, n, r) { !function (i) { "object" == typeof r && "object" == typeof n ? i(t("../../lib/codemirror")) : "function" == typeof e && e.amd ? e(["../../lib/codemirror"], i) : i(CodeMirror) }(function (e) { "use strict"; var t = { autoSelfClosers: { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, frame: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0, menuitem: !0 }, implicitlyClosed: { dd: !0, li: !0, optgroup: !0, option: !0, p: !0, rp: !0, rt: !0, tbody: !0, td: !0, tfoot: !0, th: !0, tr: !0 }, contextGrabbers: { dd: { dd: !0, dt: !0 }, dt: { dd: !0, dt: !0 }, li: { li: !0 }, option: { option: !0, optgroup: !0 }, optgroup: { optgroup: !0 }, p: { address: !0, article: !0, aside: !0, blockquote: !0, dir: !0, div: !0, dl: !0, fieldset: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, menu: !0, nav: !0, ol: !0, p: !0, pre: !0, section: !0, table: !0, ul: !0 }, rp: { rp: !0, rt: !0 }, rt: { rp: !0, rt: !0 }, tbody: { tbody: !0, tfoot: !0 }, td: { td: !0, th: !0 }, tfoot: { tbody: !0 }, th: { td: !0, th: !0 }, thead: { tbody: !0, tfoot: !0 }, tr: { tr: !0 } }, doNotIndent: { pre: !0 }, allowUnquoted: !0, allowMissing: !0, caseFold: !0 }, n = { autoSelfClosers: {}, implicitlyClosed: {}, contextGrabbers: {}, doNotIndent: {}, allowUnquoted: !1, allowMissing: !1, caseFold: !1 }; e.defineMode("xml", function (r, i) { function o(e, t) { function n(n) { return t.tokenize = n, n(e, t) } var r = e.next(); if ("<" == r) return e.eat("!") ? e.eat("[") ? e.match("CDATA[") ? n(s("atom", "]]>")) : null : e.match("--") ? n(s("comment", "-->")) : e.match("DOCTYPE", !0, !0) ? (e.eatWhile(/[\w\._\-]/), n(c(1))) : null : e.eat("?") ? (e.eatWhile(/[\w\._\-]/), t.tokenize = s("meta", "?>"), "meta") : (T = e.eat("/") ? "closeTag" : "openTag", t.tokenize = a, "tag bracket"); if ("&" == r) { var i; return i = e.eat("#") ? e.eat("x") ? e.eatWhile(/[a-fA-F\d]/) && e.eat(";") : e.eatWhile(/[\d]/) && e.eat(";") : e.eatWhile(/[\w\.\-:]/) && e.eat(";"), i ? "atom" : "error" } return e.eatWhile(/[^&<]/), null } function a(e, t) { var n = e.next(); if (">" == n || "/" == n && e.eat(">")) return t.tokenize = o, T = ">" == n ? "endTag" : "selfcloseTag", "tag bracket"; if ("=" == n) return T = "equals", null; if ("<" == n) { t.tokenize = o, t.state = d, t.tagName = t.tagStart = null; var r = t.tokenize(e, t); return r ? r + " tag error" : "tag error" } return /[\'\"]/.test(n) ? (t.tokenize = l(n), t.stringStartCol = e.column(), t.tokenize(e, t)) : (e.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), "word") } function l(e) { var t = function (t, n) { for (; !t.eol();)if (t.next() == e) { n.tokenize = a; break } return "string" }; return t.isInAttribute = !0, t } function s(e, t) { return function (n, r) { for (; !n.eol();) { if (n.match(t)) { r.tokenize = o; break } n.next() } return e } } function c(e) { return function (t, n) { for (var r; null != (r = t.next());) { if ("<" == r) return n.tokenize = c(e + 1), n.tokenize(t, n); if (">" == r) { if (1 == e) { n.tokenize = o; break } return n.tokenize = c(e - 1), n.tokenize(t, n) } } return "meta" } } function u(e, t, n) { this.prev = e.context, this.tagName = t, this.indent = e.indented, this.startOfLine = n, (S.doNotIndent.hasOwnProperty(t) || e.context && e.context.noIndent) && (this.noIndent = !0) } function f(e) { e.context && (e.context = e.context.prev) } function h(e, t) { for (var n; ;) { if (!e.context) return; if (n = e.context.tagName, !S.contextGrabbers.hasOwnProperty(n) || !S.contextGrabbers[n].hasOwnProperty(t)) return; f(e) } } function d(e, t, n) { return "openTag" == e ? (n.tagStart = t.column(), p) : "closeTag" == e ? m : d } function p(e, t, n) { return "word" == e ? (n.tagName = t.current(), M = "tag", y) : (M = "error", p) } function m(e, t, n) { if ("word" == e) { var r = t.current(); return n.context && n.context.tagName != r && S.implicitlyClosed.hasOwnProperty(n.context.tagName) && f(n), n.context && n.context.tagName == r || S.matchClosing === !1 ? (M = "tag", g) : (M = "tag error", v) } return M = "error", v } function g(e, t, n) { return "endTag" != e ? (M = "error", g) : (f(n), d) } function v(e, t, n) { return M = "error", g(e, t, n) } function y(e, t, n) { if ("word" == e) return M = "attribute", x; if ("endTag" == e || "selfcloseTag" == e) { var r = n.tagName, i = n.tagStart; return n.tagName = n.tagStart = null, "selfcloseTag" == e || S.autoSelfClosers.hasOwnProperty(r) ? h(n, r) : (h(n, r), n.context = new u(n, r, i == n.indented)), d } return M = "error", y } function x(e, t, n) { return "equals" == e ? b : (S.allowMissing || (M = "error"), y(e, t, n)) } function b(e, t, n) { return "string" == e ? w : "word" == e && S.allowUnquoted ? (M = "string", y) : (M = "error", y(e, t, n)) } function w(e, t, n) { return "string" == e ? w : y(e, t, n) } var k = r.indentUnit, S = {}, C = i.htmlMode ? t : n; for (var L in C) S[L] = C[L]; for (var L in i) S[L] = i[L]; var T, M; return o.isInText = !0, { startState: function (e) { var t = { tokenize: o, state: d, indented: e || 0, tagName: null, tagStart: null, context: null }; return null != e && (t.baseIndent = e), t }, token: function (e, t) { if (!t.tagName && e.sol() && (t.indented = e.indentation()), e.eatSpace()) return null; T = null; var n = t.tokenize(e, t); return (n || T) && "comment" != n && (M = null, t.state = t.state(T || n, e, t), M && (n = "error" == M ? n + " error" : M)), n }, indent: function (t, n, r) { var i = t.context; if (t.tokenize.isInAttribute) return t.tagStart == t.indented ? t.stringStartCol + 1 : t.indented + k; if (i && i.noIndent) return e.Pass; if (t.tokenize != a && t.tokenize != o) return r ? r.match(/^(\s*)/)[0].length : 0; if (t.tagName) return S.multilineTagIndentPastTag !== !1 ? t.tagStart + t.tagName.length + 2 : t.tagStart + k * (S.multilineTagIndentFactor || 1); if (S.alignCDATA && /<!\[CDATA\[/.test(n)) return 0; var l = n && /^<(\/)?([\w_:\.-]*)/.exec(n); if (l && l[1]) for (; i;) { if (i.tagName == l[2]) { i = i.prev; break } if (!S.implicitlyClosed.hasOwnProperty(i.tagName)) break; i = i.prev } else if (l) for (; i;) { var s = S.contextGrabbers[i.tagName]; if (!s || !s.hasOwnProperty(l[2])) break; i = i.prev } for (; i && i.prev && !i.startOfLine;)i = i.prev; return i ? i.indent + k : t.baseIndent || 0 }, electricInput: /<\/[\s\w:]+>$/, blockCommentStart: "<!--", blockCommentEnd: "-->", configuration: S.htmlMode ? "html" : "xml", helperType: S.htmlMode ? "html" : "xml", skipAttribute: function (e) { e.state == b && (e.state = y) } } }), e.defineMIME("text/xml", "xml"), e.defineMIME("application/xml", "xml"), e.mimeModes.hasOwnProperty("text/html") || e.defineMIME("text/html", { name: "xml", htmlMode: !0 }) }) }, { "../../lib/codemirror": 10 }], 15: [function (e, t, n) { n.read = function (e, t, n, r, i) { var o, a, l = 8 * i - r - 1, s = (1 << l) - 1, c = s >> 1, u = -7, f = n ? i - 1 : 0, h = n ? -1 : 1, d = e[t + f]; for (f += h, o = d & (1 << -u) - 1, d >>= -u, u += l; u > 0; o = 256 * o + e[t + f], f += h, u -= 8); for (a = o & (1 << -u) - 1, o >>= -u, u += r; u > 0; a = 256 * a + e[t + f], f += h, u -= 8); if (0 === o) o = 1 - c; else { if (o === s) return a ? NaN : (d ? -1 : 1) * (1 / 0); a += Math.pow(2, r), o -= c } return (d ? -1 : 1) * a * Math.pow(2, o - r) }, n.write = function (e, t, n, r, i, o) { var a, l, s, c = 8 * o - i - 1, u = (1 << c) - 1, f = u >> 1, h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : o - 1, p = r ? 1 : -1, m = 0 > t || 0 === t && 0 > 1 / t ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (l = isNaN(t) ? 1 : 0, a = u) : (a = Math.floor(Math.log(t) / Math.LN2), t * (s = Math.pow(2, -a)) < 1 && (a-- , s *= 2), t += a + f >= 1 ? h / s : h * Math.pow(2, 1 - f), t * s >= 2 && (a++ , s /= 2), a + f >= u ? (l = 0, a = u) : a + f >= 1 ? (l = (t * s - 1) * Math.pow(2, i), a += f) : (l = t * Math.pow(2, f - 1) * Math.pow(2, i), a = 0)); i >= 8; e[n + d] = 255 & l, d += p, l /= 256, i -= 8); for (a = a << i | l, c += i; c > 0; e[n + d] = 255 & a, d += p, a /= 256, c -= 8); e[n + d - p] |= 128 * m } }, {}], 16: [function (e, t, n) { var r = {}.toString; t.exports = Array.isArray || function (e) { return "[object Array]" == r.call(e) } }, {}], 17: [function (t, n, r) {
            (function (t) {
                (function () {
                    function t(e) { this.tokens = [], this.tokens.links = {}, this.options = e || h.defaults, this.rules = d.normal, this.options.gfm && (this.options.tables ? this.rules = d.tables : this.rules = d.gfm) } function i(e, t) { if (this.options = t || h.defaults, this.links = e, this.rules = p.normal, this.renderer = this.options.renderer || new o, this.renderer.options = this.options, !this.links) throw new Error("Tokens array requires a `links` property."); this.options.gfm ? this.options.breaks ? this.rules = p.breaks : this.rules = p.gfm : this.options.pedantic && (this.rules = p.pedantic) } function o(e) { this.options = e || {} } function a(e) { this.tokens = [], this.token = null, this.options = e || h.defaults, this.options.renderer = this.options.renderer || new o, this.renderer = this.options.renderer, this.renderer.options = this.options } function l(e, t) { return e.replace(t ? /&/g : /&(?!#?\w+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;") } function s(e) { return e.replace(/&([#\w]+);/g, function (e, t) { return t = t.toLowerCase(), "colon" === t ? ":" : "#" === t.charAt(0) ? "x" === t.charAt(1) ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : "" }) } function c(e, t) { return e = e.source, t = t || "", function n(r, i) { return r ? (i = i.source || i, i = i.replace(/(^|[^\[])\^/g, "$1"), e = e.replace(r, i), n) : new RegExp(e, t) } } function u() { } function f(e) { for (var t, n, r = 1; r < arguments.length; r++) { t = arguments[r]; for (n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]) } return e } function h(e, n, r) { if (r || "function" == typeof n) { r || (r = n, n = null), n = f({}, h.defaults, n || {}); var i, o, s = n.highlight, c = 0; try { i = t.lex(e, n) } catch (u) { return r(u) } o = i.length; var d = function (e) { if (e) return n.highlight = s, r(e); var t; try { t = a.parse(i, n) } catch (o) { e = o } return n.highlight = s, e ? r(e) : r(null, t) }; if (!s || s.length < 3) return d(); if (delete n.highlight, !o) return d(); for (; c < i.length; c++)!function (e) { return "code" !== e.type ? --o || d() : s(e.text, e.lang, function (t, n) { return t ? d(t) : null == n || n === e.text ? --o || d() : (e.text = n, e.escaped = !0, void (--o || d())) }) }(i[c]) } else try { return n && (n = f({}, h.defaults, n)), a.parse(t.lex(e, n), n) } catch (u) { if (u.message += "\nPlease report this to https://github.com/chjj/marked.", (n || h.defaults).silent) return "<p>An error occured:</p><pre>" + l(u.message + "", !0) + "</pre>"; throw u } } var d = { newline: /^\n+/, code: /^( {4}[^\n]+\n*)+/, fences: u, hr: /^( *[-*_]){3,} *(?:\n+|$)/, heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/, nptable: u, lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/, blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/, list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/, html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/, def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/, table: u, paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/, text: /^[^\n]+/ }; d.bullet = /(?:[*+-]|\d+\.)/, d.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/, d.item = c(d.item, "gm")(/bull/g, d.bullet)(), d.list = c(d.list)(/bull/g, d.bullet)("hr", "\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))")("def", "\\n+(?=" + d.def.source + ")")(), d.blockquote = c(d.blockquote)("def", d.def)(), d._tag = "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b", d.html = c(d.html)("comment", /<!--[\s\S]*?-->/)("closed", /<(tag)[\s\S]+?<\/\1>/)("closing", /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g, d._tag)(), d.paragraph = c(d.paragraph)("hr", d.hr)("heading", d.heading)("lheading", d.lheading)("blockquote", d.blockquote)("tag", "<" + d._tag)("def", d.def)(), d.normal = f({}, d), d.gfm = f({}, d.normal, { fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/, paragraph: /^/, heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/ }), d.gfm.paragraph = c(d.paragraph)("(?!", "(?!" + d.gfm.fences.source.replace("\\1", "\\2") + "|" + d.list.source.replace("\\1", "\\3") + "|")(), d.tables = f({}, d.gfm, { nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/, table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/ }), t.rules = d, t.lex = function (e, n) { var r = new t(n); return r.lex(e) }, t.prototype.lex = function (e) { return e = e.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ").replace(/\u00a0/g, " ").replace(/\u2424/g, "\n"), this.token(e, !0) }, t.prototype.token = function (e, t, n) {
                        for (var r, i, o, a, l, s, c, u, f, e = e.replace(/^ +$/gm, ""); e;)if ((o = this.rules.newline.exec(e)) && (e = e.substring(o[0].length), o[0].length > 1 && this.tokens.push({ type: "space" })), o = this.rules.code.exec(e)) e = e.substring(o[0].length), o = o[0].replace(/^ {4}/gm, ""), this.tokens.push({ type: "code", text: this.options.pedantic ? o : o.replace(/\n+$/, "") }); else if (o = this.rules.fences.exec(e)) e = e.substring(o[0].length), this.tokens.push({ type: "code", lang: o[2], text: o[3] || "" }); else if (o = this.rules.heading.exec(e)) e = e.substring(o[0].length), this.tokens.push({ type: "heading", depth: o[1].length, text: o[2] }); else if (t && (o = this.rules.nptable.exec(e))) { for (e = e.substring(o[0].length), s = { type: "table", header: o[1].replace(/^ *| *\| *$/g, "").split(/ *\| */), align: o[2].replace(/^ *|\| *$/g, "").split(/ *\| */), cells: o[3].replace(/\n$/, "").split("\n") }, u = 0; u < s.align.length; u++)/^ *-+: *$/.test(s.align[u]) ? s.align[u] = "right" : /^ *:-+: *$/.test(s.align[u]) ? s.align[u] = "center" : /^ *:-+ *$/.test(s.align[u]) ? s.align[u] = "left" : s.align[u] = null; for (u = 0; u < s.cells.length; u++)s.cells[u] = s.cells[u].split(/ *\| */); this.tokens.push(s) } else if (o = this.rules.lheading.exec(e)) e = e.substring(o[0].length), this.tokens.push({ type: "heading", depth: "=" === o[2] ? 1 : 2, text: o[1] }); else if (o = this.rules.hr.exec(e)) e = e.substring(o[0].length), this.tokens.push({ type: "hr" }); else if (o = this.rules.blockquote.exec(e)) e = e.substring(o[0].length), this.tokens.push({ type: "blockquote_start" }), o = o[0].replace(/^ *> ?/gm, ""), this.token(o, t, !0), this.tokens.push({ type: "blockquote_end" }); else if (o = this.rules.list.exec(e)) { for (e = e.substring(o[0].length), a = o[2], this.tokens.push({ type: "list_start", ordered: a.length > 1 }), o = o[0].match(this.rules.item), r = !1, f = o.length, u = 0; f > u; u++)s = o[u], c = s.length, s = s.replace(/^ *([*+-]|\d+\.) +/, ""), ~s.indexOf("\n ") && (c -= s.length, s = this.options.pedantic ? s.replace(/^ {1,4}/gm, "") : s.replace(new RegExp("^ {1," + c + "}", "gm"), "")), this.options.smartLists && u !== f - 1 && (l = d.bullet.exec(o[u + 1])[0], a === l || a.length > 1 && l.length > 1 || (e = o.slice(u + 1).join("\n") + e, u = f - 1)), i = r || /\n\n(?!\s*$)/.test(s), u !== f - 1 && (r = "\n" === s.charAt(s.length - 1), i || (i = r)), this.tokens.push({ type: i ? "loose_item_start" : "list_item_start" }), this.token(s, !1, n), this.tokens.push({ type: "list_item_end" }); this.tokens.push({ type: "list_end" }) } else if (o = this.rules.html.exec(e)) e = e.substring(o[0].length), this.tokens.push({ type: this.options.sanitize ? "paragraph" : "html", pre: !this.options.sanitizer && ("pre" === o[1] || "script" === o[1] || "style" === o[1]), text: o[0] }); else if (!n && t && (o = this.rules.def.exec(e))) e = e.substring(o[0].length), this.tokens.links[o[1].toLowerCase()] = { href: o[2], title: o[3] }; else if (t && (o = this.rules.table.exec(e))) {
                            for (e = e.substring(o[0].length), s = {
                                type: "table",
                                header: o[1].replace(/^ *| *\| *$/g, "").split(/ *\| */), align: o[2].replace(/^ *|\| *$/g, "").split(/ *\| */), cells: o[3].replace(/(?: *\| *)?\n$/, "").split("\n")
                            }, u = 0; u < s.align.length; u++)/^ *-+: *$/.test(s.align[u]) ? s.align[u] = "right" : /^ *:-+: *$/.test(s.align[u]) ? s.align[u] = "center" : /^ *:-+ *$/.test(s.align[u]) ? s.align[u] = "left" : s.align[u] = null; for (u = 0; u < s.cells.length; u++)s.cells[u] = s.cells[u].replace(/^ *\| *| *\| *$/g, "").split(/ *\| */); this.tokens.push(s)
                        } else if (t && (o = this.rules.paragraph.exec(e))) e = e.substring(o[0].length), this.tokens.push({ type: "paragraph", text: "\n" === o[1].charAt(o[1].length - 1) ? o[1].slice(0, -1) : o[1] }); else if (o = this.rules.text.exec(e)) e = e.substring(o[0].length), this.tokens.push({ type: "text", text: o[0] }); else if (e) throw new Error("Infinite loop on byte: " + e.charCodeAt(0)); return this.tokens
                    }; var p = { escape: /^\\([\\`*{}\[\]()#+\-.!_>])/, autolink: /^<([^ >]+(@|:\/)[^ >]+)>/, url: u, tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/, link: /^!?\[(inside)\]\(href\)/, reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/, nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/, strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/, em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/, br: /^ {2,}\n(?!\s*$)/, del: u, text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/ }; p._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/, p._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/, p.link = c(p.link)("inside", p._inside)("href", p._href)(), p.reflink = c(p.reflink)("inside", p._inside)(), p.normal = f({}, p), p.pedantic = f({}, p.normal, { strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/ }), p.gfm = f({}, p.normal, { escape: c(p.escape)("])", "~|])")(), url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, del: /^~~(?=\S)([\s\S]*?\S)~~/, text: c(p.text)("]|", "~]|")("|", "|https?://|")() }), p.breaks = f({}, p.gfm, { br: c(p.br)("{2,}", "*")(), text: c(p.gfm.text)("{2,}", "*")() }), i.rules = p, i.output = function (e, t, n) { var r = new i(t, n); return r.output(e) }, i.prototype.output = function (e) { for (var t, n, r, i, o = ""; e;)if (i = this.rules.escape.exec(e)) e = e.substring(i[0].length), o += i[1]; else if (i = this.rules.autolink.exec(e)) e = e.substring(i[0].length), "@" === i[2] ? (n = ":" === i[1].charAt(6) ? this.mangle(i[1].substring(7)) : this.mangle(i[1]), r = this.mangle("mailto:") + n) : (n = l(i[1]), r = n), o += this.renderer.link(r, null, n); else if (this.inLink || !(i = this.rules.url.exec(e))) { if (i = this.rules.tag.exec(e)) !this.inLink && /^<a /i.test(i[0]) ? this.inLink = !0 : this.inLink && /^<\/a>/i.test(i[0]) && (this.inLink = !1), e = e.substring(i[0].length), o += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(i[0]) : l(i[0]) : i[0]; else if (i = this.rules.link.exec(e)) e = e.substring(i[0].length), this.inLink = !0, o += this.outputLink(i, { href: i[2], title: i[3] }), this.inLink = !1; else if ((i = this.rules.reflink.exec(e)) || (i = this.rules.nolink.exec(e))) { if (e = e.substring(i[0].length), t = (i[2] || i[1]).replace(/\s+/g, " "), t = this.links[t.toLowerCase()], !t || !t.href) { o += i[0].charAt(0), e = i[0].substring(1) + e; continue } this.inLink = !0, o += this.outputLink(i, t), this.inLink = !1 } else if (i = this.rules.strong.exec(e)) e = e.substring(i[0].length), o += this.renderer.strong(this.output(i[2] || i[1])); else if (i = this.rules.em.exec(e)) e = e.substring(i[0].length), o += this.renderer.em(this.output(i[2] || i[1])); else if (i = this.rules.code.exec(e)) e = e.substring(i[0].length), o += this.renderer.codespan(l(i[2], !0)); else if (i = this.rules.br.exec(e)) e = e.substring(i[0].length), o += this.renderer.br(); else if (i = this.rules.del.exec(e)) e = e.substring(i[0].length), o += this.renderer.del(this.output(i[1])); else if (i = this.rules.text.exec(e)) e = e.substring(i[0].length), o += this.renderer.text(l(this.smartypants(i[0]))); else if (e) throw new Error("Infinite loop on byte: " + e.charCodeAt(0)) } else e = e.substring(i[0].length), n = l(i[1]), r = n, o += this.renderer.link(r, null, n); return o }, i.prototype.outputLink = function (e, t) { var n = l(t.href), r = t.title ? l(t.title) : null; return "!" !== e[0].charAt(0) ? this.renderer.link(n, r, this.output(e[1])) : this.renderer.image(n, r, l(e[1])) }, i.prototype.smartypants = function (e) { return this.options.smartypants ? e.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014\/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014\/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…") : e }, i.prototype.mangle = function (e) { if (!this.options.mangle) return e; for (var t, n = "", r = e.length, i = 0; r > i; i++)t = e.charCodeAt(i), Math.random() > .5 && (t = "x" + t.toString(16)), n += "&#" + t + ";"; return n }, o.prototype.code = function (e, t, n) { if (this.options.highlight) { var r = this.options.highlight(e, t); null != r && r !== e && (n = !0, e = r) } return t ? '<pre><code class="' + this.options.langPrefix + l(t, !0) + '">' + (n ? e : l(e, !0)) + "\n</code></pre>\n" : "<pre><code>" + (n ? e : l(e, !0)) + "\n</code></pre>" }, o.prototype.blockquote = function (e) { return "<blockquote>\n" + e + "</blockquote>\n" }, o.prototype.html = function (e) { return e }, o.prototype.heading = function (e, t, n) { return "<h" + t + ' id="' + this.options.headerPrefix + n.toLowerCase().replace(/[^\w]+/g, "-") + '">' + e + "</h" + t + ">\n" }, o.prototype.hr = function () { return this.options.xhtml ? "<hr/>\n" : "<hr>\n" }, o.prototype.list = function (e, t) { var n = t ? "ol" : "ul"; return "<" + n + ">\n" + e + "</" + n + ">\n" }, o.prototype.listitem = function (e) { return "<li>" + e + "</li>\n" }, o.prototype.paragraph = function (e) { return "<p>" + e + "</p>\n" }, o.prototype.table = function (e, t) { return "<table>\n<thead>\n" + e + "</thead>\n<tbody>\n" + t + "</tbody>\n</table>\n" }, o.prototype.tablerow = function (e) { return "<tr>\n" + e + "</tr>\n" }, o.prototype.tablecell = function (e, t) { var n = t.header ? "th" : "td", r = t.align ? "<" + n + ' style="text-align:' + t.align + '">' : "<" + n + ">"; return r + e + "</" + n + ">\n" }, o.prototype.strong = function (e) { return "<strong>" + e + "</strong>" }, o.prototype.em = function (e) { return "<em>" + e + "</em>" }, o.prototype.codespan = function (e) { return "<code>" + e + "</code>" }, o.prototype.br = function () { return this.options.xhtml ? "<br/>" : "<br>" }, o.prototype.del = function (e) { return "<del>" + e + "</del>" }, o.prototype.link = function (e, t, n) { if (this.options.sanitize) { try { var r = decodeURIComponent(s(e)).replace(/[^\w:]/g, "").toLowerCase() } catch (i) { return "" } if (0 === r.indexOf("javascript:") || 0 === r.indexOf("vbscript:")) return "" } var o = '<a href="' + e + '"'; return t && (o += ' title="' + t + '"'), o += ">" + n + "</a>" }, o.prototype.image = function (e, t, n) { var r = '<img src="' + e + '" alt="' + n + '"'; return t && (r += ' title="' + t + '"'), r += this.options.xhtml ? "/>" : ">" }, o.prototype.text = function (e) { return e }, a.parse = function (e, t, n) { var r = new a(t, n); return r.parse(e) }, a.prototype.parse = function (e) { this.inline = new i(e.links, this.options, this.renderer), this.tokens = e.reverse(); for (var t = ""; this.next();)t += this.tok(); return t }, a.prototype.next = function () { return this.token = this.tokens.pop() }, a.prototype.peek = function () { return this.tokens[this.tokens.length - 1] || 0 }, a.prototype.parseText = function () { for (var e = this.token.text; "text" === this.peek().type;)e += "\n" + this.next().text; return this.inline.output(e) }, a.prototype.tok = function () { switch (this.token.type) { case "space": return ""; case "hr": return this.renderer.hr(); case "heading": return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, this.token.text); case "code": return this.renderer.code(this.token.text, this.token.lang, this.token.escaped); case "table": var e, t, n, r, i, o = "", a = ""; for (n = "", e = 0; e < this.token.header.length; e++)r = { header: !0, align: this.token.align[e] }, n += this.renderer.tablecell(this.inline.output(this.token.header[e]), { header: !0, align: this.token.align[e] }); for (o += this.renderer.tablerow(n), e = 0; e < this.token.cells.length; e++) { for (t = this.token.cells[e], n = "", i = 0; i < t.length; i++)n += this.renderer.tablecell(this.inline.output(t[i]), { header: !1, align: this.token.align[i] }); a += this.renderer.tablerow(n) } return this.renderer.table(o, a); case "blockquote_start": for (var a = ""; "blockquote_end" !== this.next().type;)a += this.tok(); return this.renderer.blockquote(a); case "list_start": for (var a = "", l = this.token.ordered; "list_end" !== this.next().type;)a += this.tok(); return this.renderer.list(a, l); case "list_item_start": for (var a = ""; "list_item_end" !== this.next().type;)a += "text" === this.token.type ? this.parseText() : this.tok(); return this.renderer.listitem(a); case "loose_item_start": for (var a = ""; "list_item_end" !== this.next().type;)a += this.tok(); return this.renderer.listitem(a); case "html": var s = this.token.pre || this.options.pedantic ? this.token.text : this.inline.output(this.token.text); return this.renderer.html(s); case "paragraph": return this.renderer.paragraph(this.inline.output(this.token.text)); case "text": return this.renderer.paragraph(this.parseText()) } }, u.exec = u, h.options = h.setOptions = function (e) { return f(h.defaults, e), h }, h.defaults = { gfm: !0, tables: !0, breaks: !1, pedantic: !1, sanitize: !1, sanitizer: null, mangle: !0, smartLists: !1, silent: !1, highlight: null, langPrefix: "lang-", smartypants: !1, headerPrefix: "", renderer: new o, xhtml: !1 }, h.Parser = a, h.parser = a.parse, h.Renderer = o, h.Lexer = t, h.lexer = t.lex, h.InlineLexer = i, h.inlineLexer = i.output, h.parse = h, "undefined" != typeof n && "object" == typeof r ? n.exports = h : "function" == typeof e && e.amd ? e(function () { return h }) : this.marked = h
                }).call(function () { return this || ("undefined" != typeof window ? window : t) }())
            }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }, {}], 18: [function (e, t, n) { (function (n, r) { "use strict"; var i = function (e, t, n, i) { if (i = i || {}, this.dictionary = null, this.rules = {}, this.dictionaryTable = {}, this.compoundRules = [], this.compoundRuleCodes = {}, this.replacementTable = [], this.flags = i.flags || {}, e) { if (this.dictionary = e, "undefined" != typeof window && "chrome" in window && "extension" in window.chrome && "getURL" in window.chrome.extension) t || (t = this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + e + "/" + e + ".aff"))), n || (n = this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + e + "/" + e + ".dic"))); else { if (i.dictionaryPath) var o = i.dictionaryPath; else if ("undefined" != typeof r) var o = r + "/dictionaries"; else var o = "./dictionaries"; t || (t = this._readFile(o + "/" + e + "/" + e + ".aff")), n || (n = this._readFile(o + "/" + e + "/" + e + ".dic")) } this.rules = this._parseAFF(t), this.compoundRuleCodes = {}; for (var a = 0, l = this.compoundRules.length; l > a; a++)for (var s = this.compoundRules[a], c = 0, u = s.length; u > c; c++)this.compoundRuleCodes[s[c]] = []; "ONLYINCOMPOUND" in this.flags && (this.compoundRuleCodes[this.flags.ONLYINCOMPOUND] = []), this.dictionaryTable = this._parseDIC(n); for (var a in this.compoundRuleCodes) 0 == this.compoundRuleCodes[a].length && delete this.compoundRuleCodes[a]; for (var a = 0, l = this.compoundRules.length; l > a; a++) { for (var f = this.compoundRules[a], h = "", c = 0, u = f.length; u > c; c++) { var d = f[c]; h += d in this.compoundRuleCodes ? "(" + this.compoundRuleCodes[d].join("|") + ")" : d } this.compoundRules[a] = new RegExp(h, "i") } } return this }; i.prototype = { load: function (e) { for (var t in e) this[t] = e[t]; return this }, _readFile: function (t, r) { if (r || (r = "utf8"), "undefined" != typeof XMLHttpRequest) { var i = new XMLHttpRequest; return i.open("GET", t, !1), i.overrideMimeType && i.overrideMimeType("text/plain; charset=" + r), i.send(null), i.responseText } if ("undefined" != typeof e) { var o = e("fs"); try { if (o.existsSync(t)) { var a = o.statSync(t), l = o.openSync(t, "r"), s = new n(a.size); return o.readSync(l, s, 0, s.length, null), s.toString(r, 0, s.length) } console.log("Path " + t + " does not exist.") } catch (c) { return console.log(c), "" } } }, _parseAFF: function (e) { var t = {}; e = this._removeAffixComments(e); for (var n = e.split("\n"), r = 0, i = n.length; i > r; r++) { var o = n[r], a = o.split(/\s+/), l = a[0]; if ("PFX" == l || "SFX" == l) { for (var s = a[1], c = a[2], u = parseInt(a[3], 10), f = [], h = r + 1, d = r + 1 + u; d > h; h++) { var o = n[h], p = o.split(/\s+/), m = p[2], g = p[3].split("/"), v = g[0]; "0" === v && (v = ""); var y = this.parseRuleCodes(g[1]), x = p[4], b = {}; b.add = v, y.length > 0 && (b.continuationClasses = y), "." !== x && ("SFX" === l ? b.match = new RegExp(x + "$") : b.match = new RegExp("^" + x)), "0" != m && ("SFX" === l ? b.remove = new RegExp(m + "$") : b.remove = m), f.push(b) } t[s] = { type: l, combineable: "Y" == c, entries: f }, r += u } else if ("COMPOUNDRULE" === l) { for (var u = parseInt(a[1], 10), h = r + 1, d = r + 1 + u; d > h; h++) { var o = n[h], p = o.split(/\s+/); this.compoundRules.push(p[1]) } r += u } else if ("REP" === l) { var p = o.split(/\s+/); 3 === p.length && this.replacementTable.push([p[1], p[2]]) } else this.flags[l] = a[1] } return t }, _removeAffixComments: function (e) { return e = e.replace(/#.*$/gm, ""), e = e.replace(/^\s\s*/m, "").replace(/\s\s*$/m, ""), e = e.replace(/\n{2,}/g, "\n"), e = e.replace(/^\s\s*/, "").replace(/\s\s*$/, "") }, _parseDIC: function (e) { function t(e, t) { e in r && "object" == typeof r[e] || (r[e] = []), r[e].push(t) } e = this._removeDicComments(e); for (var n = e.split("\n"), r = {}, i = 1, o = n.length; o > i; i++) { var a = n[i], l = a.split("/", 2), s = l[0]; if (l.length > 1) { var c = this.parseRuleCodes(l[1]); "NEEDAFFIX" in this.flags && -1 != c.indexOf(this.flags.NEEDAFFIX) || t(s, c); for (var u = 0, f = c.length; f > u; u++) { var h = c[u], d = this.rules[h]; if (d) for (var p = this._applyRule(s, d), m = 0, g = p.length; g > m; m++) { var v = p[m]; if (t(v, []), d.combineable) for (var y = u + 1; f > y; y++) { var x = c[y], b = this.rules[x]; if (b && b.combineable && d.type != b.type) for (var w = this._applyRule(v, b), k = 0, S = w.length; S > k; k++) { var C = w[k]; t(C, []) } } } h in this.compoundRuleCodes && this.compoundRuleCodes[h].push(s) } } else t(s.trim(), []) } return r }, _removeDicComments: function (e) { return e = e.replace(/^\t.*$/gm, "") }, parseRuleCodes: function (e) { if (!e) return []; if (!("FLAG" in this.flags)) return e.split(""); if ("long" === this.flags.FLAG) { for (var t = [], n = 0, r = e.length; r > n; n += 2)t.push(e.substr(n, 2)); return t } return "num" === this.flags.FLAG ? textCode.split(",") : void 0 }, _applyRule: function (e, t) { for (var n = t.entries, r = [], i = 0, o = n.length; o > i; i++) { var a = n[i]; if (!a.match || e.match(a.match)) { var l = e; if (a.remove && (l = l.replace(a.remove, "")), "SFX" === t.type ? l += a.add : l = a.add + l, r.push(l), "continuationClasses" in a) for (var s = 0, c = a.continuationClasses.length; c > s; s++) { var u = this.rules[a.continuationClasses[s]]; u && (r = r.concat(this._applyRule(l, u))) } } } return r }, check: function (e) { var t = e.replace(/^\s\s*/, "").replace(/\s\s*$/, ""); if (this.checkExact(t)) return !0; if (t.toUpperCase() === t) { var n = t[0] + t.substring(1).toLowerCase(); if (this.hasFlag(n, "KEEPCASE")) return !1; if (this.checkExact(n)) return !0 } var r = t.toLowerCase(); if (r !== t) { if (this.hasFlag(r, "KEEPCASE")) return !1; if (this.checkExact(r)) return !0 } return !1 }, checkExact: function (e) { var t = this.dictionaryTable[e]; if ("undefined" == typeof t) { if ("COMPOUNDMIN" in this.flags && e.length >= this.flags.COMPOUNDMIN) for (var n = 0, r = this.compoundRules.length; r > n; n++)if (e.match(this.compoundRules[n])) return !0; return !1 } if ("object" == typeof t) { for (var n = 0, r = t.length; r > n; n++)if (!this.hasFlag(e, "ONLYINCOMPOUND", t[n])) return !0; return !1 } }, hasFlag: function (e, t, n) { if (t in this.flags) { if ("undefined" == typeof n) var n = Array.prototype.concat.apply([], this.dictionaryTable[e]); if (n && -1 !== n.indexOf(this.flags[t])) return !0 } return !1 }, alphabet: "", suggest: function (e, t) { function n(e) { for (var t = [], n = 0, r = e.length; r > n; n++) { for (var i = e[n], o = [], a = 0, l = i.length + 1; l > a; a++)o.push([i.substring(0, a), i.substring(a, i.length)]); for (var s = [], a = 0, l = o.length; l > a; a++) { var u = o[a]; u[1] && s.push(u[0] + u[1].substring(1)) } for (var f = [], a = 0, l = o.length; l > a; a++) { var u = o[a]; u[1].length > 1 && f.push(u[0] + u[1][1] + u[1][0] + u[1].substring(2)) } for (var h = [], a = 0, l = o.length; l > a; a++) { var u = o[a]; if (u[1]) for (var d = 0, p = c.alphabet.length; p > d; d++)h.push(u[0] + c.alphabet[d] + u[1].substring(1)) } for (var m = [], a = 0, l = o.length; l > a; a++) { var u = o[a]; if (u[1]) for (var d = 0, p = c.alphabet.length; p > d; d++)h.push(u[0] + c.alphabet[d] + u[1]) } t = t.concat(s), t = t.concat(f), t = t.concat(h), t = t.concat(m) } return t } function r(e) { for (var t = [], n = 0; n < e.length; n++)c.check(e[n]) && t.push(e[n]); return t } function i(e) { function i(e, t) { return e[1] < t[1] ? -1 : 1 } for (var o = n([e]), a = n(o), l = r(o).concat(r(a)), s = {}, u = 0, f = l.length; f > u; u++)l[u] in s ? s[l[u]] += 1 : s[l[u]] = 1; var h = []; for (var u in s) h.push([u, s[u]]); h.sort(i).reverse(); for (var d = [], u = 0, f = Math.min(t, h.length); f > u; u++)c.hasFlag(h[u][0], "NOSUGGEST") || d.push(h[u][0]); return d } if (t || (t = 5), this.check(e)) return []; for (var o = 0, a = this.replacementTable.length; a > o; o++) { var l = this.replacementTable[o]; if (-1 !== e.indexOf(l[0])) { var s = e.replace(l[0], l[1]); if (this.check(s)) return [s] } } var c = this; return c.alphabet = "abcdefghijklmnopqrstuvwxyz", i(e) } }, "undefined" != typeof t && (t.exports = i) }).call(this, e("buffer").Buffer, "/node_modules/typo-js") }, { buffer: 3, fs: 2 }], 19: [function (e, t, n) { var r = e("codemirror"); r.commands.tabAndIndentMarkdownList = function (e) { var t = e.listSelections(), n = t[0].head, r = e.getStateAfter(n.line), i = r.list !== !1; if (i) return void e.execCommand("indentMore"); if (e.options.indentWithTabs) e.execCommand("insertTab"); else { var o = Array(e.options.tabSize + 1).join(" "); e.replaceSelection(o) } }, r.commands.shiftTabAndUnindentMarkdownList = function (e) { var t = e.listSelections(), n = t[0].head, r = e.getStateAfter(n.line), i = r.list !== !1; if (i) return void e.execCommand("indentLess"); if (e.options.indentWithTabs) e.execCommand("insertTab"); else { var o = Array(e.options.tabSize + 1).join(" "); e.replaceSelection(o) } } }, { codemirror: 10 }], 20: [function (e, t, n) {
            "use strict"; function r(e) { return e = U ? e.replace("Ctrl", "Cmd") : e.replace("Cmd", "Ctrl") } function i(e, t, n) { e = e || {}; var r = document.createElement("a"); return t = void 0 == t ? !0 : t, e.title && t && (r.title = a(e.title, e.action, n), U && (r.title = r.title.replace("Ctrl", "⌘"), r.title = r.title.replace("Alt", "⌥"))), r.tabIndex = -1, r.className = e.className, r } function o() { var e = document.createElement("i"); return e.className = "separator", e.innerHTML = "|", e } function a(e, t, n) { var i, o = e; return t && (i = Y(t), n[i] && (o += " (" + r(n[i]) + ")")), o } function l(e, t) { t = t || e.getCursor("start"); var n = e.getTokenAt(t); if (!n.type) return {}; for (var r, i, o = n.type.split(" "), a = {}, l = 0; l < o.length; l++)r = o[l], "strong" === r ? a.bold = !0 : "variable-2" === r ? (i = e.getLine(t.line), /^\s*\d+\.\s/.test(i) ? a["ordered-list"] = !0 : a["unordered-list"] = !0) : "atom" === r ? a.quote = !0 : "em" === r ? a.italic = !0 : "quote" === r ? a.quote = !0 : "strikethrough" === r ? a.strikethrough = !0 : "comment" === r ? a.code = !0 : "link" === r ? a.link = !0 : "tag" === r ? a.image = !0 : r.match(/^header(\-[1-6])?$/) && (a[r.replace("header", "heading")] = !0); return a } function s(e) { var t = e.codemirror; t.setOption("fullScreen", !t.getOption("fullScreen")), t.getOption("fullScreen") ? (V = document.body.style.overflow, document.body.style.overflow = "hidden") : document.body.style.overflow = V; var n = t.getWrapperElement(); /fullscreen/.test(n.previousSibling.className) ? n.previousSibling.className = n.previousSibling.className.replace(/\s*fullscreen\b/, "") : n.previousSibling.className += " fullscreen"; var r = e.toolbarElements.fullscreen; /active/.test(r.className) ? r.className = r.className.replace(/\s*active\s*/g, "") : r.className += " active"; var i = t.getWrapperElement().nextSibling; /editor-preview-active-side/.test(i.className) && N(e) } function c(e) { P(e, "bold", e.options.blockStyles.bold) } function u(e) { P(e, "italic", e.options.blockStyles.italic) } function f(e) { P(e, "strikethrough", "~~") } function h(e) { function t(e) { if ("object" != typeof e) throw "fencing_line() takes a 'line' object (not a line number, or line text).  Got: " + typeof e + ": " + e; return e.styles && e.styles[2] && -1 !== e.styles[2].indexOf("formatting-code-block") } function n(e) { return e.state.base.base || e.state.base } function r(e, r, i, o, a) { i = i || e.getLineHandle(r), o = o || e.getTokenAt({ line: r, ch: 1 }), a = a || !!i.text && e.getTokenAt({ line: r, ch: i.text.length - 1 }); var l = o.type ? o.type.split(" ") : []; return a && n(a).indentedCode ? "indented" : -1 === l.indexOf("comment") ? !1 : n(o).fencedChars || n(a).fencedChars || t(i) ? "fenced" : "single" } function i(e, t, n, r) { var i = t.line + 1, o = n.line + 1, a = t.line !== n.line, l = r + "\n", s = "\n" + r; a && o++ , a && 0 === n.ch && (s = r + "\n", o--), E(e, !1, [l, s]), e.setSelection({ line: i, ch: 0 }, { line: o, ch: 0 }) } var o, a, l, s = e.options.blockStyles.code, c = e.codemirror, u = c.getCursor("start"), f = c.getCursor("end"), h = c.getTokenAt({ line: u.line, ch: u.ch || 1 }), d = c.getLineHandle(u.line), p = r(c, u.line, d, h); if ("single" === p) { var m = d.text.slice(0, u.ch).replace("`", ""), g = d.text.slice(u.ch).replace("`", ""); c.replaceRange(m + g, { line: u.line, ch: 0 }, { line: u.line, ch: 99999999999999 }), u.ch-- , u !== f && f.ch-- , c.setSelection(u, f), c.focus() } else if ("fenced" === p) if (u.line !== f.line || u.ch !== f.ch) { for (o = u.line; o >= 0 && (d = c.getLineHandle(o), !t(d)); o--); var v, y, x, b, w = c.getTokenAt({ line: o, ch: 1 }), k = n(w).fencedChars; t(c.getLineHandle(u.line)) ? (v = "", y = u.line) : t(c.getLineHandle(u.line - 1)) ? (v = "", y = u.line - 1) : (v = k + "\n", y = u.line), t(c.getLineHandle(f.line)) ? (x = "", b = f.line, 0 === f.ch && (b += 1)) : 0 !== f.ch && t(c.getLineHandle(f.line + 1)) ? (x = "", b = f.line + 1) : (x = k + "\n", b = f.line + 1), 0 === f.ch && (b -= 1), c.operation(function () { c.replaceRange(x, { line: b, ch: 0 }, { line: b + (x ? 0 : 1), ch: 0 }), c.replaceRange(v, { line: y, ch: 0 }, { line: y + (v ? 0 : 1), ch: 0 }) }), c.setSelection({ line: y + (v ? 1 : 0), ch: 0 }, { line: b + (v ? 1 : -1), ch: 0 }), c.focus() } else { var S = u.line; if (t(c.getLineHandle(u.line)) && ("fenced" === r(c, u.line + 1) ? (o = u.line, S = u.line + 1) : (a = u.line, S = u.line - 1)), void 0 === o) for (o = S; o >= 0 && (d = c.getLineHandle(o), !t(d)); o--); if (void 0 === a) for (l = c.lineCount(), a = S; l > a && (d = c.getLineHandle(a), !t(d)); a++); c.operation(function () { c.replaceRange("", { line: o, ch: 0 }, { line: o + 1, ch: 0 }), c.replaceRange("", { line: a - 1, ch: 0 }, { line: a, ch: 0 }) }), c.focus() } else if ("indented" === p) { if (u.line !== f.line || u.ch !== f.ch) o = u.line, a = f.line, 0 === f.ch && a--; else { for (o = u.line; o >= 0; o--)if (d = c.getLineHandle(o), !d.text.match(/^\s*$/) && "indented" !== r(c, o, d)) { o += 1; break } for (l = c.lineCount(), a = u.line; l > a; a++)if (d = c.getLineHandle(a), !d.text.match(/^\s*$/) && "indented" !== r(c, a, d)) { a -= 1; break } } var C = c.getLineHandle(a + 1), L = C && c.getTokenAt({ line: a + 1, ch: C.text.length - 1 }), T = L && n(L).indentedCode; T && c.replaceRange("\n", { line: a + 1, ch: 0 }); for (var M = o; a >= M; M++)c.indentLine(M, "subtract"); c.focus() } else { var N = u.line === f.line && u.ch === f.ch && 0 === u.ch, A = u.line !== f.line; N || A ? i(c, u, f, s) : E(c, !1, ["`", "`"]) } } function d(e) { var t = e.codemirror; I(t, "quote") } function p(e) { var t = e.codemirror; O(t, "smaller") } function m(e) { var t = e.codemirror; O(t, "bigger") } function g(e) { var t = e.codemirror; O(t, void 0, 1) } function v(e) { var t = e.codemirror; O(t, void 0, 2) } function y(e) { var t = e.codemirror; O(t, void 0, 3) } function x(e) { var t = e.codemirror; I(t, "unordered-list") } function b(e) { var t = e.codemirror; I(t, "ordered-list") } function w(e) { var t = e.codemirror; R(t) } function k(e) { var t = e.codemirror, n = l(t), r = e.options, i = "http://"; return r.promptURLs && (i = prompt(r.promptTexts.link), !i) ? !1 : void E(t, n.link, r.insertTexts.link, i) } function S(e) { var t = e.codemirror, n = l(t), r = e.options, i = "http://"; return r.promptURLs && (i = prompt(r.promptTexts.image), !i) ? !1 : void E(t, n.image, r.insertTexts.image, i) } function C(e) { var t = e.codemirror, n = l(t), r = e.options; E(t, n.table, r.insertTexts.table) } function L(e) { var t = e.codemirror, n = l(t), r = e.options; E(t, n.image, r.insertTexts.horizontalRule) } function T(e) { var t = e.codemirror; t.undo(), t.focus() } function M(e) { var t = e.codemirror; t.redo(), t.focus() } function N(e) { var t = e.codemirror, n = t.getWrapperElement(), r = n.nextSibling, i = e.toolbarElements["side-by-side"], o = !1; /editor-preview-active-side/.test(r.className) ? (r.className = r.className.replace(/\s*editor-preview-active-side\s*/g, ""), i.className = i.className.replace(/\s*active\s*/g, ""), n.className = n.className.replace(/\s*CodeMirror-sided\s*/g, " ")) : (setTimeout(function () { t.getOption("fullScreen") || s(e), r.className += " editor-preview-active-side" }, 1), i.className += " active", n.className += " CodeMirror-sided", o = !0); var a = n.lastChild; if (/editor-preview-active/.test(a.className)) { a.className = a.className.replace(/\s*editor-preview-active\s*/g, ""); var l = e.toolbarElements.preview, c = n.previousSibling; l.className = l.className.replace(/\s*active\s*/g, ""), c.className = c.className.replace(/\s*disabled-for-preview*/g, "") } var u = function () { r.innerHTML = e.options.previewRender(e.value(), r) }; t.sideBySideRenderingFunction || (t.sideBySideRenderingFunction = u), o ? (r.innerHTML = e.options.previewRender(e.value(), r), t.on("update", t.sideBySideRenderingFunction)) : t.off("update", t.sideBySideRenderingFunction), t.refresh() } function A(e) { var t = e.codemirror, n = t.getWrapperElement(), r = n.previousSibling, i = e.options.toolbar ? e.toolbarElements.preview : !1, o = n.lastChild; o && /editor-preview/.test(o.className) || (o = document.createElement("div"), o.className = "editor-preview", n.appendChild(o)), /editor-preview-active/.test(o.className) ? (o.className = o.className.replace(/\s*editor-preview-active\s*/g, ""), i && (i.className = i.className.replace(/\s*active\s*/g, ""), r.className = r.className.replace(/\s*disabled-for-preview*/g, ""))) : (setTimeout(function () { o.className += " editor-preview-active" }, 1), i && (i.className += " active", r.className += " disabled-for-preview")), o.innerHTML = e.options.previewRender(e.value(), o); var a = t.getWrapperElement().nextSibling; /editor-preview-active-side/.test(a.className) && N(e) } function E(e, t, n, r) { if (!/editor-preview-active/.test(e.getWrapperElement().lastChild.className)) { var i, o = n[0], a = n[1], l = e.getCursor("start"), s = e.getCursor("end"); r && (a = a.replace("#url#", r)), t ? (i = e.getLine(l.line), o = i.slice(0, l.ch), a = i.slice(l.ch), e.replaceRange(o + a, { line: l.line, ch: 0 })) : (i = e.getSelection(), e.replaceSelection(o + i + a), l.ch += o.length, l !== s && (s.ch += o.length)), e.setSelection(l, s), e.focus() } } function O(e, t, n) { if (!/editor-preview-active/.test(e.getWrapperElement().lastChild.className)) { for (var r = e.getCursor("start"), i = e.getCursor("end"), o = r.line; o <= i.line; o++)!function (r) { var i = e.getLine(r), o = i.search(/[^#]/); i = void 0 !== t ? 0 >= o ? "bigger" == t ? "###### " + i : "# " + i : 6 == o && "smaller" == t ? i.substr(7) : 1 == o && "bigger" == t ? i.substr(2) : "bigger" == t ? i.substr(1) : "#" + i : 1 == n ? 0 >= o ? "# " + i : o == n ? i.substr(o + 1) : "# " + i.substr(o + 1) : 2 == n ? 0 >= o ? "## " + i : o == n ? i.substr(o + 1) : "## " + i.substr(o + 1) : 0 >= o ? "### " + i : o == n ? i.substr(o + 1) : "### " + i.substr(o + 1), e.replaceRange(i, { line: r, ch: 0 }, { line: r, ch: 99999999999999 }) }(o); e.focus() } } function I(e, t) { if (!/editor-preview-active/.test(e.getWrapperElement().lastChild.className)) { for (var n = l(e), r = e.getCursor("start"), i = e.getCursor("end"), o = { quote: /^(\s*)\>\s+/, "unordered-list": /^(\s*)(\*|\-|\+)\s+/, "ordered-list": /^(\s*)\d+\.\s+/ }, a = { quote: "> ", "unordered-list": "* ", "ordered-list": "1. " }, s = r.line; s <= i.line; s++)!function (r) { var i = e.getLine(r); i = n[t] ? i.replace(o[t], "$1") : a[t] + i, e.replaceRange(i, { line: r, ch: 0 }, { line: r, ch: 99999999999999 }) }(s); e.focus() } } function P(e, t, n, r) { if (!/editor-preview-active/.test(e.codemirror.getWrapperElement().lastChild.className)) { r = "undefined" == typeof r ? n : r; var i, o = e.codemirror, a = l(o), s = n, c = r, u = o.getCursor("start"), f = o.getCursor("end"); a[t] ? (i = o.getLine(u.line), s = i.slice(0, u.ch), c = i.slice(u.ch), "bold" == t ? (s = s.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, ""), c = c.replace(/(\*\*|__)/, "")) : "italic" == t ? (s = s.replace(/(\*|_)(?![\s\S]*(\*|_))/, ""), c = c.replace(/(\*|_)/, "")) : "strikethrough" == t && (s = s.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, ""), c = c.replace(/(\*\*|~~)/, "")), o.replaceRange(s + c, { line: u.line, ch: 0 }, { line: u.line, ch: 99999999999999 }), "bold" == t || "strikethrough" == t ? (u.ch -= 2, u !== f && (f.ch -= 2)) : "italic" == t && (u.ch -= 1, u !== f && (f.ch -= 1))) : (i = o.getSelection(), "bold" == t ? (i = i.split("**").join(""), i = i.split("__").join("")) : "italic" == t ? (i = i.split("*").join(""), i = i.split("_").join("")) : "strikethrough" == t && (i = i.split("~~").join("")), o.replaceSelection(s + i + c), u.ch += n.length, f.ch = u.ch + i.length), o.setSelection(u, f), o.focus() } } function R(e) { if (!/editor-preview-active/.test(e.getWrapperElement().lastChild.className)) for (var t, n = e.getCursor("start"), r = e.getCursor("end"), i = n.line; i <= r.line; i++)t = e.getLine(i), t = t.replace(/^[ ]*([# ]+|\*|\-|[> ]+|[0-9]+(.|\)))[ ]*/, ""), e.replaceRange(t, { line: i, ch: 0 }, { line: i, ch: 99999999999999 }) } function D(e, t) { for (var n in t) t.hasOwnProperty(n) && (t[n] instanceof Array ? e[n] = t[n].concat(e[n] instanceof Array ? e[n] : []) : null !== t[n] && "object" == typeof t[n] && t[n].constructor === Object ? e[n] = D(e[n] || {}, t[n]) : e[n] = t[n]); return e } function H(e) { for (var t = 1; t < arguments.length; t++)e = D(e, arguments[t]); return e } function W(e) { var t = /[a-zA-Z0-9_\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g, n = e.match(t), r = 0; if (null === n) return r; for (var i = 0; i < n.length; i++)r += n[i].charCodeAt(0) >= 19968 ? n[i].length : 1; return r } function B(e) { e = e || {}, e.parent = this; var t = !0; if (e.autoDownloadFontAwesome === !1 && (t = !1), e.autoDownloadFontAwesome !== !0) for (var n = document.styleSheets, r = 0; r < n.length; r++)n[r].href && n[r].href.indexOf("//maxcdn.bootstrapcdn.com/font-awesome/") > -1 && (t = !1); if (t) { var i = document.createElement("link"); i.rel = "stylesheet", i.href = "https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css", document.getElementsByTagName("head")[0].appendChild(i) } if (e.element) this.element = e.element; else if (null === e.element) return void console.log("SimpleMDE: Error. No element was found."); if (void 0 === e.toolbar) { e.toolbar = []; for (var o in K) K.hasOwnProperty(o) && (-1 != o.indexOf("separator-") && e.toolbar.push("|"), (K[o]["default"] === !0 || e.showIcons && e.showIcons.constructor === Array && -1 != e.showIcons.indexOf(o)) && e.toolbar.push(o)) } e.hasOwnProperty("status") || (e.status = ["autosave", "lines", "words", "cursor"]), e.previewRender || (e.previewRender = function (e) { return this.parent.markdown(e) }), e.parsingConfig = H({ highlightFormatting: !0 }, e.parsingConfig || {}), e.insertTexts = H({}, X, e.insertTexts || {}), e.promptTexts = Z, e.blockStyles = H({}, J, e.blockStyles || {}), e.shortcuts = H({}, G, e.shortcuts || {}), void 0 != e.autosave && void 0 != e.autosave.unique_id && "" != e.autosave.unique_id && (e.autosave.uniqueId = e.autosave.unique_id), this.options = e, this.render(), !e.initialValue || this.options.autosave && this.options.autosave.foundSavedValue === !0 || this.value(e.initialValue) } function _() { if ("object" != typeof localStorage) return !1; try { localStorage.setItem("smde_localStorage", 1), localStorage.removeItem("smde_localStorage") } catch (e) { return !1 } return !0 } var F = e("codemirror"); e("codemirror/addon/edit/continuelist.js"), e("./codemirror/tablist"), e("codemirror/addon/display/fullscreen.js"), e("codemirror/mode/markdown/markdown.js"), e("codemirror/addon/mode/overlay.js"), e("codemirror/addon/display/placeholder.js"), e("codemirror/addon/selection/mark-selection.js"), e("codemirror/mode/gfm/gfm.js"), e("codemirror/mode/xml/xml.js"); var z = e("codemirror-spell-checker"), j = e("marked"), U = /Mac/.test(navigator.platform), q = { toggleBold: c, toggleItalic: u, drawLink: k, toggleHeadingSmaller: p, toggleHeadingBigger: m, drawImage: S, toggleBlockquote: d, toggleOrderedList: b, toggleUnorderedList: x, toggleCodeBlock: h, togglePreview: A, toggleStrikethrough: f, toggleHeading1: g, toggleHeading2: v, toggleHeading3: y, cleanBlock: w, drawTable: C, drawHorizontalRule: L, undo: T, redo: M, toggleSideBySide: N, toggleFullScreen: s }, G = { toggleBold: "Cmd-B", toggleItalic: "Cmd-I", drawLink: "Cmd-K", toggleHeadingSmaller: "Cmd-H", toggleHeadingBigger: "Shift-Cmd-H", cleanBlock: "Cmd-E", drawImage: "Cmd-Alt-I", toggleBlockquote: "Cmd-'", toggleOrderedList: "Cmd-Alt-L", toggleUnorderedList: "Cmd-L", toggleCodeBlock: "Cmd-Alt-C", togglePreview: "Cmd-P", toggleSideBySide: "F9", toggleFullScreen: "F11" }, Y = function (e) { for (var t in q) if (q[t] === e) return t; return null }, $ = function () {
                var e = !1; return function (t) {
                (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0);
                }(navigator.userAgent || navigator.vendor || window.opera), e
            }, V = "", K = { bold: { name: "bold", action: c, className: "fa fa-bold", title: "Bold", "default": !0 }, italic: { name: "italic", action: u, className: "fa fa-italic", title: "Italic", "default": !0 }, strikethrough: { name: "strikethrough", action: f, className: "fa fa-strikethrough", title: "Strikethrough" }, heading: { name: "heading", action: p, className: "fa fa-header", title: "Heading", "default": !0 }, "heading-smaller": { name: "heading-smaller", action: p, className: "fa fa-header fa-header-x fa-header-smaller", title: "Smaller Heading" }, "heading-bigger": { name: "heading-bigger", action: m, className: "fa fa-header fa-header-x fa-header-bigger", title: "Bigger Heading" }, "heading-1": { name: "heading-1", action: g, className: "fa fa-header fa-header-x fa-header-1", title: "Big Heading" }, "heading-2": { name: "heading-2", action: v, className: "fa fa-header fa-header-x fa-header-2", title: "Medium Heading" }, "heading-3": { name: "heading-3", action: y, className: "fa fa-header fa-header-x fa-header-3", title: "Small Heading" }, "separator-1": { name: "separator-1" }, code: { name: "code", action: h, className: "fa fa-code", title: "Code" }, quote: { name: "quote", action: d, className: "fa fa-quote-left", title: "Quote", "default": !0 }, "unordered-list": { name: "unordered-list", action: x, className: "fa fa-list-ul", title: "Generic List", "default": !0 }, "ordered-list": { name: "ordered-list", action: b, className: "fa fa-list-ol", title: "Numbered List", "default": !0 }, "clean-block": { name: "clean-block", action: w, className: "fa fa-eraser fa-clean-block", title: "Clean block" }, "separator-2": { name: "separator-2" }, link: { name: "link", action: k, className: "fa fa-link", title: "Create Link", "default": !0 }, image: { name: "image", action: S, className: "fa fa-picture-o", title: "Insert Image", "default": !0 }, table: { name: "table", action: C, className: "fa fa-table", title: "Insert Table" }, "horizontal-rule": { name: "horizontal-rule", action: L, className: "fa fa-minus", title: "Insert Horizontal Line" }, "separator-3": { name: "separator-3" }, preview: { name: "preview", action: A, className: "fa fa-eye no-disable", title: "Toggle Preview", "default": !0 }, "side-by-side": { name: "side-by-side", action: N, className: "fa fa-columns no-disable no-mobile", title: "Toggle Side by Side", "default": !0 }, fullscreen: { name: "fullscreen", action: s, className: "fa fa-arrows-alt no-disable no-mobile", title: "Toggle Fullscreen", "default": !0 }, "separator-4": { name: "separator-4" }, guide: { name: "guide", action: "https://simplemde.com/markdown-guide", className: "fa fa-question-circle", title: "Markdown Guide", "default": !0 }, "separator-5": { name: "separator-5" }, undo: { name: "undo", action: T, className: "fa fa-undo no-disable", title: "Undo" }, redo: { name: "redo", action: M, className: "fa fa-repeat no-disable", title: "Redo" } }, X = { link: ["[", "](#url#)"], image: ["![](", "#url#)"], table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n"], horizontalRule: ["", "\n\n-----\n\n"] }, Z = { link: "URL for the link:", image: "URL of the image:" }, J = { bold: "**", code: "```", italic: "*" }; B.prototype.markdown = function (e) { if (j) { var t = {}; return this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === !1 ? t.breaks = !1 : t.breaks = !0, this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === !0 && window.hljs && (t.highlight = function (e) { return window.hljs.highlightAuto(e).value }), j.setOptions(t), j(e) } }, B.prototype.render = function (e) { if (e || (e = this.element || document.getElementsByTagName("textarea")[0]), !this._rendered || this._rendered !== e) { this.element = e; var t = this.options, n = this, i = {}; for (var o in t.shortcuts) null !== t.shortcuts[o] && null !== q[o] && !function (e) { i[r(t.shortcuts[e])] = function () { q[e](n) } }(o); i.Enter = "newlineAndIndentContinueMarkdownList", i.Tab = "tabAndIndentMarkdownList", i["Shift-Tab"] = "shiftTabAndUnindentMarkdownList", i.Esc = function (e) { e.getOption("fullScreen") && s(n) }, document.addEventListener("keydown", function (e) { e = e || window.event, 27 == e.keyCode && n.codemirror.getOption("fullScreen") && s(n) }, !1); var a, l; if (t.spellChecker !== !1 ? (a = "spell-checker", l = t.parsingConfig, l.name = "gfm", l.gitHubSpice = !1, z({ codeMirrorInstance: F })) : (a = t.parsingConfig, a.name = "gfm", a.gitHubSpice = !1), this.codemirror = F.fromTextArea(e, { mode: a, backdrop: l, theme: "paper", tabSize: void 0 != t.tabSize ? t.tabSize : 2, indentUnit: void 0 != t.tabSize ? t.tabSize : 2, indentWithTabs: t.indentWithTabs !== !1, lineNumbers: !1, autofocus: t.autofocus === !0, extraKeys: i, lineWrapping: t.lineWrapping !== !1, allowDropFileTypes: ["text/plain"], placeholder: t.placeholder || e.getAttribute("placeholder") || "", styleSelectedText: void 0 != t.styleSelectedText ? t.styleSelectedText : !0 }), t.forceSync === !0) { var c = this.codemirror; c.on("change", function () { c.save() }) } this.gui = {}, t.toolbar !== !1 && (this.gui.toolbar = this.createToolbar()), t.status !== !1 && (this.gui.statusbar = this.createStatusbar()), void 0 != t.autosave && t.autosave.enabled === !0 && this.autosave(), this.gui.sideBySide = this.createSideBySide(), this._rendered = this.element; var u = this.codemirror; setTimeout(function () { u.refresh() }.bind(u), 0) } }, B.prototype.autosave = function () { if (_()) { var e = this; if (void 0 == this.options.autosave.uniqueId || "" == this.options.autosave.uniqueId) return void console.log("SimpleMDE: You must set a uniqueId to use the autosave feature"); null != e.element.form && void 0 != e.element.form && e.element.form.addEventListener("submit", function () { localStorage.removeItem("smde_" + e.options.autosave.uniqueId) }), this.options.autosave.loaded !== !0 && ("string" == typeof localStorage.getItem("smde_" + this.options.autosave.uniqueId) && "" != localStorage.getItem("smde_" + this.options.autosave.uniqueId) && (this.codemirror.setValue(localStorage.getItem("smde_" + this.options.autosave.uniqueId)), this.options.autosave.foundSavedValue = !0), this.options.autosave.loaded = !0), localStorage.setItem("smde_" + this.options.autosave.uniqueId, e.value()); var t = document.getElementById("autosaved"); if (null != t && void 0 != t && "" != t) { var n = new Date, r = n.getHours(), i = n.getMinutes(), o = "am", a = r; a >= 12 && (a = r - 12, o = "pm"), 0 == a && (a = 12), i = 10 > i ? "0" + i : i, t.innerHTML = "Autosaved: " + a + ":" + i + " " + o } this.autosaveTimeoutId = setTimeout(function () { e.autosave() }, this.options.autosave.delay || 1e4) } else console.log("SimpleMDE: localStorage not available, cannot autosave") }, B.prototype.clearAutosavedValue = function () { if (_()) { if (void 0 == this.options.autosave || void 0 == this.options.autosave.uniqueId || "" == this.options.autosave.uniqueId) return void console.log("SimpleMDE: You must set a uniqueId to clear the autosave value"); localStorage.removeItem("smde_" + this.options.autosave.uniqueId) } else console.log("SimpleMDE: localStorage not available, cannot autosave") }, B.prototype.createSideBySide = function () { var e = this.codemirror, t = e.getWrapperElement(), n = t.nextSibling; n && /editor-preview-side/.test(n.className) || (n = document.createElement("div"), n.className = "editor-preview-side", t.parentNode.insertBefore(n, t.nextSibling)); var r = !1, i = !1; return e.on("scroll", function (e) { if (r) return void (r = !1); i = !0; var t = e.getScrollInfo().height - e.getScrollInfo().clientHeight, o = parseFloat(e.getScrollInfo().top) / t, a = (n.scrollHeight - n.clientHeight) * o; n.scrollTop = a }), n.onscroll = function () { if (i) return void (i = !1); r = !0; var t = n.scrollHeight - n.clientHeight, o = parseFloat(n.scrollTop) / t, a = (e.getScrollInfo().height - e.getScrollInfo().clientHeight) * o; e.scrollTo(0, a) }, n }, B.prototype.createToolbar = function (e) { if (e = e || this.options.toolbar, e && 0 !== e.length) { var t; for (t = 0; t < e.length; t++)void 0 != K[e[t]] && (e[t] = K[e[t]]); var n = document.createElement("div"); n.className = "editor-toolbar"; var r = this, a = {}; for (r.toolbar = e, t = 0; t < e.length; t++)if (("guide" != e[t].name || r.options.toolbarGuideIcon !== !1) && !(r.options.hideIcons && -1 != r.options.hideIcons.indexOf(e[t].name) || ("fullscreen" == e[t].name || "side-by-side" == e[t].name) && $())) { if ("|" === e[t]) { for (var s = !1, c = t + 1; c < e.length; c++)"|" === e[c] || r.options.hideIcons && -1 != r.options.hideIcons.indexOf(e[c].name) || (s = !0); if (!s) continue } !function (e) { var t; t = "|" === e ? o() : i(e, r.options.toolbarTips, r.options.shortcuts), e.action && ("function" == typeof e.action ? t.onclick = function (t) { t.preventDefault(), e.action(r) } : "string" == typeof e.action && (t.href = e.action, t.target = "_blank")), a[e.name || e] = t, n.appendChild(t) }(e[t]) } r.toolbarElements = a; var u = this.codemirror; u.on("cursorActivity", function () { var e = l(u); for (var t in a) !function (t) { var n = a[t]; e[t] ? n.className += " active" : "fullscreen" != t && "side-by-side" != t && (n.className = n.className.replace(/\s*active\s*/g, "")) }(t) }); var f = u.getWrapperElement(); return f.parentNode.insertBefore(n, f), n } }, B.prototype.createStatusbar = function (e) { e = e || this.options.status; var t = this.options, n = this.codemirror; if (e && 0 !== e.length) { var r, i, o, a = []; for (r = 0; r < e.length; r++)if (i = void 0, o = void 0, "object" == typeof e[r]) a.push({ className: e[r].className, defaultValue: e[r].defaultValue, onUpdate: e[r].onUpdate }); else { var l = e[r]; "words" === l ? (o = function (e) { e.innerHTML = W(n.getValue()) }, i = function (e) { e.innerHTML = W(n.getValue()) }) : "lines" === l ? (o = function (e) { e.innerHTML = n.lineCount() }, i = function (e) { e.innerHTML = n.lineCount() }) : "cursor" === l ? (o = function (e) { e.innerHTML = "0:0" }, i = function (e) { var t = n.getCursor(); e.innerHTML = t.line + ":" + t.ch }) : "autosave" === l && (o = function (e) { void 0 != t.autosave && t.autosave.enabled === !0 && e.setAttribute("id", "autosaved") }), a.push({ className: l, defaultValue: o, onUpdate: i }) } var s = document.createElement("div"); for (s.className = "editor-statusbar", r = 0; r < a.length; r++) { var c = a[r], u = document.createElement("span"); u.className = c.className, "function" == typeof c.defaultValue && c.defaultValue(u), "function" == typeof c.onUpdate && this.codemirror.on("update", function (e, t) { return function () { t.onUpdate(e) } }(u, c)), s.appendChild(u) } var f = this.codemirror.getWrapperElement(); return f.parentNode.insertBefore(s, f.nextSibling), s } }, B.prototype.value = function (e) { return void 0 === e ? this.codemirror.getValue() : (this.codemirror.getDoc().setValue(e), this) }, B.toggleBold = c, B.toggleItalic = u, B.toggleStrikethrough = f, B.toggleBlockquote = d, B.toggleHeadingSmaller = p, B.toggleHeadingBigger = m, B.toggleHeading1 = g, B.toggleHeading2 = v, B.toggleHeading3 = y, B.toggleCodeBlock = h, B.toggleUnorderedList = x, B.toggleOrderedList = b, B.cleanBlock = w, B.drawLink = k, B.drawImage = S, B.drawTable = C, B.drawHorizontalRule = L, B.undo = T, B.redo = M, B.togglePreview = A, B.toggleSideBySide = N, B.toggleFullScreen = s, B.prototype.toggleBold = function () { c(this) }, B.prototype.toggleItalic = function () { u(this) }, B.prototype.toggleStrikethrough = function () { f(this) }, B.prototype.toggleBlockquote = function () { d(this) }, B.prototype.toggleHeadingSmaller = function () { p(this) }, B.prototype.toggleHeadingBigger = function () { m(this) }, B.prototype.toggleHeading1 = function () { g(this) }, B.prototype.toggleHeading2 = function () { v(this) }, B.prototype.toggleHeading3 = function () { y(this) }, B.prototype.toggleCodeBlock = function () { h(this) }, B.prototype.toggleUnorderedList = function () { x(this) }, B.prototype.toggleOrderedList = function () { b(this) }, B.prototype.cleanBlock = function () { w(this) }, B.prototype.drawLink = function () { k(this) }, B.prototype.drawImage = function () { S(this) }, B.prototype.drawTable = function () { C(this) }, B.prototype.drawHorizontalRule = function () { L(this) }, B.prototype.undo = function () { T(this) }, B.prototype.redo = function () { M(this) }, B.prototype.togglePreview = function () { A(this) }, B.prototype.toggleSideBySide = function () { N(this) }, B.prototype.toggleFullScreen = function () { s(this) }, B.prototype.isPreviewActive = function () { var e = this.codemirror, t = e.getWrapperElement(), n = t.lastChild; return /editor-preview-active/.test(n.className) }, B.prototype.isSideBySideActive = function () { var e = this.codemirror, t = e.getWrapperElement(), n = t.nextSibling; return /editor-preview-active-side/.test(n.className) }, B.prototype.isFullscreenActive = function () { var e = this.codemirror; return e.getOption("fullScreen") }, B.prototype.getState = function () { var e = this.codemirror; return l(e) }, B.prototype.toTextArea = function () { var e = this.codemirror, t = e.getWrapperElement(); t.parentNode && (this.gui.toolbar && t.parentNode.removeChild(this.gui.toolbar), this.gui.statusbar && t.parentNode.removeChild(this.gui.statusbar), this.gui.sideBySide && t.parentNode.removeChild(this.gui.sideBySide)), e.toTextArea(), this.autosaveTimeoutId && (clearTimeout(this.autosaveTimeoutId), this.autosaveTimeoutId = void 0, this.clearAutosavedValue()) }, t.exports = B
        }, { "./codemirror/tablist": 19, codemirror: 10, "codemirror-spell-checker": 4, "codemirror/addon/display/fullscreen.js": 5, "codemirror/addon/display/placeholder.js": 6, "codemirror/addon/edit/continuelist.js": 7, "codemirror/addon/mode/overlay.js": 8, "codemirror/addon/selection/mark-selection.js": 9, "codemirror/mode/gfm/gfm.js": 11, "codemirror/mode/markdown/markdown.js": 12, "codemirror/mode/xml/xml.js": 14, marked: 17 }]
    }, {}, [20])(20)
});

/* jquery.signalR.core.js */
/*global window:false */
/*!
 * ASP.NET SignalR JavaScript Library v2.0.3
 * http://signalr.net/
 *
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *
 */

/// <reference path="Scripts/jquery-1.6.4.js" />
/// <reference path="jquery.signalR.version.js" />
(function ($, window, undefined) {
    "use strict";

    var resources = {
        nojQuery: "jQuery was not found. Please ensure jQuery is referenced before the SignalR client JavaScript file.",
        noTransportOnInit: "No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization.",
        errorOnNegotiate: "Error during negotiation request.",
        stoppedWhileLoading: "The connection was stopped during page load.",
        stoppedWhileNegotiating: "The connection was stopped during the negotiate request.",
        errorParsingNegotiateResponse: "Error parsing negotiate response.",
        protocolIncompatible: "You are using a version of the client that isn't compatible with the server. Client version {0}, server version {1}.",
        sendFailed: "Send failed.",
        parseFailed: "Failed at parsing response: {0}",
        longPollFailed: "Long polling request failed.",
        eventSourceFailedToConnect: "EventSource failed to connect.",
        eventSourceError: "Error raised by EventSource",
        webSocketClosed: "WebSocket closed.",
        pingServerFailedInvalidResponse: "Invalid ping response when pinging server: '{0}'.",
        pingServerFailed: "Failed to ping server.",
        pingServerFailedStatusCode: "Failed to ping server.  Server responded with status code {0}, stopping the connection.",
        pingServerFailedParse: "Failed to parse ping server response, stopping the connection.",
        noConnectionTransport: "Connection is in an invalid state, there is no transport active.",
        webSocketsInvalidState: "The Web Socket transport is in an invalid state, transitioning into reconnecting."
    };

    if (typeof ($) !== "function") {
        // no jQuery!
        throw new Error(resources.nojQuery);
    }

    var signalR,
        _connection,
        _pageLoaded = (window.document.readyState === "complete"),
        _pageWindow = $(window),
        _negotiateAbortText = "__Negotiate Aborted__",
        events = {
            onStart: "onStart",
            onStarting: "onStarting",
            onReceived: "onReceived",
            onError: "onError",
            onConnectionSlow: "onConnectionSlow",
            onReconnecting: "onReconnecting",
            onReconnect: "onReconnect",
            onStateChanged: "onStateChanged",
            onDisconnect: "onDisconnect"
        },
        ajaxDefaults = {
            processData: true,
            timeout: null,
            async: true,
            global: false,
            cache: false
        },
        log = function (msg, logging) {
            if (logging === false) {
                return;
            }
            var m;
            if (typeof (window.console) === "undefined") {
                return;
            }
            m = "[" + new Date().toTimeString() + "] SignalR: " + msg;
            if (window.console.debug) {
                window.console.debug(m);
            } else if (window.console.log) {
                window.console.log(m);
            }
        },

        changeState = function (connection, expectedState, newState) {
            if (expectedState === connection.state) {
                connection.state = newState;

                $(connection).triggerHandler(events.onStateChanged, [{ oldState: expectedState, newState: newState }]);
                return true;
            }

            return false;
        },

        isDisconnecting = function (connection) {
            return connection.state === signalR.connectionState.disconnected;
        },

        configureStopReconnectingTimeout = function (connection) {
            var stopReconnectingTimeout,
                onReconnectTimeout;

            // Check if this connection has already been configured to stop reconnecting after a specified timeout.
            // Without this check if a connection is stopped then started events will be bound multiple times.
            if (!connection._.configuredStopReconnectingTimeout) {
                onReconnectTimeout = function (connection) {
                    connection.log("Couldn't reconnect within the configured timeout (" + connection.disconnectTimeout + "ms), disconnecting.");
                    connection.stop(/* async */ false, /* notifyServer */ false);
                };

                connection.reconnecting(function () {
                    var connection = this;

                    // Guard against state changing in a previous user defined even handler
                    if (connection.state === signalR.connectionState.reconnecting) {
                        stopReconnectingTimeout = window.setTimeout(function () { onReconnectTimeout(connection); }, connection.disconnectTimeout);
                    }
                });

                connection.stateChanged(function (data) {
                    if (data.oldState === signalR.connectionState.reconnecting) {
                        // Clear the pending reconnect timeout check
                        window.clearTimeout(stopReconnectingTimeout);
                    }
                });

                connection._.configuredStopReconnectingTimeout = true;
            }
        };

    signalR = function (url, qs, logging) {
        /// <summary>Creates a new SignalR connection for the given url</summary>
        /// <param name="url" type="String">The URL of the long polling endpoint</param>
        /// <param name="qs" type="Object">
        ///     [Optional] Custom querystring parameters to add to the connection URL.
        ///     If an object, every non-function member will be added to the querystring.
        ///     If a string, it's added to the QS as specified.
        /// </param>
        /// <param name="logging" type="Boolean">
        ///     [Optional] A flag indicating whether connection logging is enabled to the browser
        ///     console/log. Defaults to false.
        /// </param>

        return new signalR.fn.init(url, qs, logging);
    };

    signalR._ = {
        defaultContentType: "application/x-www-form-urlencoded; charset=UTF-8",

        ieVersion: (function () {
            var version,
                matches;

            if (window.navigator.appName === 'Microsoft Internet Explorer') {
                // Check if the user agent has the pattern "MSIE (one or more numbers).(one or more numbers)";
                matches = /MSIE ([0-9]+\.[0-9]+)/.exec(window.navigator.userAgent);

                if (matches) {
                    version = window.parseFloat(matches[1]);
                }
            }

            // undefined value means not IE
            return version;
        })(),

        error: function (message, source, context) {
            var e = new Error(message);
            e.source = source;

            if (typeof context !== "undefined") {
                e.context = context;
            }

            return e;
        },

        transportError: function (message, transport, source, context) {
            var e = this.error(message, source, context);
            e.transport = transport ? transport.name : undefined;
            return e;
        },

        format: function () {
            /// <summary>Usage: format("Hi {0}, you are {1}!", "Foo", 100) </summary>
            var s = arguments[0];
            for (var i = 0; i < arguments.length - 1; i++) {
                s = s.replace("{" + i + "}", arguments[i + 1]);
            }
            return s;
        },

        firefoxMajorVersion: function (userAgent) {
            // Firefox user agents: http://useragentstring.com/pages/Firefox/
            var matches = userAgent.match(/Firefox\/(\d+)/);
            if (!matches || !matches.length || matches.length < 2) {
                return 0;
            }
            return parseInt(matches[1], 10 /* radix */);
        },

        configurePingInterval: function (connection) {
            var config = connection._.config,
                onFail = function (error) {
                    $(connection).triggerHandler(events.onError, [error]);
                };

            if (config && !connection._.pingIntervalId && config.pingInterval) {
                connection._.pingIntervalId = window.setInterval(function () {
                    signalR.transports._logic.pingServer(connection).fail(onFail);
                }, config.pingInterval);
            }
        }
    };

    signalR.events = events;

    signalR.resources = resources;

    signalR.ajaxDefaults = ajaxDefaults;

    signalR.changeState = changeState;

    signalR.isDisconnecting = isDisconnecting;

    signalR.connectionState = {
        connecting: 0,
        connected: 1,
        reconnecting: 2,
        disconnected: 4
    };

    signalR.hub = {
        start: function () {
            // This will get replaced with the real hub connection start method when hubs is referenced correctly
            throw new Error("SignalR: Error loading hubs. Ensure your hubs reference is correct, e.g. <script src='/signalr/js'></script>.");
        }
    };

    _pageWindow.load(function () { _pageLoaded = true; });

    function validateTransport(requestedTransport, connection) {
        /// <summary>Validates the requested transport by cross checking it with the pre-defined signalR.transports</summary>
        /// <param name="requestedTransport" type="Object">The designated transports that the user has specified.</param>
        /// <param name="connection" type="signalR">The connection that will be using the requested transports.  Used for logging purposes.</param>
        /// <returns type="Object" />

        if ($.isArray(requestedTransport)) {
            // Go through transport array and remove an "invalid" tranports
            for (var i = requestedTransport.length - 1; i >= 0; i--) {
                var transport = requestedTransport[i];
                if ($.type(transport) !== "string" || !signalR.transports[transport]) {
                    connection.log("Invalid transport: " + transport + ", removing it from the transports list.");
                    requestedTransport.splice(i, 1);
                }
            }

            // Verify we still have transports left, if we dont then we have invalid transports
            if (requestedTransport.length === 0) {
                connection.log("No transports remain within the specified transport array.");
                requestedTransport = null;
            }
        } else if (!signalR.transports[requestedTransport] && requestedTransport !== "auto") {
            connection.log("Invalid transport: " + requestedTransport.toString() + ".");
            requestedTransport = null;
        } else if (requestedTransport === "auto" && signalR._.ieVersion <= 8) {
            // If we're doing an auto transport and we're IE8 then force longPolling, #1764
            return ["longPolling"];

        }

        return requestedTransport;
    }

    function getDefaultPort(protocol) {
        if (protocol === "http:") {
            return 80;
        } else if (protocol === "https:") {
            return 443;
        }
    }

    function addDefaultPort(protocol, url) {
        // Remove ports  from url.  We have to check if there's a / or end of line
        // following the port in order to avoid removing ports such as 8080.
        if (url.match(/:\d+$/)) {
            return url;
        } else {
            return url + ":" + getDefaultPort(protocol);
        }
    }

    function ConnectingMessageBuffer(connection, drainCallback) {
        var that = this,
            buffer = [];

        that.tryBuffer = function (message) {
            if (connection.state === $.signalR.connectionState.connecting) {
                buffer.push(message);

                return true;
            }

            return false;
        };

        that.drain = function () {
            // Ensure that the connection is connected when we drain (do not want to drain while a connection is not active)
            if (connection.state === $.signalR.connectionState.connected) {
                while (buffer.length > 0) {
                    drainCallback(buffer.shift());
                }
            }
        };

        that.clear = function () {
            buffer = [];
        };
    }

    signalR.fn = signalR.prototype = {
        init: function (url, qs, logging) {
            var $connection = $(this);

            this.url = url;
            this.qs = qs;
            this._ = {
                keepAliveData: {},
                connectingMessageBuffer: new ConnectingMessageBuffer(this, function (message) {
                    $connection.triggerHandler(events.onReceived, [message]);
                }),
                onFailedTimeoutHandle: null,
                lastMessageAt: new Date().getTime(),
                lastActiveAt: new Date().getTime(),
                beatInterval: 5000, // Default value, will only be overridden if keep alive is enabled,
                beatHandle: null,
                totalTransportConnectTimeout: 0 // This will be the sum of the TransportConnectTimeout sent in response to negotiate and connection.transportConnectTimeout
            };
            if (typeof (logging) === "boolean") {
                this.logging = logging;
            }
        },

        _parseResponse: function (response) {
            var that = this;

            if (!response) {
                return response;
            } else if (typeof response === "string") {
                return that.json.parse(response);
            } else {
                return response;
            }
        },

        json: window.JSON,

        isCrossDomain: function (url, against) {
            /// <summary>Checks if url is cross domain</summary>
            /// <param name="url" type="String">The base URL</param>
            /// <param name="against" type="Object">
            ///     An optional argument to compare the URL against, if not specified it will be set to window.location.
            ///     If specified it must contain a protocol and a host property.
            /// </param>
            var link;

            url = $.trim(url);

            against = against || window.location;

            if (url.indexOf("http") !== 0) {
                return false;
            }

            // Create an anchor tag.
            link = window.document.createElement("a");
            link.href = url;

            // When checking for cross domain we have to special case port 80 because the window.location will remove the 
            return link.protocol + addDefaultPort(link.protocol, link.host) !== against.protocol + addDefaultPort(against.protocol, against.host);
        },

        ajaxDataType: "text",

        contentType: "application/json; charset=UTF-8",

        logging: false,

        state: signalR.connectionState.disconnected,

        clientProtocol: "1.3",

        reconnectDelay: 2000,

        transportConnectTimeout: 0,

        disconnectTimeout: 30000, // This should be set by the server in response to the negotiate request (30s default)

        reconnectWindow: 30000, // This should be set by the server in response to the negotiate request 

        keepAliveWarnAt: 2 / 3, // Warn user of slow connection if we breach the X% mark of the keep alive timeout

        start: function (options, callback) {
            /// <summary>Starts the connection</summary>
            /// <param name="options" type="Object">Options map</param>
            /// <param name="callback" type="Function">A callback function to execute when the connection has started</param>
            var connection = this,
                config = {
                    pingInterval: 300000,
                    waitForPageLoad: true,
                    transport: "auto",
                    jsonp: false
                },
                initialize,
                deferred = connection._deferral || $.Deferred(), // Check to see if there is a pre-existing deferral that's being built on, if so we want to keep using it
                parser = window.document.createElement("a");

            // Persist the deferral so that if start is called multiple times the same deferral is used.
            connection._deferral = deferred;

            if (!connection.json) {
                // no JSON!
                throw new Error("SignalR: No JSON parser found. Please ensure json2.js is referenced before the SignalR.js file if you need to support clients without native JSON parsing support, e.g. IE<8.");
            }

            if ($.type(options) === "function") {
                // Support calling with single callback parameter
                callback = options;
            } else if ($.type(options) === "object") {
                $.extend(config, options);
                if ($.type(config.callback) === "function") {
                    callback = config.callback;
                }
            }

            config.transport = validateTransport(config.transport, connection);

            // If the transport is invalid throw an error and abort start
            if (!config.transport) {
                throw new Error("SignalR: Invalid transport(s) specified, aborting start.");
            }

            connection._.config = config;

            // Check to see if start is being called prior to page load
            // If waitForPageLoad is true we then want to re-direct function call to the window load event
            if (!_pageLoaded && config.waitForPageLoad === true) {
                connection._.deferredStartHandler = function () {
                    connection.start(options, callback);
                };
                _pageWindow.bind("load", connection._.deferredStartHandler);

                return deferred.promise();
            }

            // If we're already connecting just return the same deferral as the original connection start
            if (connection.state === signalR.connectionState.connecting) {
                return deferred.promise();
            } else if (changeState(connection,
                signalR.connectionState.disconnected,
                signalR.connectionState.connecting) === false) {
                // We're not connecting so try and transition into connecting.
                // If we fail to transition then we're either in connected or reconnecting.

                deferred.resolve(connection);
                return deferred.promise();
            }

            configureStopReconnectingTimeout(connection);

            // Resolve the full url
            parser.href = connection.url;
            if (!parser.protocol || parser.protocol === ":") {
                connection.protocol = window.document.location.protocol;
                connection.host = window.document.location.host;
                connection.baseUrl = connection.protocol + "//" + connection.host;
            } else {
                connection.protocol = parser.protocol;
                connection.host = parser.host;
                connection.baseUrl = parser.protocol + "//" + parser.host;
            }

            // Set the websocket protocol
            connection.wsProtocol = connection.protocol === "https:" ? "wss://" : "ws://";

            // If jsonp with no/auto transport is specified, then set the transport to long polling
            // since that is the only transport for which jsonp really makes sense.
            // Some developers might actually choose to specify jsonp for same origin requests
            // as demonstrated by Issue #623.
            if (config.transport === "auto" && config.jsonp === true) {
                config.transport = "longPolling";
            }

            // If the url is protocol relative, prepend the current windows protocol to the url. 
            if (connection.url.indexOf("//") === 0) {
                connection.url = window.location.protocol + connection.url;
                connection.log("Protocol relative URL detected, normalizing it to '" + connection.url + "'.");
            }

            if (this.isCrossDomain(connection.url)) {
                connection.log("Auto detected cross domain url.");

                if (config.transport === "auto") {
                    // TODO: Support XDM with foreverFrame
                    config.transport = ["webSockets", "serverSentEvents", "longPolling"];
                }

                if (typeof (config.withCredentials) === "undefined") {
                    config.withCredentials = true;
                }

                // Determine if jsonp is the only choice for negotiation, ajaxSend and ajaxAbort.
                // i.e. if the browser doesn't supports CORS
                // If it is, ignore any preference to the contrary, and switch to jsonp.
                if (!config.jsonp) {
                    config.jsonp = !$.support.cors;

                    if (config.jsonp) {
                        connection.log("Using jsonp because this browser doesn't support CORS.");
                    }
                }

                connection.contentType = signalR._.defaultContentType;
            }

            connection.withCredentials = config.withCredentials;

            connection.ajaxDataType = config.jsonp ? "jsonp" : "text";

            $(connection).bind(events.onStart, function (e, data) {
                if ($.type(callback) === "function") {
                    callback.call(connection);
                }
                deferred.resolve(connection);
            });

            initialize = function (transports, index) {
                var noTransportError = signalR._.error(resources.noTransportOnInit);

                index = index || 0;
                if (index >= transports.length) {
                    // No transport initialized successfully
                    $(connection).triggerHandler(events.onError, [noTransportError]);
                    deferred.reject(noTransportError);
                    // Stop the connection if it has connected and move it into the disconnected state
                    connection.stop();
                    return;
                }

                // The connection was aborted
                if (connection.state === signalR.connectionState.disconnected) {
                    return;
                }

                var transportName = transports[index],
                    transport = signalR.transports[transportName],
                    initializationComplete = false,
                    onFailed = function () {
                        // Check if we've already triggered onFailed, onStart
                        if (!initializationComplete) {
                            initializationComplete = true;
                            window.clearTimeout(connection._.onFailedTimeoutHandle);
                            transport.stop(connection);
                            initialize(transports, index + 1);
                        }
                    };

                connection.transport = transport;

                try {
                    connection._.onFailedTimeoutHandle = window.setTimeout(function () {
                        connection.log(transport.name + " timed out when trying to connect.");
                        onFailed();
                    }, connection._.totalTransportConnectTimeout);

                    transport.start(connection, function () { // success
                        // Firefox 11+ doesn't allow sync XHR withCredentials: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#withCredentials
                        var isFirefox11OrGreater = signalR._.firefoxMajorVersion(window.navigator.userAgent) >= 11,
                            asyncAbort = !!connection.withCredentials && isFirefox11OrGreater;

                        // The connection was aborted while initializing transports
                        if (connection.state === signalR.connectionState.disconnected) {
                            return;
                        }

                        if (!initializationComplete) {
                            initializationComplete = true;

                            window.clearTimeout(connection._.onFailedTimeoutHandle);

                            if (transport.supportsKeepAlive && connection._.keepAliveData.activated) {
                                signalR.transports._logic.monitorKeepAlive(connection);
                            }

                            signalR.transports._logic.startHeartbeat(connection);

                            // Used to ensure low activity clients maintain their authentication.
                            // Must be configured once a transport has been decided to perform valid ping requests.
                            signalR._.configurePingInterval(connection);

                            changeState(connection,
                                signalR.connectionState.connecting,
                                signalR.connectionState.connected);

                            // Drain any incoming buffered messages (messages that came in prior to connect)
                            connection._.connectingMessageBuffer.drain();

                            $(connection).triggerHandler(events.onStart);

                            // wire the stop handler for when the user leaves the page
                            _pageWindow.bind("unload", function () {
                                connection.log("Window unloading, stopping the connection.");

                                connection.stop(asyncAbort);
                            });

                            if (isFirefox11OrGreater) {
                                // Firefox does not fire cross-domain XHRs in the normal unload handler on tab close.
                                // #2400
                                _pageWindow.bind("beforeunload", function () {
                                    // If connection.stop() runs runs in beforeunload and fails, it will also fail
                                    // in unload unless connection.stop() runs after a timeout.
                                    window.setTimeout(function () {
                                        connection.stop(asyncAbort);
                                    }, 0);
                                });
                            }
                        }
                    }, onFailed);
                }
                catch (error) {
                    connection.log(transport.name + " transport threw '" + error.message + "' when attempting to start.");
                    onFailed();
                }
            };

            var url = connection.url + "/negotiate",
                onFailed = function (error, connection) {
                    var err = signalR._.error(resources.errorOnNegotiate, error, connection._.negotiateRequest);

                    $(connection).triggerHandler(events.onError, err);
                    deferred.reject(err);
                    // Stop the connection if negotiate failed
                    connection.stop();
                };

            $(connection).triggerHandler(events.onStarting);

            url = signalR.transports._logic.prepareQueryString(connection, url);

            // Add the client version to the negotiate request.  We utilize the same addQs method here
            // so that it can append the clientVersion appropriately to the URL
            url = signalR.transports._logic.addQs(url, {
                clientProtocol: connection.clientProtocol
            });

            connection.log("Negotiating with '" + url + "'.");

            // Save the ajax negotiate request object so we can abort it if stop is called while the request is in flight.
            connection._.negotiateRequest = $.ajax(
                $.extend({}, $.signalR.ajaxDefaults, {
                    xhrFields: { withCredentials: connection.withCredentials },
                    url: url,
                    type: "GET",
                    contentType: connection.contentType,
                    data: {},
                    dataType: connection.ajaxDataType,
                    error: function (error, statusText) {
                        // We don't want to cause any errors if we're aborting our own negotiate request.
                        if (statusText !== _negotiateAbortText) {
                            onFailed(error, connection);
                        } else {
                            // This rejection will noop if the deferred has already been resolved or rejected.
                            deferred.reject(signalR._.error(resources.stoppedWhileNegotiating, null /* error */, connection._.negotiateRequest));
                        }
                    },
                    success: function (result) {
                        var res,
                            keepAliveData,
                            protocolError,
                            transports = [],
                            supportedTransports = [];

                        try {
                            res = connection._parseResponse(result);
                        } catch (error) {
                            onFailed(signalR._.error(resources.errorParsingNegotiateResponse, error), connection);
                            return;
                        }

                        keepAliveData = connection._.keepAliveData;
                        connection.appRelativeUrl = res.Url;
                        connection.id = res.ConnectionId;
                        connection.token = res.ConnectionToken;
                        connection.webSocketServerUrl = res.WebSocketServerUrl;

                        // Once the server has labeled the PersistentConnection as Disconnected, we should stop attempting to reconnect
                        // after res.DisconnectTimeout seconds.
                        connection.disconnectTimeout = res.DisconnectTimeout * 1000; // in ms

                        // Add the TransportConnectTimeout from the response to the transportConnectTimeout from the client to calculate the total timeout
                        connection._.totalTransportConnectTimeout = connection.transportConnectTimeout + res.TransportConnectTimeout * 1000;

                        // If we have a keep alive
                        if (res.KeepAliveTimeout) {
                            // Register the keep alive data as activated
                            keepAliveData.activated = true;

                            // Timeout to designate when to force the connection into reconnecting converted to milliseconds
                            keepAliveData.timeout = res.KeepAliveTimeout * 1000;

                            // Timeout to designate when to warn the developer that the connection may be dead or is not responding.
                            keepAliveData.timeoutWarning = keepAliveData.timeout * connection.keepAliveWarnAt;

                            // Instantiate the frequency in which we check the keep alive.  It must be short in order to not miss/pick up any changes
                            connection._.beatInterval = (keepAliveData.timeout - keepAliveData.timeoutWarning) / 3;
                        } else {
                            keepAliveData.activated = false;
                        }

                        connection.reconnectWindow = connection.disconnectTimeout + (keepAliveData.timeout || 0);

                        if (!res.ProtocolVersion || res.ProtocolVersion !== connection.clientProtocol) {
                            protocolError = signalR._.error(signalR._.format(resources.protocolIncompatible, connection.clientProtocol, res.ProtocolVersion));
                            $(connection).triggerHandler(events.onError, [protocolError]);
                            deferred.reject(protocolError);

                            return;
                        }

                        $.each(signalR.transports, function (key) {
                            if ((key.indexOf("_") === 0) || (key === "webSockets" && !res.TryWebSockets)) {
                                return true;
                            }
                            supportedTransports.push(key);
                        });

                        if ($.isArray(config.transport)) {
                            $.each(config.transport, function (_, transport) {
                                if ($.inArray(transport, supportedTransports) >= 0) {
                                    transports.push(transport);
                                }
                            });
                        } else if (config.transport === "auto") {
                            transports = supportedTransports;
                        } else if ($.inArray(config.transport, supportedTransports) >= 0) {
                            transports.push(config.transport);
                        }

                        initialize(transports);
                    }
                }
                ));

            return deferred.promise();
        },

        starting: function (callback) {
            /// <summary>Adds a callback that will be invoked before anything is sent over the connection</summary>
            /// <param name="callback" type="Function">A callback function to execute before the connection is fully instantiated.</param>
            /// <returns type="signalR" />
            var connection = this;
            $(connection).bind(events.onStarting, function (e, data) {
                callback.call(connection);
            });
            return connection;
        },

        send: function (data) {
            /// <summary>Sends data over the connection</summary>
            /// <param name="data" type="String">The data to send over the connection</param>
            /// <returns type="signalR" />
            var connection = this;

            if (connection.state === signalR.connectionState.disconnected) {
                // Connection hasn't been started yet
                throw new Error("SignalR: Connection must be started before data can be sent. Call .start() before .send()");
            }

            if (connection.state === signalR.connectionState.connecting) {
                // Connection hasn't been started yet
                throw new Error("SignalR: Connection has not been fully initialized. Use .start().done() or .start().fail() to run logic after the connection has started.");
            }

            connection.transport.send(connection, data);
            // REVIEW: Should we return deferred here?
            return connection;
        },

        received: function (callback) {
            /// <summary>Adds a callback that will be invoked after anything is received over the connection</summary>
            /// <param name="callback" type="Function">A callback function to execute when any data is received on the connection</param>
            /// <returns type="signalR" />
            var connection = this;
            $(connection).bind(events.onReceived, function (e, data) {
                callback.call(connection, data);
            });
            return connection;
        },

        stateChanged: function (callback) {
            /// <summary>Adds a callback that will be invoked when the connection state changes</summary>
            /// <param name="callback" type="Function">A callback function to execute when the connection state changes</param>
            /// <returns type="signalR" />
            var connection = this;
            $(connection).bind(events.onStateChanged, function (e, data) {
                callback.call(connection, data);
            });
            return connection;
        },

        error: function (callback) {
            /// <summary>Adds a callback that will be invoked after an error occurs with the connection</summary>
            /// <param name="callback" type="Function">A callback function to execute when an error occurs on the connection</param>
            /// <returns type="signalR" />
            var connection = this;
            $(connection).bind(events.onError, function (e, errorData, sendData) {
                // In practice 'errorData' is the SignalR built error object.
                // In practice 'sendData' is undefined for all error events except those triggered by
                // 'ajaxSend' and 'webSockets.send'.'sendData' is the original send payload.
                callback.call(connection, errorData, sendData);
            });
            return connection;
        },

        disconnected: function (callback) {
            /// <summary>Adds a callback that will be invoked when the client disconnects</summary>
            /// <param name="callback" type="Function">A callback function to execute when the connection is broken</param>
            /// <returns type="signalR" />
            var connection = this;
            $(connection).bind(events.onDisconnect, function (e, data) {
                callback.call(connection);
            });
            return connection;
        },

        connectionSlow: function (callback) {
            /// <summary>Adds a callback that will be invoked when the client detects a slow connection</summary>
            /// <param name="callback" type="Function">A callback function to execute when the connection is slow</param>
            /// <returns type="signalR" />
            var connection = this;
            $(connection).bind(events.onConnectionSlow, function (e, data) {
                callback.call(connection);
            });

            return connection;
        },

        reconnecting: function (callback) {
            /// <summary>Adds a callback that will be invoked when the underlying transport begins reconnecting</summary>
            /// <param name="callback" type="Function">A callback function to execute when the connection enters a reconnecting state</param>
            /// <returns type="signalR" />
            var connection = this;
            $(connection).bind(events.onReconnecting, function (e, data) {
                callback.call(connection);
            });
            return connection;
        },

        reconnected: function (callback) {
            /// <summary>Adds a callback that will be invoked when the underlying transport reconnects</summary>
            /// <param name="callback" type="Function">A callback function to execute when the connection is restored</param>
            /// <returns type="signalR" />
            var connection = this;
            $(connection).bind(events.onReconnect, function (e, data) {
                callback.call(connection);
            });
            return connection;
        },

        stop: function (async, notifyServer) {
            /// <summary>Stops listening</summary>
            /// <param name="async" type="Boolean">Whether or not to asynchronously abort the connection</param>
            /// <param name="notifyServer" type="Boolean">Whether we want to notify the server that we are aborting the connection</param>
            /// <returns type="signalR" />
            var connection = this,
                // Save deferral because this is always cleaned up
                deferral = connection._deferral;

            // Verify that we've bound a load event.
            if (connection._.deferredStartHandler) {
                // Unbind the event.
                _pageWindow.unbind("load", connection._.deferredStartHandler);
            }

            // Always clean up private non-timeout based state.
            delete connection._deferral;
            delete connection._.config;
            delete connection._.deferredStartHandler;

            // This needs to be checked despite the connection state because a connection start can be deferred until page load.
            // If we've deferred the start due to a page load we need to unbind the "onLoad" -> start event.
            if (!_pageLoaded && (!connection._.config || connection._.config.waitForPageLoad === true)) {
                connection.log("Stopping connection prior to negotiate.");

                // If we have a deferral we should reject it
                if (deferral) {
                    deferral.reject(signalR._.error(resources.stoppedWhileLoading));
                }

                // Short-circuit because the start has not been fully started.
                return;
            }

            if (connection.state === signalR.connectionState.disconnected) {
                return;
            }

            connection.log("Stopping connection.");

            changeState(connection, connection.state, signalR.connectionState.disconnected);

            // Clear this no matter what
            window.clearTimeout(connection._.beatHandle);
            window.clearTimeout(connection._.onFailedTimeoutHandle);
            window.clearInterval(connection._.pingIntervalId);

            if (connection.transport) {
                connection.transport.stop(connection);

                if (notifyServer !== false) {
                    connection.transport.abort(connection, async);
                }

                if (connection.transport.supportsKeepAlive && connection._.keepAliveData.activated) {
                    signalR.transports._logic.stopMonitoringKeepAlive(connection);
                }

                connection.transport = null;
            }

            if (connection._.negotiateRequest) {
                // If the negotiation request has already completed this will noop.
                connection._.negotiateRequest.abort(_negotiateAbortText);
                delete connection._.negotiateRequest;
            }

            // Trigger the disconnect event
            $(connection).triggerHandler(events.onDisconnect);

            delete connection.messageId;
            delete connection.groupsToken;
            delete connection.id;
            delete connection._.pingIntervalId;
            delete connection._.lastMessageAt;
            delete connection._.lastActiveAt;

            // Clear out our message buffer
            connection._.connectingMessageBuffer.clear();

            return connection;
        },

        log: function (msg) {
            log(msg, this.logging);
        }
    };

    signalR.fn.init.prototype = signalR.fn;

    signalR.noConflict = function () {
        /// <summary>Reinstates the original value of $.connection and returns the signalR object for manual assignment</summary>
        /// <returns type="signalR" />
        if ($.connection === signalR) {
            $.connection = _connection;
        }
        return signalR;
    };

    if ($.connection) {
        _connection = $.connection;
    }

    $.connection = $.signalR = signalR;

}(window.jQuery, window));
/* jquery.signalR.transports.common.js */
// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information.

/*global window:false */
/// <reference path="jquery.signalR.core.js" />

(function ($, window, undefined) {
    "use strict";

    var signalR = $.signalR,
        events = $.signalR.events,
        changeState = $.signalR.changeState,
        transportLogic;

    signalR.transports = {};

    function beat(connection) {
        if (connection._.keepAliveData.monitoring) {
            checkIfAlive(connection);
        }

        // Ensure that we successfully marked active before continuing the heartbeat.
        if (transportLogic.markActive(connection)) {
            connection._.beatHandle = window.setTimeout(function () {
                beat(connection);
            }, connection._.beatInterval);
        }
    }

    function checkIfAlive(connection) {
        var keepAliveData = connection._.keepAliveData,
            timeElapsed;

        // Only check if we're connected
        if (connection.state === signalR.connectionState.connected) {
            timeElapsed = new Date().getTime() - connection._.lastMessageAt;

            // Check if the keep alive has completely timed out
            if (timeElapsed >= keepAliveData.timeout) {
                connection.log("Keep alive timed out.  Notifying transport that connection has been lost.");

                // Notify transport that the connection has been lost
                connection.transport.lostConnection(connection);
            } else if (timeElapsed >= keepAliveData.timeoutWarning) {
                // This is to assure that the user only gets a single warning
                if (!keepAliveData.userNotified) {
                    connection.log("Keep alive has been missed, connection may be dead/slow.");
                    $(connection).triggerHandler(events.onConnectionSlow);
                    keepAliveData.userNotified = true;
                }
            } else {
                keepAliveData.userNotified = false;
            }
        }
    }

    function addConnectionData(url, connectionData) {
        var appender = url.indexOf("?") !== -1 ? "&" : "?";

        if (connectionData) {
            url += appender + "connectionData=" + window.encodeURIComponent(connectionData);
        }

        return url;
    }

    transportLogic = signalR.transports._logic = {
        pingServer: function (connection) {
            /// <summary>Pings the server</summary>
            /// <param name="connection" type="signalr">Connection associated with the server ping</param>
            /// <returns type="signalR" />
            var url, deferral = $.Deferred(), xhr;

            if (connection.transport) {
                url = connection.url + "/ping";

                url = transportLogic.addQs(url, connection.qs);

                xhr = $.ajax(
                    $.extend({}, $.signalR.ajaxDefaults, {
                        xhrFields: { withCredentials: connection.withCredentials },
                        url: url,
                        type: "GET",
                        contentType: connection.contentType,
                        data: {},
                        dataType: connection.ajaxDataType,
                        success: function (result) {
                            var data;

                            try {
                                data = connection._parseResponse(result);
                            }
                            catch (error) {
                                deferral.reject(
                                    signalR._.transportError(
                                        signalR.resources.pingServerFailedParse,
                                        connection.transport,
                                        error,
                                        xhr
                                    )
                                );
                                connection.stop();
                                return;
                            }

                            if (data.Response === "pong") {
                                deferral.resolve();
                            }
                            else {
                                deferral.reject(
                                    signalR._.transportError(
                                        signalR._.format(signalR.resources.pingServerFailedInvalidResponse, result.responseText),
                                        connection.transport,
                                        null /* error */,
                                        xhr
                                    )
                                );
                            }
                        },
                        error: function (error) {
                            if (error.status === 401 || error.status === 403) {
                                deferral.reject(
                                    signalR._.transportError(
                                        signalR._.format(signalR.resources.pingServerFailedStatusCode, error.status),
                                        connection.transport,
                                        error,
                                        xhr
                                    )
                                );
                                connection.stop();
                            }
                            else {
                                deferral.reject(
                                    signalR._.transportError(
                                        signalR.resources.pingServerFailed,
                                        connection.transport,
                                        error,
                                        xhr
                                    )
                                );
                            }
                        }
                    }
                    ));

            }
            else {
                deferral.reject(
                    signalR._.transportError(
                        signalR.resources.noConnectionTransport,
                        connection.transport
                    )
                );
            }

            return deferral.promise();
        },

        prepareQueryString: function (connection, url) {
            url = transportLogic.addQs(url, connection.qs);

            return addConnectionData(url, connection.data);
        },

        addQs: function (url, qs) {
            var appender = url.indexOf("?") !== -1 ? "&" : "?",
                firstChar;

            if (!qs) {
                return url;
            }

            if (typeof (qs) === "object") {
                return url + appender + $.param(qs);
            }

            if (typeof (qs) === "string") {
                firstChar = qs.charAt(0);

                if (firstChar === "?" || firstChar === "&") {
                    appender = "";
                }

                return url + appender + qs;
            }

            throw new Error("Query string property must be either a string or object.");
        },

        getUrl: function (connection, transport, reconnecting, poll) {
            /// <summary>Gets the url for making a GET based connect request</summary>
            var baseUrl = transport === "webSockets" ? "" : connection.baseUrl,
                url = baseUrl + connection.appRelativeUrl,
                qs = "transport=" + transport + "&connectionToken=" + window.encodeURIComponent(connection.token);

            if (connection.groupsToken) {
                qs += "&groupsToken=" + window.encodeURIComponent(connection.groupsToken);
            }

            if (!reconnecting) {
                url += "/connect";
            } else {
                if (poll) {
                    // longPolling transport specific
                    url += "/poll";
                } else {
                    url += "/reconnect";
                }

                if (connection.messageId) {
                    qs += "&messageId=" + window.encodeURIComponent(connection.messageId);
                }
            }
            url += "?" + qs;
            url = transportLogic.prepareQueryString(connection, url);
            url += "&tid=" + Math.floor(Math.random() * 11);
            return url;
        },

        maximizePersistentResponse: function (minPersistentResponse) {
            return {
                MessageId: minPersistentResponse.C,
                Messages: minPersistentResponse.M,
                Initialized: typeof (minPersistentResponse.S) !== "undefined" ? true : false,
                Disconnect: typeof (minPersistentResponse.D) !== "undefined" ? true : false,
                ShouldReconnect: typeof (minPersistentResponse.T) !== "undefined" ? true : false,
                LongPollDelay: minPersistentResponse.L,
                GroupsToken: minPersistentResponse.G
            };
        },

        updateGroups: function (connection, groupsToken) {
            if (groupsToken) {
                connection.groupsToken = groupsToken;
            }
        },

        stringifySend: function (connection, message) {
            if (typeof (message) === "string" || typeof (message) === "undefined" || message === null) {
                return message;
            }
            return connection.json.stringify(message);
        },

        ajaxSend: function (connection, data) {
            var payload = transportLogic.stringifySend(connection, data),
                url = connection.url + "/send" + "?transport=" + connection.transport.name + "&connectionToken=" + window.encodeURIComponent(connection.token),
                xhr,
                onFail = function (error, connection) {
                    $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.sendFailed, connection.transport, error, xhr), data]);
                };

            url = transportLogic.prepareQueryString(connection, url);

            xhr = $.ajax(
                $.extend({}, $.signalR.ajaxDefaults, {
                    xhrFields: { withCredentials: connection.withCredentials },
                    url: url,
                    type: connection.ajaxDataType === "jsonp" ? "GET" : "POST",
                    contentType: signalR._.defaultContentType,
                    dataType: connection.ajaxDataType,
                    data: {
                        data: payload
                    },
                    success: function (result) {
                        var res;

                        if (result) {
                            try {
                                res = connection._parseResponse(result);
                            }
                            catch (error) {
                                onFail(error, connection);
                                connection.stop();
                                return;
                            }

                            transportLogic.triggerReceived(connection, res);
                        }
                    },
                    error: function (error, textStatus) {
                        if (textStatus === "abort" || textStatus === "parsererror") {
                            // The parsererror happens for sends that don't return any data, and hence
                            // don't write the jsonp callback to the response. This is harder to fix on the server
                            // so just hack around it on the client for now.
                            return;
                        }

                        onFail(error, connection);
                    }
                }
                ));

            return xhr;
        },

        ajaxAbort: function (connection, async) {
            if (typeof (connection.transport) === "undefined") {
                return;
            }

            // Async by default unless explicitly overidden
            async = typeof async === "undefined" ? true : async;

            var url = connection.url + "/abort" + "?transport=" + connection.transport.name + "&connectionToken=" + window.encodeURIComponent(connection.token);
            url = transportLogic.prepareQueryString(connection, url);

            $.ajax(
                $.extend({}, $.signalR.ajaxDefaults, {
                    xhrFields: { withCredentials: connection.withCredentials },
                    url: url,
                    async: async,
                    timeout: 1000,
                    type: "POST",
                    contentType: connection.contentType,
                    dataType: connection.ajaxDataType,
                    data: {}
                }
                ));

            connection.log("Fired ajax abort async = " + async + ".");
        },

        tryInitialize: function (persistentResponse, onInitialized) {
            if (persistentResponse.Initialized) {
                onInitialized();
            }
        },

        triggerReceived: function (connection, data) {
            if (!connection._.connectingMessageBuffer.tryBuffer(data)) {
                $(connection).triggerHandler(events.onReceived, [data]);
            }
        },

        processMessages: function (connection, minData, onInitialized) {
            var data;

            // Update the last message time stamp
            transportLogic.markLastMessage(connection);

            if (minData) {
                data = transportLogic.maximizePersistentResponse(minData);

                if (data.Disconnect) {
                    connection.log("Disconnect command received from server.");

                    // Disconnected by the server
                    connection.stop(false, false);
                    return;
                }

                transportLogic.updateGroups(connection, data.GroupsToken);

                if (data.MessageId) {
                    connection.messageId = data.MessageId;
                }

                if (data.Messages) {
                    $.each(data.Messages, function (index, message) {
                        transportLogic.triggerReceived(connection, message);
                    });

                    transportLogic.tryInitialize(data, onInitialized);
                }
            }
        },

        monitorKeepAlive: function (connection) {
            var keepAliveData = connection._.keepAliveData;

            // If we haven't initiated the keep alive timeouts then we need to
            if (!keepAliveData.monitoring) {
                keepAliveData.monitoring = true;

                transportLogic.markLastMessage(connection);

                // Save the function so we can unbind it on stop
                connection._.keepAliveData.reconnectKeepAliveUpdate = function () {
                    // Mark a new message so that keep alive doesn't time out connections
                    transportLogic.markLastMessage(connection);
                };

                // Update Keep alive on reconnect
                $(connection).bind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);

                connection.log("Now monitoring keep alive with a warning timeout of " + keepAliveData.timeoutWarning + " and a connection lost timeout of " + keepAliveData.timeout + ".");
            } else {
                connection.log("Tried to monitor keep alive but it's already being monitored.");
            }
        },

        stopMonitoringKeepAlive: function (connection) {
            var keepAliveData = connection._.keepAliveData;

            // Only attempt to stop the keep alive monitoring if its being monitored
            if (keepAliveData.monitoring) {
                // Stop monitoring
                keepAliveData.monitoring = false;

                // Remove the updateKeepAlive function from the reconnect event
                $(connection).unbind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);

                // Clear all the keep alive data
                connection._.keepAliveData = {};
                connection.log("Stopping the monitoring of the keep alive.");
            }
        },

        startHeartbeat: function (connection) {
            connection._.lastActiveAt = new Date().getTime();
            beat(connection);
        },

        markLastMessage: function (connection) {
            connection._.lastMessageAt = new Date().getTime();
        },

        markActive: function (connection) {
            if (transportLogic.verifyLastActive(connection)) {
                connection._.lastActiveAt = new Date().getTime();
                return true;
            }

            return false;
        },

        isConnectedOrReconnecting: function (connection) {
            return connection.state === signalR.connectionState.connected ||
                connection.state === signalR.connectionState.reconnecting;
        },

        ensureReconnectingState: function (connection) {
            if (changeState(connection,
                signalR.connectionState.connected,
                signalR.connectionState.reconnecting) === true) {
                $(connection).triggerHandler(events.onReconnecting);
            }
            return connection.state === signalR.connectionState.reconnecting;
        },

        clearReconnectTimeout: function (connection) {
            if (connection && connection._.reconnectTimeout) {
                window.clearTimeout(connection._.reconnectTimeout);
                delete connection._.reconnectTimeout;
            }
        },

        verifyLastActive: function (connection) {
            if (new Date().getTime() - connection._.lastActiveAt >= connection.reconnectWindow) {
                connection.log("There has not been an active server connection for an extended period of time. Stopping connection.");
                connection.stop();
                return false;
            }

            return true;
        },

        reconnect: function (connection, transportName) {
            var transport = signalR.transports[transportName];

            // We should only set a reconnectTimeout if we are currently connected
            // and a reconnectTimeout isn't already set.
            if (transportLogic.isConnectedOrReconnecting(connection) && !connection._.reconnectTimeout) {
                // Need to verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.
                if (!transportLogic.verifyLastActive(connection)) {
                    return;
                }

                connection._.reconnectTimeout = window.setTimeout(function () {
                    if (!transportLogic.verifyLastActive(connection)) {
                        return;
                    }

                    transport.stop(connection);

                    if (transportLogic.ensureReconnectingState(connection)) {
                        connection.log(transportName + " reconnecting.");
                        transport.start(connection);
                    }
                }, connection.reconnectDelay);
            }
        },

        handleParseFailure: function (connection, result, error, onFailed, context) {
            // If we're in the initialization phase trigger onFailed, otherwise stop the connection.
            if (connection.state === signalR.connectionState.connecting) {
                connection.log("Failed to parse server response while attempting to connect.");
                onFailed();
            } else {
                $(connection).triggerHandler(events.onError, [
                    signalR._.transportError(
                        signalR._.format(signalR.resources.parseFailed, result),
                        connection.transport,
                        error,
                        context)]);
                connection.stop();
            }
        },

        foreverFrame: {
            count: 0,
            connections: {}
        }
    };

}(window.jQuery, window));
/* jquery.signalR.transports.webSockets.js */
// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information.

/*global window:false */
/// <reference path="jquery.signalR.transports.common.js" />

(function ($, window, undefined) {
    "use strict";

    var signalR = $.signalR,
        events = $.signalR.events,
        changeState = $.signalR.changeState,
        transportLogic = signalR.transports._logic;

    signalR.transports.webSockets = {
        name: "webSockets",

        supportsKeepAlive: true,

        send: function (connection, data) {
            var payload = transportLogic.stringifySend(connection, data);

            try {
                connection.socket.send(payload);
            } catch (ex) {
                $(connection).triggerHandler(events.onError,
                    [signalR._.transportError(
                        signalR.resources.webSocketsInvalidState,
                        connection.transport,
                        ex,
                        connection.socket
                    ),
                        data]);
            }
        },

        start: function (connection, onSuccess, onFailed) {
            var url,
                opened = false,
                that = this,
                reconnecting = !onSuccess,
                $connection = $(connection);

            if (!window.WebSocket) {
                onFailed();
                return;
            }

            if (!connection.socket) {
                if (connection.webSocketServerUrl) {
                    url = connection.webSocketServerUrl;
                } else {
                    url = connection.wsProtocol + connection.host;
                }

                url += transportLogic.getUrl(connection, this.name, reconnecting);

                connection.log("Connecting to websocket endpoint '" + url + "'.");
                connection.socket = new window.WebSocket(url);

                connection.socket.onopen = function () {
                    opened = true;
                    connection.log("Websocket opened.");

                    transportLogic.clearReconnectTimeout(connection);

                    if (changeState(connection,
                        signalR.connectionState.reconnecting,
                        signalR.connectionState.connected) === true) {
                        $connection.triggerHandler(events.onReconnect);
                    }
                };

                connection.socket.onclose = function (event) {
                    // Only handle a socket close if the close is from the current socket.
                    // Sometimes on disconnect the server will push down an onclose event
                    // to an expired socket.

                    if (this === connection.socket) {
                        if (!opened) {
                            if (onFailed) {
                                onFailed();
                            } else if (reconnecting) {
                                that.reconnect(connection);
                            }
                            return;
                        } else if (typeof event.wasClean !== "undefined" && event.wasClean === false) {
                            // Ideally this would use the websocket.onerror handler (rather than checking wasClean in onclose) but
                            // I found in some circumstances Chrome won't call onerror. This implementation seems to work on all browsers.
                            $(connection).triggerHandler(events.onError, [signalR._.transportError(
                                signalR.resources.webSocketClosed,
                                connection.transport,
                                event)]);
                            connection.log("Unclean disconnect from websocket: " + event.reason || "[no reason given].");
                        } else {
                            connection.log("Websocket closed.");
                        }

                        that.reconnect(connection);
                    }
                };

                connection.socket.onmessage = function (event) {
                    var data;

                    try {
                        data = connection._parseResponse(event.data);
                    }
                    catch (error) {
                        transportLogic.handleParseFailure(connection, event.data, error, onFailed, event);
                        return;
                    }

                    if (data) {
                        // data.M is PersistentResponse.Messages
                        if ($.isEmptyObject(data) || data.M) {
                            transportLogic.processMessages(connection, data, onSuccess);
                        } else {
                            // For websockets we need to trigger onReceived
                            // for callbacks to outgoing hub calls.
                            transportLogic.triggerReceived(connection, data);
                        }
                    }
                };
            }
        },

        reconnect: function (connection) {
            transportLogic.reconnect(connection, this.name);
        },

        lostConnection: function (connection) {
            this.reconnect(connection);
        },

        stop: function (connection) {
            // Don't trigger a reconnect after stopping
            transportLogic.clearReconnectTimeout(connection);

            if (connection.socket) {
                connection.log("Closing the Websocket.");
                connection.socket.close();
                connection.socket = null;
            }
        },

        abort: function (connection, async) {
            transportLogic.ajaxAbort(connection, async);
        }
    };

}(window.jQuery, window));
/* jquery.signalR.transports.serverSentEvents.js */
// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information.

/*global window:false */
/// <reference path="jquery.signalR.transports.common.js" />

(function ($, window, undefined) {
    "use strict";

    var signalR = $.signalR,
        events = $.signalR.events,
        changeState = $.signalR.changeState,
        transportLogic = signalR.transports._logic;

    signalR.transports.serverSentEvents = {
        name: "serverSentEvents",

        supportsKeepAlive: true,

        timeOut: 3000,

        start: function (connection, onSuccess, onFailed) {
            var that = this,
                opened = false,
                $connection = $(connection),
                reconnecting = !onSuccess,
                url,
                reconnectTimeout;

            if (connection.eventSource) {
                connection.log("The connection already has an event source. Stopping it.");
                connection.stop();
            }

            if (!window.EventSource) {
                if (onFailed) {
                    connection.log("This browser doesn't support SSE.");
                    onFailed();
                }
                return;
            }

            url = transportLogic.getUrl(connection, this.name, reconnecting);

            try {
                connection.log("Attempting to connect to SSE endpoint '" + url + "'.");
                connection.eventSource = new window.EventSource(url, { withCredentials: connection.withCredentials });
            }
            catch (e) {
                connection.log("EventSource failed trying to connect with error " + e.Message + ".");
                if (onFailed) {
                    // The connection failed, call the failed callback
                    onFailed();
                } else {
                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceFailedToConnect, connection.transport, e)]);
                    if (reconnecting) {
                        // If we were reconnecting, rather than doing initial connect, then try reconnect again
                        that.reconnect(connection);
                    }
                }
                return;
            }

            if (reconnecting) {
                reconnectTimeout = window.setTimeout(function () {
                    if (opened === false) {
                        // If we're reconnecting and the event source is attempting to connect,
                        // don't keep retrying. This causes duplicate connections to spawn.
                        if (connection.eventSource.readyState !== window.EventSource.OPEN) {
                            // If we were reconnecting, rather than doing initial connect, then try reconnect again
                            that.reconnect(connection);
                        }
                    }
                },
                    that.timeOut);
            }

            connection.eventSource.addEventListener("open", function (e) {
                connection.log("EventSource connected.");

                if (reconnectTimeout) {
                    window.clearTimeout(reconnectTimeout);
                }

                transportLogic.clearReconnectTimeout(connection);

                if (opened === false) {
                    opened = true;

                    if (changeState(connection,
                        signalR.connectionState.reconnecting,
                        signalR.connectionState.connected) === true) {
                        $connection.triggerHandler(events.onReconnect);
                    }
                }
            }, false);

            connection.eventSource.addEventListener("message", function (e) {
                var res;

                // process messages
                if (e.data === "initialized") {
                    return;
                }

                try {
                    res = connection._parseResponse(e.data);
                }
                catch (error) {
                    transportLogic.handleParseFailure(connection, e.data, error, onFailed, e);
                    return;
                }

                transportLogic.processMessages(connection, res, onSuccess);
            }, false);

            connection.eventSource.addEventListener("error", function (e) {
                // Only handle an error if the error is from the current Event Source.
                // Sometimes on disconnect the server will push down an error event
                // to an expired Event Source.
                if (this !== connection.eventSource) {
                    return;
                }

                if (!opened) {
                    if (onFailed) {
                        onFailed();
                    }

                    return;
                }

                connection.log("EventSource readyState: " + connection.eventSource.readyState + ".");

                if (e.eventPhase === window.EventSource.CLOSED) {
                    // We don't use the EventSource's native reconnect function as it
                    // doesn't allow us to change the URL when reconnecting. We need
                    // to change the URL to not include the /connect suffix, and pass
                    // the last message id we received.
                    connection.log("EventSource reconnecting due to the server connection ending.");
                    that.reconnect(connection);
                } else {
                    // connection error
                    connection.log("EventSource error.");
                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceError, connection.transport, e)]);
                }
            }, false);
        },

        reconnect: function (connection) {
            transportLogic.reconnect(connection, this.name);
        },

        lostConnection: function (connection) {
            this.reconnect(connection);
        },

        send: function (connection, data) {
            transportLogic.ajaxSend(connection, data);
        },

        stop: function (connection) {
            // Don't trigger a reconnect after stopping
            transportLogic.clearReconnectTimeout(connection);

            if (connection && connection.eventSource) {
                connection.log("EventSource calling close().");
                connection.eventSource.close();
                connection.eventSource = null;
                delete connection.eventSource;
            }
        },

        abort: function (connection, async) {
            transportLogic.ajaxAbort(connection, async);
        }
    };

}(window.jQuery, window));
/* jquery.signalR.transports.foreverFrame.js */
// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information.

/*global window:false */
/// <reference path="jquery.signalR.transports.common.js" />

(function ($, window, undefined) {
    "use strict";

    var signalR = $.signalR,
        events = $.signalR.events,
        changeState = $.signalR.changeState,
        transportLogic = signalR.transports._logic,
        createFrame = function () {
            var frame = window.document.createElement("iframe");
            frame.setAttribute("style", "position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;");
            return frame;
        },
        // Used to prevent infinite loading icon spins in older versions of ie
        // We build this object inside a closure so we don't pollute the rest of   
        // the foreverFrame transport with unnecessary functions/utilities.
        loadPreventer = (function () {
            var loadingFixIntervalId = null,
                loadingFixInterval = 1000,
                attachedTo = 0;

            return {
                prevent: function () {
                    // Prevent additional iframe removal procedures from newer browsers
                    if (signalR._.ieVersion <= 8) {
                        // We only ever want to set the interval one time, so on the first attachedTo
                        if (attachedTo === 0) {
                            // Create and destroy iframe every 3 seconds to prevent loading icon, super hacky
                            loadingFixIntervalId = window.setInterval(function () {
                                var tempFrame = createFrame();

                                window.document.body.appendChild(tempFrame);
                                window.document.body.removeChild(tempFrame);

                                tempFrame = null;
                            }, loadingFixInterval);
                        }

                        attachedTo++;
                    }
                },
                cancel: function () {
                    // Only clear the interval if there's only one more object that the loadPreventer is attachedTo
                    if (attachedTo === 1) {
                        window.clearInterval(loadingFixIntervalId);
                    }

                    if (attachedTo > 0) {
                        attachedTo--;
                    }
                }
            };
        })();

    signalR.transports.foreverFrame = {
        name: "foreverFrame",

        supportsKeepAlive: true,

        // Added as a value here so we can create tests to verify functionality
        iframeClearThreshold: 50,

        start: function (connection, onSuccess, onFailed) {
            var that = this,
                frameId = (transportLogic.foreverFrame.count += 1),
                url,
                frame = createFrame(),
                frameLoadHandler = function () {
                    connection.log("Forever frame iframe finished loading and is no longer receiving messages.");
                    that.reconnect(connection);
                };

            if (window.EventSource) {
                // If the browser supports SSE, don't use Forever Frame
                if (onFailed) {
                    connection.log("This browser supports SSE, skipping Forever Frame.");
                    onFailed();
                }
                return;
            }

            frame.setAttribute("data-signalr-connection-id", connection.id);

            // Start preventing loading icon
            // This will only perform work if the loadPreventer is not attached to another connection.
            loadPreventer.prevent();

            // Build the url
            url = transportLogic.getUrl(connection, this.name);
            url += "&frameId=" + frameId;

            // Set body prior to setting URL to avoid caching issues.
            window.document.body.appendChild(frame);

            connection.log("Binding to iframe's load event.");

            if (frame.addEventListener) {
                frame.addEventListener("load", frameLoadHandler, false);
            } else if (frame.attachEvent) {
                frame.attachEvent("onload", frameLoadHandler);
            }

            frame.src = url;
            transportLogic.foreverFrame.connections[frameId] = connection;

            connection.frame = frame;
            connection.frameId = frameId;

            if (onSuccess) {
                connection.onSuccess = function () {
                    connection.log("Iframe transport started.");
                    onSuccess();
                };
            }
        },

        reconnect: function (connection) {
            var that = this;

            // Need to verify connection state and verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.
            if (transportLogic.isConnectedOrReconnecting(connection) && transportLogic.verifyLastActive(connection)) {
                window.setTimeout(function () {
                    // Verify that we're ok to reconnect.
                    if (!transportLogic.verifyLastActive(connection)) {
                        return;
                    }

                    if (connection.frame && transportLogic.ensureReconnectingState(connection)) {
                        var frame = connection.frame,
                            src = transportLogic.getUrl(connection, that.name, true) + "&frameId=" + connection.frameId;
                        connection.log("Updating iframe src to '" + src + "'.");
                        frame.src = src;
                    }
                }, connection.reconnectDelay);
            }
        },

        lostConnection: function (connection) {
            this.reconnect(connection);
        },

        send: function (connection, data) {
            transportLogic.ajaxSend(connection, data);
        },

        receive: function (connection, data) {
            var cw,
                body;

            transportLogic.processMessages(connection, data, connection.onSuccess);

            // Protect against connection stopping from a callback trigger within the processMessages above.
            if (connection.state === $.signalR.connectionState.connected) {
                // Delete the script & div elements
                connection.frameMessageCount = (connection.frameMessageCount || 0) + 1;
                if (connection.frameMessageCount > signalR.transports.foreverFrame.iframeClearThreshold) {
                    connection.frameMessageCount = 0;
                    cw = connection.frame.contentWindow || connection.frame.contentDocument;
                    if (cw && cw.document && cw.document.body) {
                        body = cw.document.body;

                        // Remove all the child elements from the iframe's body to conserver memory
                        while (body.firstChild) {
                            body.removeChild(body.firstChild);
                        }
                    }
                }
            }
        },

        stop: function (connection) {
            var cw = null;

            // Stop attempting to prevent loading icon
            loadPreventer.cancel();

            if (connection.frame) {
                if (connection.frame.stop) {
                    connection.frame.stop();
                } else {
                    try {
                        cw = connection.frame.contentWindow || connection.frame.contentDocument;
                        if (cw.document && cw.document.execCommand) {
                            cw.document.execCommand("Stop");
                        }
                    }
                    catch (e) {
                        connection.log("Error occured when stopping foreverFrame transport. Message = " + e.message + ".");
                    }
                }

                // Ensure the iframe is where we left it
                if (connection.frame.parentNode === window.document.body) {
                    window.document.body.removeChild(connection.frame);
                }

                delete transportLogic.foreverFrame.connections[connection.frameId];
                connection.frame = null;
                connection.frameId = null;
                delete connection.frame;
                delete connection.frameId;
                delete connection.onSuccess;
                delete connection.frameMessageCount;
                connection.log("Stopping forever frame.");
            }
        },

        abort: function (connection, async) {
            transportLogic.ajaxAbort(connection, async);
        },

        getConnection: function (id) {
            return transportLogic.foreverFrame.connections[id];
        },

        started: function (connection) {
            if (changeState(connection,
                signalR.connectionState.reconnecting,
                signalR.connectionState.connected) === true) {
                // If there's no onSuccess handler we assume this is a reconnect
                $(connection).triggerHandler(events.onReconnect);
            }
        }
    };

}(window.jQuery, window));
/* jquery.signalR.transports.longPolling.js */
// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information.

/*global window:false */
/// <reference path="jquery.signalR.transports.common.js" />

(function ($, window, undefined) {
    "use strict";

    var signalR = $.signalR,
        events = $.signalR.events,
        changeState = $.signalR.changeState,
        isDisconnecting = $.signalR.isDisconnecting,
        transportLogic = signalR.transports._logic;

    signalR.transports.longPolling = {
        name: "longPolling",

        supportsKeepAlive: false,

        reconnectDelay: 3000,

        start: function (connection, onSuccess, onFailed) {
            /// <summary>Starts the long polling connection</summary>
            /// <param name="connection" type="signalR">The SignalR connection to start</param>
            var that = this,
                fireConnect = function () {
                    fireConnect = $.noop;

                    connection.log("LongPolling connected.");
                    onSuccess();
                    // Reset onFailed to null because it shouldn't be called again
                    onFailed = null;
                },
                tryFailConnect = function () {
                    if (onFailed) {
                        onFailed();
                        onFailed = null;
                        connection.log("LongPolling failed to connect.");
                        return true;
                    }

                    return false;
                },
                privateData = connection._,
                reconnectErrors = 0,
                fireReconnected = function (instance) {
                    window.clearTimeout(privateData.reconnectTimeoutId);
                    privateData.reconnectTimeoutId = null;

                    if (changeState(instance,
                        signalR.connectionState.reconnecting,
                        signalR.connectionState.connected) === true) {
                        // Successfully reconnected!
                        instance.log("Raising the reconnect event");
                        $(instance).triggerHandler(events.onReconnect);
                    }
                },
                // 1 hour
                maxFireReconnectedTimeout = 3600000;

            if (connection.pollXhr) {
                connection.log("Polling xhr requests already exists, aborting.");
                connection.stop();
            }

            connection.messageId = null;

            privateData.reconnectTimeoutId = null;

            privateData.pollTimeoutId = window.setTimeout(function () {
                (function poll(instance, raiseReconnect) {
                    var messageId = instance.messageId,
                        connect = (messageId === null),
                        reconnecting = !connect,
                        polling = !raiseReconnect,
                        url = transportLogic.getUrl(instance, that.name, reconnecting, polling);

                    // If we've disconnected during the time we've tried to re-instantiate the poll then stop.
                    if (isDisconnecting(instance) === true) {
                        return;
                    }

                    connection.log("Opening long polling request to '" + url + "'.");
                    instance.pollXhr = $.ajax(
                        $.extend({}, $.signalR.ajaxDefaults, {
                            xhrFields: { withCredentials: connection.withCredentials },
                            url: url,
                            type: "GET",
                            dataType: connection.ajaxDataType,
                            contentType: connection.contentType,
                            success: function (result) {
                                var minData,
                                    delay = 0,
                                    data,
                                    shouldReconnect;

                                connection.log("Long poll complete.");

                                // Reset our reconnect errors so if we transition into a reconnecting state again we trigger
                                // reconnected quickly
                                reconnectErrors = 0;

                                try {
                                    minData = connection._parseResponse(result);
                                }
                                catch (error) {
                                    transportLogic.handleParseFailure(instance, result, error, tryFailConnect, instance.pollXhr);
                                    return;
                                }

                                // If there's currently a timeout to trigger reconnect, fire it now before processing messages
                                if (privateData.reconnectTimeoutId !== null) {
                                    fireReconnected(instance);
                                }

                                if (minData) {
                                    data = transportLogic.maximizePersistentResponse(minData);
                                }

                                transportLogic.processMessages(instance, minData, fireConnect);

                                if (data &&
                                    $.type(data.LongPollDelay) === "number") {
                                    delay = data.LongPollDelay;
                                }

                                if (data && data.Disconnect) {
                                    return;
                                }

                                if (isDisconnecting(instance) === true) {
                                    return;
                                }

                                shouldReconnect = data && data.ShouldReconnect;
                                if (shouldReconnect) {
                                    // Transition into the reconnecting state
                                    // If this fails then that means that the user transitioned the connection into a invalid state in processMessages.
                                    if (!transportLogic.ensureReconnectingState(instance)) {
                                        return;
                                    }
                                }

                                // We never want to pass a raiseReconnect flag after a successful poll.  This is handled via the error function
                                if (delay > 0) {
                                    privateData.pollTimeoutId = window.setTimeout(function () {
                                        poll(instance, shouldReconnect);
                                    }, delay);
                                } else {
                                    poll(instance, shouldReconnect);
                                }
                            },

                            error: function (data, textStatus) {
                                // Stop trying to trigger reconnect, connection is in an error state
                                // If we're not in the reconnect state this will noop
                                window.clearTimeout(privateData.reconnectTimeoutId);
                                privateData.reconnectTimeoutId = null;

                                if (textStatus === "abort") {
                                    connection.log("Aborted xhr request.");
                                    return;
                                }

                                if (!tryFailConnect()) {

                                    // Increment our reconnect errors, we assume all errors to be reconnect errors
                                    // In the case that it's our first error this will cause Reconnect to be fired
                                    // after 1 second due to reconnectErrors being = 1.
                                    reconnectErrors++;

                                    if (connection.state !== signalR.connectionState.reconnecting) {
                                        connection.log("An error occurred using longPolling. Status = " + textStatus + ".  Response = " + data.responseText + ".");
                                        $(instance).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.longPollFailed, connection.transport, data, instance.pollXhr)]);
                                    }

                                    // We check the state here to verify that we're not in an invalid state prior to verifying Reconnect.
                                    // If we're not in connected or reconnecting then the next ensureReconnectingState check will fail and will return.
                                    // Therefore we don't want to change that failure code path.
                                    if ((connection.state === signalR.connectionState.connected ||
                                        connection.state === signalR.connectionState.reconnecting) &&
                                        !transportLogic.verifyLastActive(connection)) {
                                        return;
                                    }

                                    // Transition into the reconnecting state
                                    // If this fails then that means that the user transitioned the connection into the disconnected or connecting state within the above error handler trigger.
                                    if (!transportLogic.ensureReconnectingState(instance)) {
                                        return;
                                    }

                                    // Call poll with the raiseReconnect flag as true after the reconnect delay
                                    privateData.pollTimeoutId = window.setTimeout(function () {
                                        poll(instance, true);
                                    }, that.reconnectDelay);
                                }
                            }
                        }
                        ));


                    // This will only ever pass after an error has occured via the poll ajax procedure.
                    if (reconnecting && raiseReconnect === true) {
                        // We wait to reconnect depending on how many times we've failed to reconnect.
                        // This is essentially a heuristic that will exponentially increase in wait time before
                        // triggering reconnected.  This depends on the "error" handler of Poll to cancel this 
                        // timeout if it triggers before the Reconnected event fires.
                        // The Math.min at the end is to ensure that the reconnect timeout does not overflow.
                        privateData.reconnectTimeoutId = window.setTimeout(function () { fireReconnected(instance); }, Math.min(1000 * (Math.pow(2, reconnectErrors) - 1), maxFireReconnectedTimeout));
                    }
                }(connection));
            }, 250); // Have to delay initial poll so Chrome doesn't show loader spinner in tab
        },

        lostConnection: function (connection) {
            throw new Error("Lost Connection not handled for LongPolling");
        },

        send: function (connection, data) {
            transportLogic.ajaxSend(connection, data);
        },

        stop: function (connection) {
            /// <summary>Stops the long polling connection</summary>
            /// <param name="connection" type="signalR">The SignalR connection to stop</param>

            window.clearTimeout(connection._.pollTimeoutId);
            window.clearTimeout(connection._.reconnectTimeoutId);

            delete connection._.pollTimeoutId;
            delete connection._.reconnectTimeoutId;

            if (connection.pollXhr) {
                connection.pollXhr.abort();
                connection.pollXhr = null;
                delete connection.pollXhr;
            }
        },

        abort: function (connection, async) {
            transportLogic.ajaxAbort(connection, async);
        }
    };

}(window.jQuery, window));
/* jquery.signalR.hubs.js */
// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information.

/*global window:false */
/// <reference path="jquery.signalR.core.js" />

(function ($, window, undefined) {
    "use strict";

    var eventNamespace = ".hubProxy",
        signalR = $.signalR;

    function makeEventName(event) {
        return event + eventNamespace;
    }

    // Equivalent to Array.prototype.map
    function map(arr, fun, thisp) {
        var i,
            length = arr.length,
            result = [];
        for (i = 0; i < length; i += 1) {
            if (arr.hasOwnProperty(i)) {
                result[i] = fun.call(thisp, arr[i], i, arr);
            }
        }
        return result;
    }

    function getArgValue(a) {
        return $.isFunction(a) ? null : ($.type(a) === "undefined" ? null : a);
    }

    function hasMembers(obj) {
        for (var key in obj) {
            // If we have any properties in our callback map then we have callbacks and can exit the loop via return
            if (obj.hasOwnProperty(key)) {
                return true;
            }
        }

        return false;
    }

    function clearInvocationCallbacks(connection, error) {
        /// <param name="connection" type="hubConnection" />
        var callbacks = connection._.invocationCallbacks,
            callback;

        if (hasMembers(callbacks)) {
            connection.log("Clearing hub invocation callbacks with error: " + error + ".");
        }

        // Reset the callback cache now as we have a local var referencing it
        connection._.invocationCallbackId = 0;
        delete connection._.invocationCallbacks;
        connection._.invocationCallbacks = {};

        // Loop over the callbacks and invoke them.
        // We do this using a local var reference and *after* we've cleared the cache
        // so that if a fail callback itself tries to invoke another method we don't 
        // end up with its callback in the list we're looping over.
        for (var callbackId in callbacks) {
            callback = callbacks[callbackId];
            callback.method.call(callback.scope, { E: error });
        }
    }

    // hubProxy
    function hubProxy(hubConnection, hubName) {
        /// <summary>
        ///     Creates a new proxy object for the given hub connection that can be used to invoke
        ///     methods on server hubs and handle client method invocation requests from the server.
        /// </summary>
        return new hubProxy.fn.init(hubConnection, hubName);
    }

    hubProxy.fn = hubProxy.prototype = {
        init: function (connection, hubName) {
            this.state = {};
            this.connection = connection;
            this.hubName = hubName;
            this._ = {
                callbackMap: {}
            };
        },

        hasSubscriptions: function () {
            return hasMembers(this._.callbackMap);
        },

        on: function (eventName, callback) {
            /// <summary>Wires up a callback to be invoked when a invocation request is received from the server hub.</summary>
            /// <param name="eventName" type="String">The name of the hub event to register the callback for.</param>
            /// <param name="callback" type="Function">The callback to be invoked.</param>
            var that = this,
                callbackMap = that._.callbackMap;

            // Normalize the event name to lowercase
            eventName = eventName.toLowerCase();

            // If there is not an event registered for this callback yet we want to create its event space in the callback map.
            if (!callbackMap[eventName]) {
                callbackMap[eventName] = {};
            }

            // Map the callback to our encompassed function
            callbackMap[eventName][callback] = function (e, data) {
                callback.apply(that, data);
            };

            $(that).bind(makeEventName(eventName), callbackMap[eventName][callback]);

            return that;
        },

        off: function (eventName, callback) {
            /// <summary>Removes the callback invocation request from the server hub for the given event name.</summary>
            /// <param name="eventName" type="String">The name of the hub event to unregister the callback for.</param>
            /// <param name="callback" type="Function">The callback to be invoked.</param>
            var that = this,
                callbackMap = that._.callbackMap,
                callbackSpace;

            // Normalize the event name to lowercase
            eventName = eventName.toLowerCase();

            callbackSpace = callbackMap[eventName];

            // Verify that there is an event space to unbind
            if (callbackSpace) {
                // Only unbind if there's an event bound with eventName and a callback with the specified callback
                if (callbackSpace[callback]) {
                    $(that).unbind(makeEventName(eventName), callbackSpace[callback]);

                    // Remove the callback from the callback map
                    delete callbackSpace[callback];

                    // Check if there are any members left on the event, if not we need to destroy it.
                    if (!hasMembers(callbackSpace)) {
                        delete callbackMap[eventName];
                    }
                } else if (!callback) { // Check if we're removing the whole event and we didn't error because of an invalid callback
                    $(that).unbind(makeEventName(eventName));

                    delete callbackMap[eventName];
                }
            }

            return that;
        },

        invoke: function (methodName) {
            /// <summary>Invokes a server hub method with the given arguments.</summary>
            /// <param name="methodName" type="String">The name of the server hub method.</param>

            var that = this,
                connection = that.connection,
                args = $.makeArray(arguments).slice(1),
                argValues = map(args, getArgValue),
                data = { H: that.hubName, M: methodName, A: argValues, I: connection._.invocationCallbackId },
                d = $.Deferred(),
                callback = function (minResult) {
                    var result = that._maximizeHubResponse(minResult),
                        source,
                        error;

                    // Update the hub state
                    $.extend(that.state, result.State);

                    if (result.Error) {
                        // Server hub method threw an exception, log it & reject the deferred
                        if (result.StackTrace) {
                            connection.log(result.Error + "\n" + result.StackTrace + ".");
                        }

                        // result.ErrorData is only set if a HubException was thrown
                        source = result.IsHubException ? "HubException" : "Exception";
                        error = signalR._.error(result.Error, source);
                        error.data = result.ErrorData;

                        connection.log(that.hubName + "." + methodName + " failed to execute. Error: " + error.message);
                        d.rejectWith(that, [error]);
                    } else {
                        // Server invocation succeeded, resolve the deferred
                        connection.log("Invoked " + that.hubName + "." + methodName);
                        d.resolveWith(that, [result.Result]);
                    }
                };

            connection._.invocationCallbacks[connection._.invocationCallbackId.toString()] = { scope: that, method: callback };
            connection._.invocationCallbackId += 1;

            if (!$.isEmptyObject(that.state)) {
                data.S = that.state;
            }

            connection.log("Invoking " + that.hubName + "." + methodName);
            connection.send(data);

            return d.promise();
        },

        _maximizeHubResponse: function (minHubResponse) {
            return {
                State: minHubResponse.S,
                Result: minHubResponse.R,
                Id: minHubResponse.I,
                IsHubException: minHubResponse.H,
                Error: minHubResponse.E,
                StackTrace: minHubResponse.T,
                ErrorData: minHubResponse.D
            };
        }
    };

    hubProxy.fn.init.prototype = hubProxy.fn;

    // hubConnection
    function hubConnection(url, options) {
        /// <summary>Creates a new hub connection.</summary>
        /// <param name="url" type="String">[Optional] The hub route url, defaults to "/signalr".</param>
        /// <param name="options" type="Object">[Optional] Settings to use when creating the hubConnection.</param>
        var settings = {
            qs: null,
            logging: false,
            useDefaultPath: true
        };

        $.extend(settings, options);

        if (!url || settings.useDefaultPath) {
            url = (url || "") + "/signalr";
        }
        return new hubConnection.fn.init(url, settings);
    }

    hubConnection.fn = hubConnection.prototype = $.connection();

    hubConnection.fn.init = function (url, options) {
        var settings = {
            qs: null,
            logging: false,
            useDefaultPath: true
        },
            connection = this;

        $.extend(settings, options);

        // Call the base constructor
        $.signalR.fn.init.call(connection, url, settings.qs, settings.logging);

        // Object to store hub proxies for this connection
        connection.proxies = {};

        connection._.invocationCallbackId = 0;
        connection._.invocationCallbacks = {};

        // Wire up the received handler
        connection.received(function (minData) {
            var data, proxy, dataCallbackId, callback, hubName, eventName;
            if (!minData) {
                return;
            }

            if (typeof (minData.I) !== "undefined") {
                // We received the return value from a server method invocation, look up callback by id and call it
                dataCallbackId = minData.I.toString();
                callback = connection._.invocationCallbacks[dataCallbackId];
                if (callback) {
                    // Delete the callback from the proxy
                    connection._.invocationCallbacks[dataCallbackId] = null;
                    delete connection._.invocationCallbacks[dataCallbackId];

                    // Invoke the callback
                    callback.method.call(callback.scope, minData);
                }
            } else {
                data = this._maximizeClientHubInvocation(minData);

                // We received a client invocation request, i.e. broadcast from server hub
                connection.log("Triggering client hub event '" + data.Method + "' on hub '" + data.Hub + "'.");

                // Normalize the names to lowercase
                hubName = data.Hub.toLowerCase();
                eventName = data.Method.toLowerCase();

                // Trigger the local invocation event
                proxy = this.proxies[hubName];

                // Update the hub state
                $.extend(proxy.state, data.State);
                $(proxy).triggerHandler(makeEventName(eventName), [data.Args]);
            }
        });

        connection.error(function (errData, origData) {
            var callbackId, callback;

            if (!origData) {
                // No original data passed so this is not a send error
                return;
            }

            callbackId = origData.I;
            callback = connection._.invocationCallbacks[callbackId];

            // Verify that there is a callback bound (could have been cleared)
            if (callback) {
                // Delete the callback
                connection._.invocationCallbacks[callbackId] = null;
                delete connection._.invocationCallbacks[callbackId];

                // Invoke the callback with an error to reject the promise
                callback.method.call(callback.scope, { E: errData });
            }
        });

        connection.reconnecting(function () {
            if (connection.transport && connection.transport.name === "webSockets") {
                clearInvocationCallbacks(connection, "Connection started reconnecting before invocation result was received.");
            }
        });

        connection.disconnected(function () {
            clearInvocationCallbacks(connection, "Connection was disconnected before invocation result was received.");
        });
    };

    hubConnection.fn._maximizeClientHubInvocation = function (minClientHubInvocation) {
        return {
            Hub: minClientHubInvocation.H,
            Method: minClientHubInvocation.M,
            Args: minClientHubInvocation.A,
            State: minClientHubInvocation.S
        };
    };

    hubConnection.fn._registerSubscribedHubs = function () {
        /// <summary>
        ///     Sets the starting event to loop through the known hubs and register any new hubs 
        ///     that have been added to the proxy.
        /// </summary>
        var connection = this;

        if (!connection._subscribedToHubs) {
            connection._subscribedToHubs = true;
            connection.starting(function () {
                // Set the connection's data object with all the hub proxies with active subscriptions.
                // These proxies will receive notifications from the server.
                var subscribedHubs = [];

                $.each(connection.proxies, function (key) {
                    if (this.hasSubscriptions()) {
                        subscribedHubs.push({ name: key });
                        connection.log("Client subscribed to hub '" + key + "'.");
                    }
                });

                if (subscribedHubs.length === 0) {
                    connection.log("No hubs have been subscribed to.  The client will not receive data from hubs.  To fix, declare at least one client side function prior to connection start for each hub you wish to subscribe to.");
                }

                connection.data = connection.json.stringify(subscribedHubs);
            });
        }
    };

    hubConnection.fn.createHubProxy = function (hubName) {
        /// <summary>
        ///     Creates a new proxy object for the given hub connection that can be used to invoke
        ///     methods on server hubs and handle client method invocation requests from the server.
        /// </summary>
        /// <param name="hubName" type="String">
        ///     The name of the hub on the server to create the proxy for.
        /// </param>

        // Normalize the name to lowercase
        hubName = hubName.toLowerCase();

        var proxy = this.proxies[hubName];
        if (!proxy) {
            proxy = hubProxy(this, hubName);
            this.proxies[hubName] = proxy;
        }

        this._registerSubscribedHubs();

        return proxy;
    };

    hubConnection.fn.init.prototype = hubConnection.fn;

    $.hubConnection = hubConnection;

}(window.jQuery, window));
/* jquery.signalR.version.js */
// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.md in the project root for license information.

/*global window:false */
/// <reference path="jquery.signalR.core.js" />
(function ($, undefined) {
    $.signalR.version = "2.0.3";
}(window.jQuery));

var replaceInnerText = '![Upload](Uploading...)';
var replaceText = '\r\n' + replaceInnerText + '\r\n';

function uploadAttachment() {
    $('#uploadFile').unbind('change').change(function () {
        uploadFile();
    });
    $('#uploadFile').click();
}

function uploadFile() {
    var formData = new FormData($('#frmAjaxUpload')[0]);
    var editor = $('.markdown-editor');
    var smde = editor[0].smde;

    var begin_pos, end_pos;

    begin_pos = smde.codemirror.getCursor();
    smde.codemirror.setSelection(begin_pos, begin_pos);
    smde.codemirror.replaceSelection(replaceText);
    begin_pos.line++;
    end_pos = { line: begin_pos.line, ch: begin_pos.ch + replaceInnerText.length };

    $.ajax({
        url: '/file/upload',
        type: 'POST',
        data: formData,
        dataType: 'json',
        async: false,
        cache: false,
        contentType: false,
        processData: false,
        success: function (result) {
            smde.codemirror.setSelection(begin_pos, end_pos);
            smde.codemirror.replaceSelection('![' + result.FileName + '](/file/download/' + result.Id + ')');
        },
        error: function (returndata) {
        }
    });
}

function DropEnable() {
    $('.markdown-editor').unbind().each(function () {
        var editor = $(this);
        if (editor[0].smde == undefined) {
            var smde = new SimpleMDE({
                element: editor[0],
                spellChecker: false,
                status: false
            });
            editor[0].smde = smde;
            var begin_pos, end_pos;
            $(this).parent().children(".CodeMirror").unbind().dragDropOrPaste(function () {
                begin_pos = smde.codemirror.getCursor();
                smde.codemirror.setSelection(begin_pos, begin_pos);
                smde.codemirror.replaceSelection(replaceText);
                begin_pos.line++;
                end_pos = { line: begin_pos.line, ch: begin_pos.ch + replaceInnerText.length };
            },
                function (result) {
                    smde.codemirror.setSelection(begin_pos, end_pos);
                    smde.codemirror.replaceSelection('![' + result.FileName + '](/file/download/' + result.Id + ')');
                });
        }
    });
}

$(document).ready(function () {
    DropEnable();
});

/*====================================================
  TABLE OF CONTENT
  1. function declearetion
  2. Initialization
====================================================*/

/*===========================
 1. function declearetion
 ==========================*/
var themeApp = {
    darkScheme: function () {
        if (typeof dark_color_scheme !== 'undefined' && dark_color_scheme == true) {
            $('body').addClass('dark-bg');
        }
    },
    featuredMedia: function () {
        $(".post-wrap").each(function () {
            var thiseliment = $(this);
            var container = $(this).find('.card-header');
            var media_wrapper = $(this).find('featured');
            var media_content_embeded = media_wrapper.find('iframe');
            if (media_content_embeded.length > 0) {
                $(container).html($(media_content_embeded)).wrapInner("<div class='featured-image-countainer'></div>");
                thiseliment.addClass('embeded-media');
            }
        });
    },
    responsiveIframe: function () {
        $('.card').fitVids();
    },
    navScroll: function () {
        $(window).scroll(function () {
            if ($(this).scrollTop() > 0) {
                $('.navbar-fixed-top').addClass('page-scrolled');
            } else {
                $('.navbar-fixed-top').removeClass('page-scrolled');
            }
        });
    },
    navStyle: function () {
        if (typeof fixed_navbar !== 'undefined' && fixed_navbar == false) {
            $('body').removeClass('fixed-navbar');
            $('.navbar-default').removeClass('navbar-fixed-top');
        }
    },
    shareToggle: function () {
        $('.share-button').on('click', function () {
            $(this).siblings('.share-link-wrap').toggleClass('opened');
        })
    },
    gatherData: function (page, prevPagePostID, data) {
        var page = page || 1;
        var prevPagePostID = prevPagePostID || '';
        var data = data || [];
        var parent = this;
        var status = '';

        var FEED_URL = '/rss/' + page + '/';

        $.ajax({
            url: FEED_URL,
            type: 'get',
            success: function (parsedData) {
                var currPagePostID = $(parsedData).find('item > guid').text();
                if (prevPagePostID != currPagePostID) {
                    $(parsedData).find('item').each(function () {
                        data.push(this);
                    });
                    parent.gatherData(page + 1, currPagePostID, data);
                } else {
                    parent.tagcloud(data);
                    parent.recentPosts(data);
                }
            }
        });
    },
    tagcloud: function (data) {
        var primary_array = [];
        $(data).find("category").each(function () {
            var el = $(this).text();
            if ($.inArray(el, primary_array) == -1) {
                primary_array.push(el);
            }
        });
        var formated_tag_list = "";
        for (var i = 0; i < primary_array.length; i = i + 1) {
            var tag = primary_array[i];
            var tagLink = tag.toLowerCase().replace(/ /g, '-');
            formated_tag_list += ("<a href=\"/tag/" + tagLink + "\">" + tag + "</a>");
        }
        $('.tag-cloud').append(formated_tag_list);
    },
    recentPosts: function (data) {
        var container = $(".recent-post");
        if (container.length && typeof recent_post_count !== 'undefined') {
            var string = '';
            $(data).slice(0, recent_post_count).each(function () {
                var link = $(this).find('link').text();
                var title = $(this).find('title').text();
                var published_date = themeApp.formatDate($(this).find('pubDate').text());
                var image_link = $(this).find('media\\:content, content').attr('url');
                if (typeof image_link !== 'undefined') {
                    var image = '<div class="post-thumb pull-left" style="background-image:url(' + image_link + ')"></div>';
                    var helper_class = 'have-image';
                } else {
                    var image = '<div class="post-thumb pull-left"><i class="fa fa-image"></i></div>';
                    var helper_class = '';
                }
                string += '<div class="recent-single-post clearfix ' + helper_class + '"><a href="' + link + '" class="post-title">\
				'+ image + '\
				<div class="post-info"><h4 class="h5">' + title + '</h4><div class="date"><i class="material-icons">&#xE192;</i>' + published_date + '</div></div>\
				</a></div>'
            });
            container.append(string);
        }
    },
    formatDate: function (dt) {
        var d = new Date(dt);
        var month_name = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        var month = month_name[d.getMonth()];
        var date = d.getDate();
        var year = d.getFullYear();
        var formatted_dt = month + ' ' + date + ',' + ' ' + year;
        return formatted_dt;
    },
    matrerialInput: function () {
        $('input').blur(function () {
            if ($.trim(this.value).length > 0) {
                $(this).addClass('non-empty');
            } else {
                $(this).removeClass('non-empty');
            }
        });
    },
    mailchimp: function () {
        function IsEmail(email) {
            var regex = /^([a-zA-Z0-9_.+-])+\@(([a-zA-Z0-9-])+\.)+([a-zA-Z0-9]{2,4})+$/;
            return regex.test(email);
        }
    },
    highlighter: function () {
        $('pre code').each(function (i, block) {
            hljs.highlightBlock(block);
        });
    },
    searchPopup: function () {
        $('.search-toggle').on('click', function (e) {
            e.preventDefault();
            $('.search-popup').addClass('visible');
            $('#search-input').css('visibility', 'visible').focus();
        });
        $('.close-button').on('click', function (e) {
            e.preventDefault();
            $('.search-popup').removeClass('visible');
        });
    },
    SearchProcess: function () {
        $('#search-input').ghostHunter({
            results: "#search-results",
            displaySearchInfo: false,
            onKeyUp: true,
            result_template: '<div class="result-item"><a href="{{link}}"><i class="material-icons">&#xE145;</i>{{title}}</a></div>',
        });
    },
    clickRipple: function () {
        $('.ripple').on('click', function (event) {
            // event.preventDefault();
            console.log($(this).height());
            var $div = $('<span/>');
            var btnOffset = $(this).offset();
            var xPos = event.pageX - btnOffset.left;
            var yPos = event.pageY - btnOffset.top;
            console.log(xPos, yPos);
            $div.addClass('ripple-effect');
            var $ripple = $(".ripple-effect");
            $ripple.css("height", $(this).height());
            $ripple.css("width", $(this).height());
            $div.css({
                top: yPos - ($ripple.height() / 2),
                left: xPos - ($ripple.width() / 2),
                background: $(this).data("ripple-color")
            }).appendTo($(this));
            window.setTimeout(function () {
                $div.remove();
            }, 1000);
        });
    },
    backToTop: function () {
        $(window).scroll(function () {
            if ($(this).scrollTop() > 100) {
                $('#back-to-top').fadeIn();
            } else {
                $('#back-to-top').fadeOut();
            }
        });
        $('#back-to-top').on('click', function (e) {
            e.preventDefault();
            $('html, body').animate({ scrollTop: 0 }, 1000);
            return false;
        });
    },

    init: function () {
        themeApp.darkScheme();
        themeApp.featuredMedia();
        themeApp.responsiveIframe();
        themeApp.navStyle();
        themeApp.navScroll();
        themeApp.shareToggle();
        themeApp.gatherData();
        themeApp.matrerialInput();
        themeApp.mailchimp();
        themeApp.highlighter();
        themeApp.searchPopup();
        themeApp.SearchProcess();
        themeApp.clickRipple();
        themeApp.backToTop();
    }
}

/*===========================
2. Initialization
==========================*/
$(document).ready(function () {
    themeApp.init();
});

var render = {};
render.Post = function (id, callback) {
    $.get('/Render/Post/' + id, {}, function (data) {
        if ($('[data-id="' + id + '"]').length == 0)
            $('.lst-posts').append(data);
        else
            $('[data-id="' + id + '"]').html($(data).html());
        callback();
    });
};

function popResult(txt) {
    var msg = $('<div class="msg hide">' + txt + '</div>');
    msg.css('left', '50%');
    $('body').append(msg);
    msg.css('margin-left', '-' + parseInt(msg.outerWidth() / 2) + 'px');
    msg.removeClass('hide');
    setTimeout(function () {
        msg.addClass('hide');
        setTimeout(function () {
            msg.remove();
        }, 400);
    }, 2600);
}

function openTab(selector, openId, action, page) {
    if (!page) {
        $('.profile-tabs-section').hide();
    }
    if (action) {
        $(selector).html('');
        $.get('/Render/' + action + '/' + openId, { p: page || 1 }, function (data) {
            var html = $(data);
            var anchors = html.children('ul').find('a');
            for (var i = 0; i < anchors.length; i++) {
                var dom = $(anchors[i]);
                var _page = dom.attr('href').substr(dom.attr('href').lastIndexOf('?p=') + 3);
                if (_page == page && dom.text() != '«' && dom.text() != '»') {
                    dom.parent().addClass('active');
                }
                dom.attr('href', 'javascript:;');
                dom.unbind('click').bind('click', function () {
                    openTab(selector, openId, action, _page);
                    return false;
                });
            }
            html.appendTo($(selector));
            $(selector).show();
        });
    }
    else {
        $(selector).show();
    }
}

$(document).ready(function () {
    $('.profile-tabs-item').click(function () {
        $('.profile-tabs-item').removeClass('active');
        $(this).addClass('active');
    });

    var tabs = $('.profile-tabs-item');
    if (tabs.length > 0) {
        $(tabs[0]).click();
    }
});

$(document).ready(function () {
    themeApp.init();

    $('.btn-close').click(function () {
        $(this).parents('.dialog').addClass('hide');
    });
});

function popResult(txt) {
    var msg = $('<div class="msg hide">' + txt + '</div>');
    msg.css('left', '50%');
    $('body').append(msg);
    msg.css('margin-left', '-' + parseInt(msg.outerWidth() / 2) + 'px');
    msg.removeClass('hide');
    setTimeout(function () {
        msg.addClass('hide');
        setTimeout(function () {
            msg.remove();
        }, 400);
    }, 2600);
}

$(document).ready(function () {
    BindingDateTime();
});

function _bindSingle(dom) {
    var time = parseInt(dom.attr('datetime'));
    dom.html(new Date(time - new Date().getTimezoneOffset() * 60 * 1000));
    var now = new Date().getTime() - new Date().getTimezoneOffset() * 60 * 1000;
    var span = now - time;
    if (span == 0) {
        if (dom.html() != SR("Now"))
            dom.html(SR("Now"));
    }
    else if (span > 0) {
        var _span = span / 1000;
        if (_span < 60) {
            if (dom.html() != SR("{0} seconds ago", parseInt(_span)))
                dom.html(SR("{0} seconds ago", parseInt(_span)));
            return;
        }
        _span = _span / 60;
        if (_span < 60) {
            if (dom.html() != SR("{0} minutes ago", parseInt(_span)))
                dom.html(SR("{0} minutes ago", parseInt(_span)));
            return;
        }
        _span = _span / 60;
        if (_span < 24) {
            if (dom.html() != SR("{0} hours ago", parseInt(_span)))
                dom.html(SR("{0} hours ago", parseInt(_span)));
            return;
        }
        _span = _span / 24;
        if (_span < 30) {
            if (dom.html() != SR("{0} days ago", parseInt(_span)))
                dom.html(SR("{0} days ago", parseInt(_span)));
            return;
        }
        _span = _span / 30;
        if (_span < 12) {
            if (dom.html() != SR("{0} months ago", parseInt(_span)))
                dom.html(SR("{0} months ago", parseInt(_span)));
            return;
        }
        _span = _span / 12;
        if (dom.html() != SR("{0} years ago", parseInt(_span)))
            dom.html(SR("{0} years ago", parseInt(_span)));
        return;
    }
    else {
        var _span = -span;
        _span = _span / 1000;
        if (_span < 60) {
            if (dom.html() != SR("{0} seconds later", parseInt(_span)))
                dom.html(SR("{0} seconds later", parseInt(_span)));
            return;
        }
        _span = _span / 60;
        if (_span < 60) {
            if (dom.html() != SR("{0} minutes later", parseInt(_span)))
                dom.html(SR("{0} minutes later", parseInt(_span)));
            return;
        }
        _span = _span / 60;
        if (_span < 24) {
            if (dom.html() != SR("{0} hours later", parseInt(_span)))
                dom.html(SR("{0} hours later", parseInt(_span)));
            return;
        }
        _span = _span / 24;
        if (_span < 30) {
            if (dom.html() != SR("{0} days later", parseInt(_span)))
                dom.html(SR("{0} days later", parseInt(_span)));
            return;
        }
        _span = _span / 30;
        if (_span < 12) {
            if (dom.html() != SR("{0} months later", parseInt(_span)))
                dom.html(SR("{0} months later", parseInt(_span)));
            return;
        }
        _span = _span / 12;
        if (dom.html() != SR("{0} years later", parseInt(_span)))
            dom.html(SR("{0} years later", parseInt(_span)));
        return;
    }

}

function BindingDateTime() {
    setInterval(function () {
        var datetime = $('[datetime]');
        for (var i = 0; i < datetime.length; i++) {
            _bindSingle($(datetime[i]));
        }
    }, 1000);
}